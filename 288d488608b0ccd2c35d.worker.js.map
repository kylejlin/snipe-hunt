{"version":3,"sources":["../webpack/bootstrap","../node_modules/rusty-ts/dist/index.js","../node_modules/rusty-ts/dist/private/OptionImpl.js","../node_modules/rusty-ts/dist/private/ResultImpl.js","../node_modules/rusty-ts/dist/private/UnwrapError.js","bitwiseUtils.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","types.ts","cardMaps.ts","randInt.ts","gameUtil.ts","stateAnalyzer.ts","mcts.ts","workers/mcts.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__importDefault","this","mod","OptionImpl_1","require","ResultImpl_1","optionDotAll","options","values","length","option_1","isSome","default","none","push","some","resultDotAll","results","result_1","isOk","safeUnwrap","ok","option","all","fromVoidable","voidable","undefined","result","err","error","UnwrapError_1","OptionImpl","isNone_","match","matcher","isNone","map","mapper","_this","ifSome","executor","ifNone","unwrap","expect","message","unwrapOr","defaultValue","unwrapOrElse","defaultValueThunk","and","other","andThen","flatMapper","or","orElse","otherThunk","filter","predicate","flatten","innerOption","array","xor","transpose","res","e","equalsSome","v","someSatisfies","ResultImpl","isErr_","isErr","mapErr","ifOk","ifErr","safeUnwrapErr","unwrapErr","expectErr","unwrapOrThrowErr","unwrapErrOrThrowOk","opt","okSatisfies","errSatisfies","reverse","__extends","extendStatics","b","setPrototypeOf","__proto__","Array","__","constructor","UnwrapError","_super","Error","Offset","Filter","PlyTag","_arrayLikeToArray","arr","len","arr2","_unsupportedIterableToArray","minLen","toString","slice","from","test","_slicedToArray","isArray","iterator","_arr","_n","_d","_e","_s","_i","next","done","TypeError","_createForOfIteratorHelper","F","f","it","normalCompletion","didErr","step","_e2","_defineProperty","obj","configurable","writable","bitCount","SuggestionDetailLevel","CardLocation","CardType","allCardLocations","AlphaReserve","Row1","Row2","Row3","Row4","Row5","Row6","BetaReserve","allRows","Player","allAnimalTypes","Mouse1","Ox1","Tiger1","Rabbit1","Dragon1","Snake1","Horse1","Ram1","Monkey1","Rooster1","Dog1","Boar1","Fish1","Elephant1","Squid1","Frog1","Mouse2","Ox2","Tiger2","Rabbit2","Dragon2","Snake2","Horse2","Ram2","Monkey2","Rooster2","Dog2","Boar2","Fish2","Elephant2","Squid2","Frog2","PlyType","IllegalGameStateUpdate","Element","ElementCount","TripletShift","MctsWorkerMessageType","legalRetreaterDrops","Alpha","Beta","cardProperties","elements","double","Fire","single","Earth","elementCounts","F2","E1","tripletShifts","canRetreat","Water","E2","W1","F3","None","Air","A2","A3","W2","A1","F1","W3","E3","AlphaSnipe","BetaSnipe","randInt","inclMin","exclMax","diff","Math","floor","random","isReserve","location","cardType","opponentOf","player","snipeOf","oneRowForward","row","oneRowBackward","isRow","decodePly","ply","LeastThreeBits","SnipeStep","destination","plyType","Drop","LeastFiveBits","dropped","TwoAnimalSteps","firstCardType","firstDestination","secondCardType","secondDestination","first","moved","second","getStateAnalyzer","initState","state","getInitialState","stateVersion","initialBoard","currentBoard","turn","plies","pendingAnimalStep","getBoard","board","cards","alphaAnimals","AlphaAnimals","betaAnimals","BetaAnimals","forEach","animalType","allegiance","snipes","Snipes","getPlies","getPendingAnimalStep","isGameOver","getWinner","getTurn","getCardLocation","tryUndoSubPly","NothingToUndo","outOfSyncState","cloneState","undone","newState","recalculateOutOfSyncGameState","pop","encodedFirstStep","tryPerform","atomic","isEitherSnipeCaptured","SnipeAlreadyCaptured","getAnimalLocation","MovedCardInReserve","friendlyAnimals","NotYourAnimal","isInRange","StepDestinationOutOfRange","CannotMoveSameAnimalTwice","activatesTriplet","doesStepActivateTriplet","destSnipes","enemySnipeFilter","enemySnipeInDest","sourceAnimals","sourceSnipes","doesSourceRowHaveAnotherCard","friendlySnipeFilter","friendlySnipeInDest","CannotCaptureOwnSnipeWithoutAlsoCapturingOpponents","CannotEmptyRowWithoutImmediatelyWinning","AlreadyMovedAnimal","getSnipeLocation","animals","reserveAnimals","includes","CannotDropRetreaterOnEnemysBackTwoRows","CannotEmptyReserve","DroppedAnimalNotInReserve","getReasonWhyAtomicIsIllegal","forcePerform","serialize","toNodeKey","String","fromCharCode","LeastSixteenBits","LeastBit","setState","getLegalAtomics","isAlphaSnipeCapturedByBeta","isBetaSnipeCapturedByAlpha","atomics","snipeLocation","forward","backward","reserve","doesRowHaveAtLeastTwoCards","forwardSnipes","backwardSnipes","oldAnimals","newAnimal","rowElementCounts","shift1","shift2","snipeFilter","animalFilter","originalMutState","mutState","stateAnalyzer","Int32Array","encodedPendingAnimalStep","movedType","movedAllegiance","start","friendlyOffset","destAnimalsBeforeStep","movedSet","removeMovedFilter","friendlyReserve","destSnipesBeforeStep","enemyOffset","encodePlyWithIncorrectTag","forcePerformAnimalStep","friendlySnipeLocation","friendlySnipeSet","removeFriendlySnipeFilter","forcePerformSnipeStep","drop","droppedSet","removeDroppedFilter","forcePerformDrop","src","JSON","stringify","_key","NodeOffsets","QuicklyPerformableAtomicType","EXPLORATION_CONSTANT","sqrt","getMctsAnalyzerIfStateIsNonTerminal","rootState","turnNumber","heapSizeInI32s","heap","mallocIndex","ParentIndex","Atomic","Value","Rollouts","ChildListStartIndex","writeRootState","uninitialized","getMctsAnalyzerFromInternalDataWithoutInitializing","heapBuffer","buffer","performRollout","getMctsAnalyzerForNonTerminalState","internalData","tempState","nodeIndex","isLeaf","selectBestChild","leafIndex","getRollouts","rolloutIfNonTerminalThenBackPropagate","winner","getImmediateWinner","updateAndBackPropagateRollout","markAsEffectivelyTerminal","childIndexes","subarray","atomicsLen","childIndex","malloc","createChildOf","childIndexesLen","childListStartIndex","addChildrenAndRolloutFirstChild","getRootPointer","getNodeSummary","getChildPointersFromBestToWorst","pointer","SnipeSetsTurnNumberAndMovedAnimal","LeastTenBits","optActivePlayer","childListLen","indexesAndScores","optWinner","getEffectiveWinner","score","Infinity","childTurn","childRollouts","index","sort","a","scoreIndex","getSnapshot","root","childWithBestAtomic","bestChildIndex","rootActivePlayer","rootInactivePlayer","rootChildListStartIndex","rootChildListLen","getIndexOfChildWithBestAtomic","decodeAtomic","rollouts","getSummaryOfChildWithBestAtomic","currentStateValue","currentStateRollouts","bestAtomic","bestAtomicValue","bestAtomicRollouts","getInternalData","childCount","nodeRollouts","turnNumberAndMovedAnimal","activePlayer","inactivePlayer","bestIndex","getNthElementOfChildList","bestScore","getUcbScore","childScore","set","copyNodeStateIntoTempState","legalAtomics","performAtomic","rollout","out","etc","activePlayerLegalRetreaterDrops","getOptMovedAnimal","snipeCannotBeFound","console","log","activeSnipeLocation","getActiveSnipeLocation","qp_atomicType","qp_activePlayer","qp_snipeLocation","reserveAnimalSet","getReserveAnimalSet","destinations","destinationsLen","startIndex","friendlyAnimalSet","animalSet","LeastTwoBits","previouslyMovedAnimal","isForwardRow","isForwardNotRow","forwardSnipesAndExtraneousGreaterBits","isFriendlySnipeInForwardRow","isEnemySnipeInForwardRow","isBackwardRow","isBackwardNotRow","backwardSnipesAndExtraneousGreaterBits","isFriendlySnipeInBackwardRow","isEnemySnipeInBackwardRow","doesForwardStepActivateTriplet","canThisAnimalRetreat","canThisAnimalActivateTripletByRetreating","AnimalStep","qp_startIndex","qp_inactivePlayer","qp_doesStepActivateTriplet","activeSnipe","getReserveIndex","debug_before","snipe","debug_after","performSnipeStep","reserveIndex","performDrop","destAlphaIndex","capturedSnipesSet","performAnimalStep","offset","enemySnipeSet","hasAtLeastOneLegalAtomic","space","address","destIndex","encodeAtomic","encoded","tag","parentRollouts","getValue","parentIndex","getActivePlayerOfNonTerminalState","winnerBits","getParentIndex","etcIndex","optMctsAnalyzer","lastPosted","optStopTime","self","addEventListener","data","messageType","UpdateGameStateRequest","newGameState","gameState","NODE_SIZE_IN_I32S","thinkingTimeInMS","Number","isFinite","Date","now","stopTimeNotification","StopTimeChangeNotification","postMessage","updateOptStopTime","onGameStateUpdateRequest","PauseAnalyzerRequest","mctsAnalyzer","PauseAnalyzerResponse","ResumeAnalyzerRequest","onResumeAnalyzerRequest","analysisUpdateLoop","UpdateSnapshotNotification","optSnapshot","analyzer","meanValue","isTerminal","isOutOfThinkingTime","stopTime","postAnalysisUpdate","requestAnimationFrame"],"mappings":"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","file":"288d488608b0ccd2c35d.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OptionImpl_1 = __importDefault(require(\"./private/OptionImpl\"));\nvar ResultImpl_1 = __importDefault(require(\"./private/ResultImpl\"));\nexports.option = {\n    /**\n     * Returns a `some` variant that wraps the provided value.\n     *\n     * Corresponds to Rust's `Option::<T>::Some(T)`.\n     */\n    some: function (value) {\n        return OptionImpl_1.default.some(value);\n    },\n    /**\n     * Returns the `none` variant.\n     *\n     * Corresponds to Rust's `Option::None`.\n     */\n    none: function () {\n        return OptionImpl_1.default.none();\n    },\n    /**\n     * Transposes an array of options into an optional array,\n     * analagous to how `Promise.all()` transposes\n     * an array of promises into promised array.\n     *\n     * If every option is `some`, this method returns `option.some(arr)`\n     * where `arr` is an array of the unwrapped `Option`s.\n     * Otherwise, this method returns `option.none()`.\n     *\n     * @param options A tuple or array of options.\n     */\n    all: optionDotAll,\n    /**\n     * Accepts one argument `t`, returning `none` if the `t`\n     * is `null` or `undefined` , otherwise returning `some(t)`.\n     */\n    fromVoidable: function (voidable) {\n        if (voidable === undefined || voidable === null) {\n            return OptionImpl_1.default.none();\n        }\n        else {\n            return OptionImpl_1.default.some(voidable);\n        }\n    },\n};\nfunction optionDotAll(options) {\n    var values = [];\n    for (var i = 0; i < options.length; i++) {\n        var option_1 = options[i];\n        if (option_1.isSome()) {\n            values.push(option_1.value);\n        }\n        else {\n            return OptionImpl_1.default.none();\n        }\n    }\n    return OptionImpl_1.default.some(values);\n}\nexports.optionDotAll = optionDotAll;\nexports.result = {\n    /**\n     * Returns an `ok` variant that wraps the provided value.\n     *\n     * Corresponds to Rust's `Result::<T, E>::Ok(T)`.\n     */\n    ok: function (value) {\n        return ResultImpl_1.default.ok(value);\n    },\n    /**\n     * Returns an `err` variant that wraps the provided value.\n     *\n     * Corresponds to Rust's `Result::<T, E>::Err(E)`.\n     */\n    err: function (error) {\n        return ResultImpl_1.default.err(error);\n    },\n    /**\n     * Transposes an array of results into an result with an array,\n     * analagous to how `Promise.all()` transposes\n     * an array of promises into promised array.\n     *\n     * If every result is `ok`, this method returns `result.ok(arr)`\n     * where `arr` is an array of the unwrapped `Result`s.\n     * Otherwise, this method returns `result.err(e)` where `e` is\n     * the error value of the first result in the array that was an `err`.\n     *\n     * @param results A tuple or array of results.\n     */\n    all: resultDotAll,\n};\nfunction resultDotAll(results) {\n    var values = [];\n    for (var i = 0; i < results.length; i++) {\n        var result_1 = results[i];\n        if (result_1.isOk()) {\n            values.push(result_1.safeUnwrap());\n        }\n        else {\n            return result_1;\n        }\n    }\n    return ResultImpl_1.default.ok(values);\n}\nexports.resultDotAll = resultDotAll;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ResultImpl_1 = __importDefault(require(\"./ResultImpl\"));\nvar UnwrapError_1 = __importDefault(require(\"./UnwrapError\"));\nvar OptionImpl = /** @class */ (function () {\n    function OptionImpl(isNone_, value) {\n        this.isNone_ = isNone_;\n        this.value = value;\n    }\n    OptionImpl.some = function (value) {\n        return new OptionImpl(false, value);\n    };\n    OptionImpl.none = function () {\n        return new OptionImpl(true, undefined);\n    };\n    OptionImpl.prototype.match = function (matcher) {\n        if (this.isNone()) {\n            return matcher.none();\n        }\n        else {\n            return matcher.some(this.value);\n        }\n    };\n    OptionImpl.prototype.isNone = function () {\n        return this.isNone_;\n    };\n    OptionImpl.prototype.isSome = function () {\n        return !this.isNone();\n    };\n    OptionImpl.prototype.map = function (mapper) {\n        var _this = this;\n        return this.match({\n            none: function () { return _this; },\n            some: function (value) { return OptionImpl.some(mapper(value)); },\n        });\n    };\n    OptionImpl.prototype.ifSome = function (executor) {\n        this.map(executor);\n    };\n    OptionImpl.prototype.ifNone = function (executor) {\n        if (this.isNone()) {\n            executor();\n        }\n    };\n    OptionImpl.prototype.unwrap = function () {\n        return this.expect(\"Tried to call unwrap() on option.none()\");\n    };\n    OptionImpl.prototype.expect = function (message) {\n        return this.match({\n            none: function () {\n                var error = \"string\" === typeof message ? new UnwrapError_1.default(message) : message;\n                throw error;\n            },\n            some: function (value) { return value; },\n        });\n    };\n    OptionImpl.prototype.unwrapOr = function (defaultValue) {\n        return this.match({\n            none: function () { return defaultValue; },\n            some: function (value) { return value; },\n        });\n    };\n    OptionImpl.prototype.unwrapOrElse = function (defaultValueThunk) {\n        return this.match({\n            none: function () { return defaultValueThunk(); },\n            some: function (value) { return value; },\n        });\n    };\n    OptionImpl.prototype.and = function (other) {\n        return this.match({\n            none: function () { return OptionImpl.none(); },\n            some: function () { return other; },\n        });\n    };\n    OptionImpl.prototype.andThen = function (flatMapper) {\n        return this.match({\n            none: function () { return OptionImpl.none(); },\n            some: flatMapper,\n        });\n    };\n    OptionImpl.prototype.or = function (other) {\n        var _this = this;\n        return this.match({\n            none: function () { return other; },\n            some: function () { return _this; },\n        });\n    };\n    OptionImpl.prototype.orElse = function (otherThunk) {\n        var _this = this;\n        return this.match({\n            none: otherThunk,\n            some: function () { return _this; },\n        });\n    };\n    OptionImpl.prototype.filter = function (predicate) {\n        var _this = this;\n        return this.andThen(function (value) { return (predicate(value) ? _this : OptionImpl.none()); });\n    };\n    OptionImpl.prototype.flatten = function () {\n        return this.andThen(function (innerOption) { return innerOption; });\n    };\n    OptionImpl.prototype.array = function () {\n        return this.match({ none: function () { return []; }, some: function (value) { return [value]; } });\n    };\n    OptionImpl.prototype.xor = function (other) {\n        var _this = this;\n        return this.match({\n            none: function () { return other; },\n            some: function () {\n                return other.match({\n                    none: function () { return _this; },\n                    some: function () { return OptionImpl.none(); },\n                });\n            },\n        });\n    };\n    OptionImpl.prototype.transpose = function () {\n        return this.match({\n            none: function () { return ResultImpl_1.default.ok(OptionImpl.none()); },\n            some: function (res) {\n                return res.match({\n                    ok: function (t) { return ResultImpl_1.default.ok(OptionImpl.some(t)); },\n                    err: function (e) { return ResultImpl_1.default.err(e); },\n                });\n            },\n        });\n    };\n    OptionImpl.prototype.equalsSome = function (other) {\n        return this.match({\n            none: function () { return false; },\n            some: function (v) { return v === other; },\n        });\n    };\n    OptionImpl.prototype.someSatisfies = function (predicate) {\n        return this.match({\n            none: function () { return false; },\n            some: predicate,\n        });\n    };\n    return OptionImpl;\n}());\nexports.default = OptionImpl;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OptionImpl_1 = __importDefault(require(\"./OptionImpl\"));\nvar UnwrapError_1 = __importDefault(require(\"./UnwrapError\"));\nvar ResultImpl = /** @class */ (function () {\n    function ResultImpl(isErr_, value) {\n        this.isErr_ = isErr_;\n        this.value = value;\n    }\n    ResultImpl.ok = function (value) {\n        return new ResultImpl(false, value);\n    };\n    ResultImpl.err = function (error) {\n        return new ResultImpl(true, error);\n    };\n    ResultImpl.prototype.match = function (matcher) {\n        if (this.isErr_) {\n            return matcher.err(this.value);\n        }\n        else {\n            return matcher.ok(this.value);\n        }\n    };\n    ResultImpl.prototype.ok = function () {\n        return this.match({\n            ok: function (t) { return OptionImpl_1.default.some(t); },\n            err: function () { return OptionImpl_1.default.none(); },\n        });\n    };\n    ResultImpl.prototype.err = function () {\n        return this.match({\n            ok: function () { return OptionImpl_1.default.none(); },\n            err: function (e) { return OptionImpl_1.default.some(e); },\n        });\n    };\n    ResultImpl.prototype.isOk = function () {\n        return !this.isErr_;\n    };\n    ResultImpl.prototype.isErr = function () {\n        return this.isErr_;\n    };\n    ResultImpl.prototype.map = function (mapper) {\n        var _this = this;\n        return this.match({\n            ok: function (t) { return ResultImpl.ok(mapper(t)); },\n            err: function () { return _this; },\n        });\n    };\n    ResultImpl.prototype.mapErr = function (mapper) {\n        var _this = this;\n        return this.match({\n            err: function (e) { return ResultImpl.err(mapper(e)); },\n            ok: function () { return _this; },\n        });\n    };\n    ResultImpl.prototype.ifOk = function (executor) {\n        this.map(executor);\n    };\n    ResultImpl.prototype.ifErr = function (executor) {\n        this.mapErr(executor);\n    };\n    ResultImpl.prototype.unwrap = function () {\n        return this.expect(\"Tried to call unwrap() on result.err()\");\n    };\n    ResultImpl.prototype.safeUnwrap = function () {\n        return this.value;\n    };\n    ResultImpl.prototype.safeUnwrapErr = function () {\n        return this.value;\n    };\n    ResultImpl.prototype.unwrapErr = function () {\n        return this.expectErr(\"Tried to call unwrapErr() on result.ok()\");\n    };\n    ResultImpl.prototype.unwrapOrThrowErr = function () {\n        return this.match({\n            ok: function (t) { return t; },\n            err: function (e) {\n                throw e;\n            },\n        });\n    };\n    ResultImpl.prototype.unwrapErrOrThrowOk = function () {\n        return this.match({\n            ok: function (t) {\n                throw t;\n            },\n            err: function (e) { return e; },\n        });\n    };\n    ResultImpl.prototype.expect = function (message) {\n        return this.match({\n            ok: function (value) { return value; },\n            err: function () {\n                var error = \"string\" === typeof message ? new UnwrapError_1.default(message) : message;\n                throw error;\n            },\n        });\n    };\n    ResultImpl.prototype.expectErr = function (message) {\n        return this.match({\n            ok: function () {\n                var error = \"string\" === typeof message ? new UnwrapError_1.default(message) : message;\n                throw error;\n            },\n            err: function (value) { return value; },\n        });\n    };\n    ResultImpl.prototype.unwrapOr = function (defaultValue) {\n        return this.match({\n            ok: function (value) { return value; },\n            err: function () { return defaultValue; },\n        });\n    };\n    ResultImpl.prototype.unwrapOrElse = function (defaultValueThunk) {\n        var _this = this;\n        return this.match({\n            ok: function (value) { return value; },\n            err: function () { return defaultValueThunk(_this.value); },\n        });\n    };\n    ResultImpl.prototype.and = function (other) {\n        var _this = this;\n        return this.match({\n            ok: function () { return other; },\n            err: function () { return _this; },\n        });\n    };\n    ResultImpl.prototype.andThen = function (flatMapper) {\n        var _this = this;\n        return this.match({\n            ok: flatMapper,\n            err: function () { return _this; },\n        });\n    };\n    ResultImpl.prototype.or = function (other) {\n        var _this = this;\n        return this.match({\n            ok: function () { return _this; },\n            err: function () { return other; },\n        });\n    };\n    ResultImpl.prototype.orElse = function (otherThunk) {\n        var _this = this;\n        return this.match({\n            ok: function () { return _this; },\n            err: otherThunk,\n        });\n    };\n    ResultImpl.prototype.array = function () {\n        return this.match({\n            ok: function (t) { return [t]; },\n            err: function () { return []; },\n        });\n    };\n    ResultImpl.prototype.transpose = function () {\n        return this.match({\n            ok: function (opt) {\n                return opt.match({\n                    some: function (t) { return OptionImpl_1.default.some(ResultImpl.ok(t)); },\n                    none: function () { return OptionImpl_1.default.none(); },\n                });\n            },\n            err: function (e) { return OptionImpl_1.default.some(ResultImpl.err(e)); },\n        });\n    };\n    ResultImpl.prototype.okSatisfies = function (predicate) {\n        return this.ok().match({\n            some: predicate,\n            none: function () { return false; },\n        });\n    };\n    ResultImpl.prototype.errSatisfies = function (predicate) {\n        return this.err().match({\n            some: predicate,\n            none: function () { return false; },\n        });\n    };\n    ResultImpl.prototype.reverse = function () {\n        return this.match({\n            ok: function (t) { return ResultImpl.err(t); },\n            err: function (e) { return ResultImpl.ok(e); },\n        });\n    };\n    return ResultImpl;\n}());\nexports.default = ResultImpl;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * An error that occurs when `unwrap()` or `expect()`\n * is called on `option.none()` or `result.err()`, or\n * `unwrapErr()` or `expectErr()` is called on `result.ok()`.\n */\nvar UnwrapError = /** @class */ (function (_super) {\n    __extends(UnwrapError, _super);\n    function UnwrapError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = \"UnwrapError\";\n        return _this;\n    }\n    return UnwrapError;\n}(Error));\nexports.default = UnwrapError;\n","export enum Offset {\n  AlphaAnimals = 0,\n  BetaAnimals = 1,\n  Snipes = 2,\n}\n\nexport enum Filter {\n  LeastBit = 0b1,\n  LeastTwoBits = 0b11,\n  LeastThreeBits = 0b111,\n  LeastFiveBits = 0b1_1111,\n  LeastSixBits = 0b11_1111,\n  LeastTenBits = 0b11_1111_1111,\n  LeastSixteenBits = 0b1111_1111_1111_1111,\n}\n\nexport enum PlyTag {\n  SnipeStep = 0b001,\n  Drop = 0b010,\n  TwoAnimalSteps = 0b011,\n}\n\n// https://stackoverflow.com/a/43122214/7215455\nexport function bitCount(n: number): number {\n  n = n - ((n >> 1) & 0x55555555);\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n  return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { Option, Result } from \"rusty-ts\";\nimport { MctsAnalyzerInternalData, MctsAnalyzer } from \"./mcts\";\n\n/**\n * Increment this when making breaking changes\n * to state interfaces to ensure seralized state\n * compatibility detection will continue to work.\n */\nexport const STATE_VERSION = 14;\n\nexport interface AppState {\n  gameState: GameState;\n  ux: {\n    selectedCardType: Option<CardType>;\n    futureSubPlyStack: FutureSubPlyStack;\n    analysisSuggestionDetailLevels: {\n      [pointer: number]: SuggestionDetailLevel;\n    };\n  };\n  mctsState: MctsState;\n  thinkingTimeInMS: Option<number>;\n  thinkingTimeInputValue: string;\n  stopTime: Option<number>;\n}\n\nexport interface GameState {\n  stateVersion: typeof STATE_VERSION;\n  initialBoard: Int32Array;\n  currentBoard: Int32Array;\n  turn: Player;\n  plies: number[];\n  pendingAnimalStep: number;\n}\n\nexport interface FutureSubPlyStack {\n  stateVersion: typeof STATE_VERSION;\n  atomics: Atomic[];\n}\n\nexport type MctsState = MctsRunningState | MctsPausedState;\n\nexport interface MctsRunningState {\n  isRunning: true;\n  mostRecentSnapshot: Option<MctsAnalysisSnapshot>;\n}\n\nexport interface MctsPausedState {\n  isRunning: false;\n  analyzer: MctsAnalyzer;\n  expandedNodeIndexes: number[];\n}\n\nexport interface MctsAnalysisSnapshot {\n  currentStateValue: number;\n  currentStateRollouts: number;\n\n  bestAtomic: Atomic;\n  bestAtomicValue: number;\n  bestAtomicRollouts: number;\n}\n\nexport enum SuggestionDetailLevel {\n  None = \"None\",\n  BestAction = \"BestAction\",\n  AllActions = \"AllActions\",\n}\n\nexport interface MctsService {\n  updateGameState(state: GameState, optThinkingTimeInMS: Option<number>): void;\n  pause(): void;\n  resume(analyzer: MctsAnalyzer): void;\n\n  onSnapshot(listener: (analysis: Option<MctsAnalysisSnapshot>) => void): void;\n  onPause(listener: (analyzer: MctsAnalyzer) => void): void;\n  onStopTimeChange(listener: (stopTime: Option<number>) => void): void;\n}\n\nexport interface GameStateAnalyzer {\n  getInitialState(): GameState;\n  getBoard(): Board;\n  getPlies(): Ply[];\n  getPendingAnimalStep(): Option<AnimalStep>;\n  isGameOver(): boolean;\n  getWinner(): Option<Player>;\n  getTurn(): Player;\n  getCardLocation(cardType: CardType): CardLocation;\n  tryUndoSubPly(): Result<\n    { newState: GameState; undone: SnipeStep | Drop | AnimalStep },\n    IllegalGameStateUpdate\n  >;\n  tryPerform(atomic: Atomic): Result<GameState, IllegalGameStateUpdate>;\n  serialize(): string;\n  toNodeKey(): string;\n  setState(state: GameState): void;\n  getLegalAtomics(): Atomic[];\n  forcePerform(atomic: Atomic): GameState;\n}\n\nexport enum CardLocation {\n  AlphaReserve = 0,\n  Row1 = 1,\n  Row2 = 2,\n  Row3 = 3,\n  Row4 = 4,\n  Row5 = 5,\n  Row6 = 6,\n  BetaReserve = 7,\n}\n\nexport const allCardLocations: CardLocation[] = [\n  CardLocation.AlphaReserve,\n  CardLocation.Row1,\n  CardLocation.Row2,\n  CardLocation.Row3,\n  CardLocation.Row4,\n  CardLocation.Row5,\n  CardLocation.Row6,\n  CardLocation.BetaReserve,\n];\n\nexport const allRows: Row[] = [\n  CardLocation.Row1,\n  CardLocation.Row2,\n  CardLocation.Row3,\n  CardLocation.Row4,\n  CardLocation.Row5,\n  CardLocation.Row6,\n];\n\nexport interface Board {\n  [CardLocation.AlphaReserve]: Card[];\n  [CardLocation.Row1]: Card[];\n  [CardLocation.Row2]: Card[];\n  [CardLocation.Row3]: Card[];\n  [CardLocation.Row4]: Card[];\n  [CardLocation.Row5]: Card[];\n  [CardLocation.Row6]: Card[];\n  [CardLocation.BetaReserve]: Card[];\n}\n\nexport interface Card {\n  cardType: CardType;\n  allegiance: Player;\n}\n\nexport enum CardType {\n  Mouse1 = 0,\n  Ox1 = 1,\n  Tiger1 = 2,\n  Rabbit1 = 3,\n  Dragon1 = 4,\n  Snake1 = 5,\n  Horse1 = 6,\n  Ram1 = 7,\n  Monkey1 = 8,\n  Rooster1 = 9,\n  Dog1 = 10,\n  Boar1 = 11,\n\n  Fish1 = 12,\n  Elephant1 = 13,\n  Squid1 = 14,\n  Frog1 = 15,\n\n  Mouse2 = 16,\n  Ox2 = 17,\n  Tiger2 = 18,\n  Rabbit2 = 19,\n  Dragon2 = 20,\n  Snake2 = 21,\n  Horse2 = 22,\n  Ram2 = 23,\n  Monkey2 = 24,\n  Rooster2 = 25,\n  Dog2 = 26,\n  Boar2 = 27,\n\n  Fish2 = 28,\n  Elephant2 = 29,\n  Squid2 = 30,\n  Frog2 = 31,\n\n  AlphaSnipe = 32,\n  BetaSnipe = 33,\n}\n\nexport const allAnimalTypes: AnimalType[] = [\n  CardType.Mouse1,\n  CardType.Ox1,\n  CardType.Tiger1,\n  CardType.Rabbit1,\n  CardType.Dragon1,\n  CardType.Snake1,\n  CardType.Horse1,\n  CardType.Ram1,\n  CardType.Monkey1,\n  CardType.Rooster1,\n  CardType.Dog1,\n  CardType.Boar1,\n\n  CardType.Fish1,\n  CardType.Elephant1,\n  CardType.Squid1,\n  CardType.Frog1,\n\n  CardType.Mouse2,\n  CardType.Ox2,\n  CardType.Tiger2,\n  CardType.Rabbit2,\n  CardType.Dragon2,\n  CardType.Snake2,\n  CardType.Horse2,\n  CardType.Ram2,\n  CardType.Monkey2,\n  CardType.Rooster2,\n  CardType.Dog2,\n  CardType.Boar2,\n\n  CardType.Fish2,\n  CardType.Elephant2,\n  CardType.Squid2,\n  CardType.Frog2,\n];\n\nexport type AnimalType = Exclude<CardType, SnipeType>;\n\nexport type SnipeType = CardType.AlphaSnipe | CardType.BetaSnipe;\n\nexport enum Player {\n  Alpha = 0,\n  Beta = 1,\n}\n\nexport interface LegalRetreaterDrops {\n  [Player.Alpha]: Row[];\n  [Player.Beta]: Row[];\n}\n\nexport const legalRetreaterDrops: LegalRetreaterDrops = {\n  [Player.Alpha]: [\n    CardLocation.Row1,\n    CardLocation.Row2,\n    CardLocation.Row3,\n    CardLocation.Row4,\n  ],\n  [Player.Beta]: [\n    CardLocation.Row3,\n    CardLocation.Row4,\n    CardLocation.Row5,\n    CardLocation.Row6,\n  ],\n};\n\nexport type Ply = SnipeStep | Drop | TwoAnimalSteps;\n\nexport enum PlyType {\n  SnipeStep,\n  Drop,\n  TwoAnimalSteps,\n}\n\nexport interface SnipeStep {\n  plyType: PlyType.SnipeStep;\n  destination: Row;\n}\n\nexport interface Drop {\n  plyType: PlyType.Drop;\n  dropped: AnimalType;\n  destination: Row;\n}\n\nexport interface TwoAnimalSteps {\n  plyType: PlyType.TwoAnimalSteps;\n  first: AnimalStep;\n  second: AnimalStep;\n}\n\nexport interface AnimalStep {\n  moved: AnimalType;\n  destination: Row;\n}\n\nexport type Atomic = SnipeStep | Drop | AnimalStep;\n\nexport type Row =\n  | CardLocation.Row1\n  | CardLocation.Row2\n  | CardLocation.Row3\n  | CardLocation.Row4\n  | CardLocation.Row5\n  | CardLocation.Row6;\n\nexport enum IllegalGameStateUpdate {\n  SnipeAlreadyCaptured,\n  AlreadyMovedAnimal,\n  StepDestinationOutOfRange,\n  CannotEmptyRowWithoutImmediatelyWinning,\n  DroppedAnimalNotInReserve,\n  CannotEmptyReserve,\n  CannotDropRetreaterOnEnemysBackTwoRows,\n  MovedCardInReserve,\n  NotYourAnimal,\n  CannotMoveSameAnimalTwice,\n  CannotCaptureOwnSnipeWithoutAlsoCapturingOpponents,\n\n  NothingToUndo,\n}\n\nexport interface StateSaver<T> {\n  getState(): Option<T>;\n  setState(state: T): void;\n}\n\nexport interface CardMap<T> {\n  [CardType.Mouse1]: T;\n  [CardType.Ox1]: T;\n  [CardType.Tiger1]: T;\n  [CardType.Rabbit1]: T;\n  [CardType.Dragon1]: T;\n  [CardType.Snake1]: T;\n  [CardType.Horse1]: T;\n  [CardType.Ram1]: T;\n  [CardType.Monkey1]: T;\n  [CardType.Rooster1]: T;\n  [CardType.Dog1]: T;\n  [CardType.Boar1]: T;\n\n  [CardType.Fish1]: T;\n  [CardType.Elephant1]: T;\n  [CardType.Squid1]: T;\n  [CardType.Frog1]: T;\n\n  [CardType.Mouse2]: T;\n  [CardType.Ox2]: T;\n  [CardType.Tiger2]: T;\n  [CardType.Rabbit2]: T;\n  [CardType.Dragon2]: T;\n  [CardType.Snake2]: T;\n  [CardType.Horse2]: T;\n  [CardType.Ram2]: T;\n  [CardType.Monkey2]: T;\n  [CardType.Rooster2]: T;\n  [CardType.Dog2]: T;\n  [CardType.Boar2]: T;\n\n  [CardType.Fish2]: T;\n  [CardType.Elephant2]: T;\n  [CardType.Squid2]: T;\n  [CardType.Frog2]: T;\n\n  [CardType.AlphaSnipe]: T;\n  [CardType.BetaSnipe]: T;\n}\n\nexport interface CardProperties {\n  elements: Option<{ double: Element; single: Element }>;\n  elementCounts: number;\n  tripletShifts: [TripletShift, TripletShift];\n  canRetreat: boolean;\n}\n\nexport enum Element {\n  Fire,\n  Water,\n  Earth,\n  Air,\n}\n\nexport enum ElementCount {\n  F1 = 1 << 0,\n  F2 = 1 << 1,\n  F3 = 1 << 2,\n\n  W1 = 1 << 3,\n  W2 = 1 << 4,\n  W3 = 1 << 5,\n\n  E1 = 1 << 6,\n  E2 = 1 << 7,\n  E3 = 1 << 8,\n\n  A1 = 1 << 9,\n  A2 = 1 << 10,\n  A3 = 1 << 11,\n}\n\nexport enum TripletShift {\n  Fire = 0,\n  Water = 3,\n  Earth = 6,\n  Air = 9,\n  None = 12,\n}\n\nexport type MctsWorkerRequest =\n  | UpdateGameStateRequest\n  | PauseAnalyzerRequest\n  | ResumeAnalyzerRequest;\n\nexport type MctsWorkerNotification =\n  | LogNotification\n  | UpdateSnapshotNotification\n  | PauseAnalyzerResponse\n  | StopTimeChangeNotification;\n\nexport enum MctsWorkerMessageType {\n  UpdateGameStateRequest,\n  PauseAnalyzerRequest,\n  ResumeAnalyzerRequest,\n\n  LogNotification,\n  UpdateSnapshotNotification,\n  PauseAnalyzerResponse,\n  StopTimeChangeNotification,\n}\n\nexport interface UpdateGameStateRequest {\n  messageType: MctsWorkerMessageType.UpdateGameStateRequest;\n  gameState: GameState;\n  thinkingTimeInMS: number;\n}\n\nexport interface PauseAnalyzerRequest {\n  messageType: MctsWorkerMessageType.PauseAnalyzerRequest;\n}\n\nexport interface ResumeAnalyzerRequest {\n  messageType: MctsWorkerMessageType.ResumeAnalyzerRequest;\n  internalData: MctsAnalyzerInternalData;\n}\n\nexport interface LogNotification {\n  messageType: MctsWorkerMessageType.LogNotification;\n  data: unknown;\n}\n\nexport interface UpdateSnapshotNotification {\n  messageType: MctsWorkerMessageType.UpdateSnapshotNotification;\n  optSnapshot: MctsAnalysisSnapshot | null;\n}\n\nexport interface PauseAnalyzerResponse {\n  messageType: MctsWorkerMessageType.PauseAnalyzerResponse;\n  internalData: MctsAnalyzerInternalData;\n}\n\nexport interface StopTimeChangeNotification {\n  messageType: MctsWorkerMessageType.StopTimeChangeNotification;\n  optStopTime: number | null;\n}\n","import { option } from \"rusty-ts\";\nimport {\n  CardType,\n  Element,\n  CardMap,\n  CardProperties,\n  ElementCount,\n  TripletShift,\n} from \"./types\";\n\nexport const cardProperties: CardMap<CardProperties> = {\n  [CardType.Mouse1]: {\n    elements: option.some({ double: Element.Fire, single: Element.Earth }),\n    elementCounts: ElementCount.F2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Earth],\n    canRetreat: true,\n  },\n  [CardType.Ox1]: {\n    elements: option.some({ double: Element.Earth, single: Element.Water }),\n    elementCounts: ElementCount.E2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Water],\n    canRetreat: false,\n  },\n  [CardType.Tiger1]: {\n    elements: option.some({ double: Element.Fire, single: Element.Fire }),\n    elementCounts: ElementCount.F3,\n    tripletShifts: [TripletShift.Fire, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Rabbit1]: {\n    elements: option.some({ double: Element.Air, single: Element.Water }),\n    elementCounts: ElementCount.A2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Air, TripletShift.Water],\n    canRetreat: true,\n  },\n  [CardType.Dragon1]: {\n    elements: option.some({ double: Element.Air, single: Element.Air }),\n    elementCounts: ElementCount.A3,\n    tripletShifts: [TripletShift.Air, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Snake1]: {\n    elements: option.some({ double: Element.Water, single: Element.Earth }),\n    elementCounts: ElementCount.W2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Water, TripletShift.Earth],\n    canRetreat: true,\n  },\n  [CardType.Horse1]: {\n    elements: option.some({ double: Element.Fire, single: Element.Air }),\n    elementCounts: ElementCount.F2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Air],\n    canRetreat: false,\n  },\n  [CardType.Ram1]: {\n    elements: option.some({ double: Element.Earth, single: Element.Air }),\n    elementCounts: ElementCount.E2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Air],\n    canRetreat: true,\n  },\n  [CardType.Monkey1]: {\n    elements: option.some({ double: Element.Air, single: Element.Earth }),\n    elementCounts: ElementCount.A2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Air, TripletShift.Earth],\n    canRetreat: false,\n  },\n  [CardType.Rooster1]: {\n    elements: option.some({ double: Element.Air, single: Element.Fire }),\n    elementCounts: ElementCount.A2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Air, TripletShift.Fire],\n    canRetreat: false,\n  },\n  [CardType.Dog1]: {\n    elements: option.some({ double: Element.Fire, single: Element.Water }),\n    elementCounts: ElementCount.F2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Water],\n    canRetreat: false,\n  },\n  [CardType.Boar1]: {\n    elements: option.some({ double: Element.Earth, single: Element.Fire }),\n    elementCounts: ElementCount.E2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Fire],\n    canRetreat: true,\n  },\n\n  [CardType.Fish1]: {\n    elements: option.some({ double: Element.Water, single: Element.Water }),\n    elementCounts: ElementCount.W3,\n    tripletShifts: [TripletShift.Water, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Elephant1]: {\n    elements: option.some({ double: Element.Earth, single: Element.Earth }),\n    elementCounts: ElementCount.E3,\n    tripletShifts: [TripletShift.Earth, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Squid1]: {\n    elements: option.some({ double: Element.Water, single: Element.Fire }),\n    elementCounts: ElementCount.W2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Water, TripletShift.Fire],\n    canRetreat: true,\n  },\n  [CardType.Frog1]: {\n    elements: option.some({ double: Element.Water, single: Element.Air }),\n    elementCounts: ElementCount.W2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Water, TripletShift.Air],\n    canRetreat: false,\n  },\n\n  [CardType.Mouse2]: {\n    elements: option.some({ double: Element.Fire, single: Element.Earth }),\n    elementCounts: ElementCount.F2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Earth],\n    canRetreat: true,\n  },\n  [CardType.Ox2]: {\n    elements: option.some({ double: Element.Earth, single: Element.Water }),\n    elementCounts: ElementCount.E2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Water],\n    canRetreat: false,\n  },\n  [CardType.Tiger2]: {\n    elements: option.some({ double: Element.Fire, single: Element.Fire }),\n    elementCounts: ElementCount.F3,\n    tripletShifts: [TripletShift.Fire, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Rabbit2]: {\n    elements: option.some({ double: Element.Air, single: Element.Water }),\n    elementCounts: ElementCount.A2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Air, TripletShift.Water],\n    canRetreat: true,\n  },\n  [CardType.Dragon2]: {\n    elements: option.some({ double: Element.Air, single: Element.Air }),\n    elementCounts: ElementCount.A3,\n    tripletShifts: [TripletShift.Air, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Snake2]: {\n    elements: option.some({ double: Element.Water, single: Element.Earth }),\n    elementCounts: ElementCount.W2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Water, TripletShift.Earth],\n    canRetreat: true,\n  },\n  [CardType.Horse2]: {\n    elements: option.some({ double: Element.Fire, single: Element.Air }),\n    elementCounts: ElementCount.F2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Air],\n    canRetreat: false,\n  },\n  [CardType.Ram2]: {\n    elements: option.some({ double: Element.Earth, single: Element.Air }),\n    elementCounts: ElementCount.E2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Air],\n    canRetreat: true,\n  },\n  [CardType.Monkey2]: {\n    elements: option.some({ double: Element.Air, single: Element.Earth }),\n    elementCounts: ElementCount.A2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Air, TripletShift.Earth],\n    canRetreat: false,\n  },\n  [CardType.Rooster2]: {\n    elements: option.some({ double: Element.Air, single: Element.Fire }),\n    elementCounts: ElementCount.A2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Air, TripletShift.Fire],\n    canRetreat: false,\n  },\n  [CardType.Dog2]: {\n    elements: option.some({ double: Element.Fire, single: Element.Water }),\n    elementCounts: ElementCount.F2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Water],\n    canRetreat: false,\n  },\n  [CardType.Boar2]: {\n    elements: option.some({ double: Element.Earth, single: Element.Fire }),\n    elementCounts: ElementCount.E2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Fire],\n    canRetreat: true,\n  },\n\n  [CardType.Fish2]: {\n    elements: option.some({ double: Element.Water, single: Element.Water }),\n    elementCounts: ElementCount.W3,\n    tripletShifts: [TripletShift.Water, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Elephant2]: {\n    elements: option.some({ double: Element.Earth, single: Element.Earth }),\n    elementCounts: ElementCount.E3,\n    tripletShifts: [TripletShift.Earth, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Squid2]: {\n    elements: option.some({ double: Element.Water, single: Element.Fire }),\n    elementCounts: ElementCount.W2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Water, TripletShift.Fire],\n    canRetreat: true,\n  },\n  [CardType.Frog2]: {\n    elements: option.some({ double: Element.Water, single: Element.Air }),\n    elementCounts: ElementCount.W2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Water, TripletShift.Air],\n    canRetreat: false,\n  },\n\n  [CardType.AlphaSnipe]: {\n    elements: option.none(),\n    elementCounts: 0,\n    tripletShifts: [TripletShift.None, TripletShift.None],\n    canRetreat: true,\n  },\n  [CardType.BetaSnipe]: {\n    elements: option.none(),\n    elementCounts: 0,\n    tripletShifts: [TripletShift.None, TripletShift.None],\n    canRetreat: true,\n  },\n};\n\nexport const cardEmojis: CardMap<string> = {\n  [CardType.Mouse1]: \"🐀\",\n  [CardType.Mouse2]: \"🐀\",\n  [CardType.Ox1]: \"🐮\",\n  [CardType.Ox2]: \"🐮\",\n  [CardType.Tiger1]: \"🐯\",\n  [CardType.Tiger2]: \"🐯\",\n  [CardType.Rabbit1]: \"🐇\",\n  [CardType.Rabbit2]: \"🐇\",\n  [CardType.Dragon1]: \"🐉 \",\n  [CardType.Dragon2]: \"🐉 \",\n  [CardType.Snake1]: \"🐍\",\n  [CardType.Snake2]: \"🐍\",\n  [CardType.Horse1]: \"🐴\",\n  [CardType.Horse2]: \"🐴\",\n  [CardType.Ram1]: \"🐏\",\n  [CardType.Ram2]: \"🐏\",\n  [CardType.Monkey1]: \"🐵\",\n  [CardType.Monkey2]: \"🐵\",\n  [CardType.Rooster1]: \"🐓\",\n  [CardType.Rooster2]: \"🐓\",\n  [CardType.Dog1]: \"🐶\",\n  [CardType.Dog2]: \"🐶\",\n  [CardType.Boar1]: \"🐗\",\n  [CardType.Boar2]: \"🐗\",\n  [CardType.Fish1]: \"🐟\",\n  [CardType.Fish2]: \"🐟\",\n  [CardType.Elephant1]: \"🐘\",\n  [CardType.Elephant2]: \"🐘\",\n  [CardType.Squid1]: \"🦑\",\n  [CardType.Squid2]: \"🦑\",\n  [CardType.Frog1]: \"🐸\",\n  [CardType.Frog2]: \"🐸\",\n\n  [CardType.AlphaSnipe]: \"α\",\n  [CardType.BetaSnipe]: \"β\",\n};\n","export default function randInt(inclMin: number, exclMax: number): number {\n  const diff = exclMax - inclMin;\n  return inclMin + Math.floor(diff * Math.random());\n}\n","import { Filter, PlyTag } from \"./bitwiseUtils\";\nimport { cardProperties } from \"./cardMaps\";\nimport { gameStateFactory } from \"./gameStateFactory\";\nimport randInt from \"./randInt\";\nimport {\n  AnimalStep,\n  AnimalType,\n  Atomic,\n  Card,\n  CardLocation,\n  CardType,\n  GameState,\n  Player,\n  Ply,\n  PlyType,\n  Row,\n  SnipeType,\n} from \"./types\";\n\nexport function getRandomGameState(): GameState {\n  const { alpha, beta } = getShuffledDecks();\n  return gameStateFactory.fromBoard({\n    [CardLocation.AlphaReserve]: [alpha.pop()!],\n    [CardLocation.Row1]: [\n      alpha.pop()!,\n      { cardType: CardType.AlphaSnipe, allegiance: Player.Alpha },\n      alpha.pop()!,\n    ],\n    [CardLocation.Row2]: [\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n    ],\n    [CardLocation.Row3]: [alpha.pop()!],\n\n    [CardLocation.Row4]: [beta.pop()!],\n    [CardLocation.Row5]: [\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n    ],\n    [CardLocation.Row6]: [\n      beta.pop()!,\n      { cardType: CardType.BetaSnipe, allegiance: Player.Beta },\n      beta.pop()!,\n    ],\n    [CardLocation.BetaReserve]: [beta.pop()!],\n  });\n}\n\nfunction getShuffledDecks(): { alpha: Card[]; beta: Card[] } {\n  const minors: CardType[] = [\n    CardType.Mouse1,\n    CardType.Ox1,\n    CardType.Rabbit1,\n    CardType.Snake1,\n    CardType.Horse1,\n    CardType.Ram1,\n    CardType.Monkey1,\n    CardType.Rooster1,\n    CardType.Dog1,\n    CardType.Boar1,\n\n    CardType.Squid1,\n    CardType.Frog1,\n\n    CardType.Mouse2,\n    CardType.Ox2,\n    CardType.Rabbit2,\n    CardType.Snake2,\n    CardType.Horse2,\n    CardType.Ram2,\n    CardType.Monkey2,\n    CardType.Rooster2,\n    CardType.Dog2,\n    CardType.Boar2,\n\n    CardType.Squid2,\n    CardType.Frog2,\n  ];\n  const majors: CardType[] = [\n    CardType.Tiger1,\n    CardType.Dragon1,\n    CardType.Fish1,\n    CardType.Elephant1,\n\n    CardType.Tiger2,\n    CardType.Dragon2,\n    CardType.Fish2,\n    CardType.Elephant2,\n  ];\n\n  shuffle(minors);\n  shuffle(majors);\n\n  const alpha: Card[] = minors\n    .slice(0, 12)\n    .concat(majors.slice(0, 4))\n    .map((cardType) => ({ cardType, allegiance: Player.Alpha }));\n  const beta: Card[] = minors\n    .slice(12)\n    .concat(majors.slice(4))\n    .map((cardType) => ({ cardType, allegiance: Player.Beta }));\n\n  shuffle(alpha);\n  shuffle(beta);\n\n  return { alpha, beta };\n}\n\nfunction shuffle(arr: unknown[]): void {\n  const SHUFFLE_REPETITIONS = 512;\n  const len = arr.length;\n\n  for (let k = 0; k < SHUFFLE_REPETITIONS; k++) {\n    for (let i = 0; i <= len - 2; i++) {\n      const j = randInt(i, len);\n      const temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n    }\n  }\n}\n\nexport function isReserve(\n  location: CardLocation\n): location is CardLocation.AlphaReserve | CardLocation.BetaReserve {\n  return (\n    location === CardLocation.AlphaReserve ||\n    location === CardLocation.BetaReserve\n  );\n}\n\nexport function canRetreat(cardType: CardType): boolean {\n  return cardProperties[cardType].canRetreat;\n}\n\nexport function opponentOf(player: Player): Player {\n  switch (player) {\n    case Player.Alpha:\n      return Player.Beta;\n    case Player.Beta:\n      return Player.Alpha;\n  }\n}\n\nexport function snipeOf(player: Player): SnipeType {\n  switch (player) {\n    case Player.Alpha:\n      return CardType.AlphaSnipe;\n    case Player.Beta:\n      return CardType.BetaSnipe;\n  }\n}\n\nexport function oneRowForward(row: Row, player: Player): CardLocation {\n  const diff = player === Player.Alpha ? 1 : -1;\n  return row + diff;\n}\n\nexport function oneRowBackward(row: Row, player: Player): CardLocation {\n  const diff = player === Player.Alpha ? -1 : 1;\n  return row + diff;\n}\n\nexport function isRow(location: CardLocation): location is Row {\n  return !(\n    location === CardLocation.AlphaReserve ||\n    location === CardLocation.BetaReserve\n  );\n}\n\nexport function decodePly(ply: number): Ply {\n  const tag = (ply & Filter.LeastThreeBits) as PlyTag;\n  switch (tag) {\n    case PlyTag.SnipeStep: {\n      const destination = ((ply >>> 3) & Filter.LeastThreeBits) as Row;\n      return { plyType: PlyType.SnipeStep, destination };\n    }\n\n    case PlyTag.Drop: {\n      const cardType = ((ply >>> 3) & Filter.LeastFiveBits) as AnimalType;\n      const destination = ((ply >>> 8) & Filter.LeastThreeBits) as Row;\n      return {\n        plyType: PlyType.Drop,\n        dropped: cardType,\n        destination,\n      };\n    }\n\n    case PlyTag.TwoAnimalSteps: {\n      const firstCardType = ((ply >>> 3) & Filter.LeastFiveBits) as AnimalType;\n      const firstDestination = ((ply >>> 8) & Filter.LeastThreeBits) as Row;\n      const secondCardType = ((ply >>> 11) &\n        Filter.LeastFiveBits) as AnimalType;\n      const secondDestination = ((ply >>> 16) & Filter.LeastThreeBits) as Row;\n      return {\n        plyType: PlyType.TwoAnimalSteps,\n        first: { moved: firstCardType, destination: firstDestination },\n        second: { moved: secondCardType, destination: secondDestination },\n      };\n    }\n  }\n}\n\nexport function isAnimalStep(atomic: Atomic): atomic is AnimalStep {\n  return !(\"plyType\" in atomic);\n}\n","import { Option, option, Result, result } from \"rusty-ts\";\nimport { bitCount, Filter, Offset, PlyTag } from \"./bitwiseUtils\";\nimport { cardProperties } from \"./cardMaps\";\nimport {\n  canRetreat,\n  decodePly,\n  isReserve,\n  isRow,\n  oneRowBackward,\n  oneRowForward,\n  opponentOf,\n  snipeOf,\n} from \"./gameUtil\";\nimport {\n  allAnimalTypes,\n  allCardLocations,\n  allRows,\n  AnimalStep,\n  AnimalType,\n  Atomic,\n  Board,\n  CardLocation,\n  CardType,\n  Drop,\n  GameStateAnalyzer,\n  GameState,\n  IllegalGameStateUpdate,\n  legalRetreaterDrops,\n  Player,\n  Ply,\n  PlyType,\n  Row,\n  SnipeStep,\n  SnipeType,\n} from \"./types\";\n\nexport function getStateAnalyzer(initState: GameState): GameStateAnalyzer {\n  let state = initState;\n\n  return {\n    getInitialState,\n    getBoard,\n    getPlies,\n    getPendingAnimalStep,\n    isGameOver,\n    getWinner,\n    getTurn,\n    getCardLocation,\n    tryUndoSubPly,\n    tryPerform,\n    serialize,\n    toNodeKey,\n    setState,\n    getLegalAtomics,\n    forcePerform,\n  };\n\n  function getInitialState(): GameState {\n    return {\n      stateVersion: state.stateVersion,\n      initialBoard: state.initialBoard,\n      currentBoard: state.initialBoard,\n      turn: Player.Beta,\n      plies: [],\n      pendingAnimalStep: 0,\n    };\n  }\n\n  function getBoard(): Board {\n    const board: Board = {\n      [CardLocation.AlphaReserve]: [],\n      [CardLocation.Row1]: [],\n      [CardLocation.Row2]: [],\n      [CardLocation.Row3]: [],\n      [CardLocation.Row4]: [],\n      [CardLocation.Row5]: [],\n      [CardLocation.Row6]: [],\n      [CardLocation.BetaReserve]: [],\n    };\n\n    for (const location of allCardLocations) {\n      const cards = board[location];\n\n      const alphaAnimals =\n        state.currentBoard[location * 3 + Offset.AlphaAnimals];\n      const betaAnimals = state.currentBoard[location * 3 + Offset.BetaAnimals];\n\n      allAnimalTypes.forEach((animalType) => {\n        if (((1 << animalType) & alphaAnimals) !== 0) {\n          cards.push({ cardType: animalType, allegiance: Player.Alpha });\n        }\n\n        if (((1 << animalType) & betaAnimals) !== 0) {\n          cards.push({ cardType: animalType, allegiance: Player.Beta });\n        }\n      });\n\n      const snipes = state.currentBoard[location * 3 + Offset.Snipes];\n\n      if (((1 << Player.Alpha) & snipes) !== 0) {\n        cards.push({ cardType: CardType.AlphaSnipe, allegiance: Player.Alpha });\n      }\n      if (((1 << Player.Beta) & snipes) !== 0) {\n        cards.push({ cardType: CardType.BetaSnipe, allegiance: Player.Beta });\n      }\n    }\n\n    return board;\n  }\n\n  function getPlies(): Ply[] {\n    return state.plies.map(decodePly);\n  }\n\n  function getPendingAnimalStep(): Option<AnimalStep> {\n    const { pendingAnimalStep } = state;\n\n    if (pendingAnimalStep === 0) {\n      return option.none();\n    }\n\n    const cardType = ((pendingAnimalStep >>> 3) &\n      Filter.LeastFiveBits) as AnimalType;\n    const destination = ((pendingAnimalStep >>> 8) &\n      Filter.LeastThreeBits) as Row;\n    return option.some({\n      moved: cardType,\n      destination,\n    });\n  }\n\n  function isGameOver(): boolean {\n    return getWinner().isSome();\n  }\n\n  function getWinner(): Option<Player> {\n    if (isAlphaSnipeCapturedByBeta()) {\n      return option.some(Player.Beta);\n    }\n\n    if (isBetaSnipeCapturedByAlpha()) {\n      return option.some(Player.Alpha);\n    }\n\n    if (getLegalAtomics().length === 0) {\n      return option.some(opponentOf(state.turn));\n    }\n\n    return option.none();\n  }\n\n  function isAlphaSnipeCapturedByBeta(): boolean {\n    const snipes =\n      state.currentBoard[CardLocation.BetaReserve * 3 + Offset.Snipes];\n    return ((1 << Player.Alpha) & snipes) !== 0;\n  }\n\n  function isBetaSnipeCapturedByAlpha(): boolean {\n    const snipes =\n      state.currentBoard[CardLocation.AlphaReserve * 3 + Offset.Snipes];\n    return ((1 << Player.Beta) & snipes) !== 0;\n  }\n\n  function getLegalAtomics(): Atomic[] {\n    if (isEitherSnipeCaptured()) {\n      return [];\n    }\n\n    const atomics: Atomic[] = [];\n\n    // Only add full plies if there is no pending subply\n    if (state.pendingAnimalStep === 0) {\n      // Snipe steps\n      {\n        const activeSnipe = snipeOf(state.turn);\n        const snipeLocation = getSnipeLocation(activeSnipe) as Row;\n        const animals =\n          state.currentBoard[snipeLocation * 3 + Offset.AlphaAnimals] |\n          state.currentBoard[snipeLocation * 3 + Offset.BetaAnimals];\n        const snipes = state.currentBoard[snipeLocation * 3 + Offset.Snipes];\n        const enemySnipeFilter = 1 << opponentOf(state.turn);\n        if ((snipes & enemySnipeFilter) | animals) {\n          const forward = oneRowForward(snipeLocation, state.turn);\n          if (isRow(forward)) {\n            atomics.push({\n              plyType: PlyType.SnipeStep,\n              destination: forward,\n            });\n          }\n\n          const backward = oneRowBackward(snipeLocation, state.turn);\n          if (isRow(backward)) {\n            atomics.push({\n              plyType: PlyType.SnipeStep,\n              destination: backward,\n            });\n          }\n        }\n      }\n\n      // Drops\n      {\n        const reserve =\n          state.turn === Player.Alpha\n            ? CardLocation.AlphaReserve\n            : CardLocation.BetaReserve;\n        const friendlyAnimals =\n          state.currentBoard[\n            reserve * 3 +\n              (state.turn === Player.Alpha\n                ? Offset.AlphaAnimals\n                : Offset.BetaAnimals)\n          ];\n\n        if (bitCount(friendlyAnimals) > 1) {\n          for (const cardType of allAnimalTypes) {\n            if ((1 << cardType) & friendlyAnimals) {\n              const desinations = canRetreat(cardType)\n                ? legalRetreaterDrops[state.turn]\n                : allRows;\n              for (const row of desinations) {\n                atomics.push({\n                  plyType: PlyType.Drop,\n                  dropped: cardType,\n                  destination: row,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Animal steps are always legal atomics, if there are any\n    for (const row of allRows) {\n      const friendlyAnimals =\n        state.currentBoard[\n          row * 3 +\n            (state.turn === Player.Alpha\n              ? Offset.AlphaAnimals\n              : Offset.BetaAnimals)\n        ];\n\n      if (!friendlyAnimals) {\n        continue;\n      }\n\n      const animals =\n        state.currentBoard[row * 3 + Offset.AlphaAnimals] |\n        state.currentBoard[row * 3 + Offset.BetaAnimals];\n      const snipes = state.currentBoard[row * 3 + Offset.Snipes];\n      const doesRowHaveAtLeastTwoCards = (bitCount(animals) >>> 1) | snipes;\n      const enemySnipeFilter =\n        state.turn === Player.Alpha ? 1 << Player.Beta : 1 << Player.Alpha;\n\n      for (const cardType of allAnimalTypes) {\n        if (\n          state.pendingAnimalStep &&\n          ((state.pendingAnimalStep >>> 3) & Filter.LeastFiveBits) === cardType\n        ) {\n          continue;\n        }\n\n        if ((1 << cardType) & friendlyAnimals) {\n          if (doesRowHaveAtLeastTwoCards) {\n            const friendlySnipeFilter =\n              state.turn === Player.Alpha\n                ? 1 << Player.Alpha\n                : 1 << Player.Beta;\n\n            const forward = oneRowForward(row, state.turn);\n            const forwardSnipes =\n              state.currentBoard[forward * 3 + Offset.Snipes];\n            if (\n              isRow(forward) &&\n              !(\n                forwardSnipes & friendlySnipeFilter &&\n                !(forwardSnipes & enemySnipeFilter) &&\n                doesStepActivateTriplet(\n                  state.currentBoard[forward * 3 + Offset.AlphaAnimals] |\n                    state.currentBoard[forward * 3 + Offset.BetaAnimals],\n                  cardType\n                )\n              )\n            ) {\n              atomics.push({ moved: cardType, destination: forward });\n            }\n\n            if (canRetreat(cardType)) {\n              const backward = oneRowBackward(row, state.turn);\n              const backwardSnipes =\n                state.currentBoard[backward * 3 + Offset.Snipes];\n              if (\n                isRow(backward) &&\n                !(\n                  backwardSnipes & friendlySnipeFilter &&\n                  !(backwardSnipes & enemySnipeFilter) &&\n                  doesStepActivateTriplet(\n                    state.currentBoard[backward * 3 + Offset.AlphaAnimals] |\n                      state.currentBoard[backward * 3 + Offset.BetaAnimals],\n                    cardType\n                  )\n                )\n              ) {\n                atomics.push({ moved: cardType, destination: backward });\n              }\n            }\n          } else {\n            const forward = oneRowForward(row, state.turn);\n            if (\n              isRow(forward) &&\n              snipes & enemySnipeFilter &&\n              doesStepActivateTriplet(\n                state.currentBoard[forward * 3 + Offset.AlphaAnimals] |\n                  state.currentBoard[forward * 3 + Offset.BetaAnimals],\n                cardType\n              )\n            ) {\n              atomics.push({ moved: cardType, destination: forward });\n            }\n\n            if (canRetreat(cardType)) {\n              const backward = oneRowBackward(row, state.turn);\n              if (\n                isRow(backward) &&\n                snipes & enemySnipeFilter &&\n                doesStepActivateTriplet(\n                  state.currentBoard[backward * 3 + Offset.AlphaAnimals] |\n                    state.currentBoard[backward * 3 + Offset.BetaAnimals],\n                  cardType\n                )\n              ) {\n                atomics.push({ moved: cardType, destination: backward });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return atomics;\n  }\n\n  function isEitherSnipeCaptured() {\n    return isAlphaSnipeCapturedByBeta() || isBetaSnipeCapturedByAlpha();\n  }\n\n  function doesStepActivateTriplet(\n    oldAnimals: number,\n    newAnimal: AnimalType\n  ): boolean {\n    let rowElementCounts = cardProperties[newAnimal].elementCounts;\n\n    for (const cardType of allAnimalTypes) {\n      if ((1 << cardType) & oldAnimals) {\n        rowElementCounts |= cardProperties[cardType].elementCounts;\n      }\n    }\n\n    const [shift1, shift2] = cardProperties[newAnimal].tripletShifts;\n    return (\n      ((rowElementCounts >>> shift1) & 0b111) === 0b111 ||\n      ((rowElementCounts >>> shift2) & 0b111) === 0b111\n    );\n  }\n\n  function getTurn(): Player {\n    return state.turn;\n  }\n\n  function getCardLocation(cardType: CardType): CardLocation {\n    switch (cardType) {\n      case CardType.AlphaSnipe:\n      case CardType.BetaSnipe:\n        return getSnipeLocation(cardType);\n      default:\n        return getAnimalLocation(cardType);\n    }\n  }\n\n  function getSnipeLocation(cardType: SnipeType): CardLocation {\n    const snipeFilter =\n      cardType === CardType.AlphaSnipe ? 1 << Player.Alpha : 1 << Player.Beta;\n\n    for (const location of allCardLocations) {\n      const snipes = state.currentBoard[location * 3 + Offset.Snipes];\n      if ((snipes & snipeFilter) !== 0) {\n        return location;\n      }\n    }\n\n    throw new Error(\n      \"Impossible: \" + CardType[cardType] + \" cannot be found in \" + serialize()\n    );\n  }\n\n  function getAnimalLocation(cardType: AnimalType): CardLocation {\n    const animalFilter = 1 << cardType;\n\n    for (const location of allCardLocations) {\n      const animals =\n        state.currentBoard[location * 3 + Offset.AlphaAnimals] |\n        state.currentBoard[location * 3 + Offset.BetaAnimals];\n      if ((animals & animalFilter) !== 0) {\n        return location;\n      }\n    }\n\n    throw new Error(\n      \"Impossible: \" + CardType[cardType] + \" cannot be found in \" + serialize()\n    );\n  }\n\n  function tryUndoSubPly(): Result<\n    { newState: GameState; undone: SnipeStep | Drop | AnimalStep },\n    IllegalGameStateUpdate\n  > {\n    if (state.plies.length === 0 && state.pendingAnimalStep === 0) {\n      return result.err(IllegalGameStateUpdate.NothingToUndo);\n    }\n\n    if (state.pendingAnimalStep !== 0) {\n      const outOfSyncState = cloneState(state);\n      outOfSyncState.pendingAnimalStep = 0;\n\n      const undone: AnimalStep = {\n        moved: (state.pendingAnimalStep >>> 3) & Filter.LeastFiveBits,\n        destination: (state.pendingAnimalStep >>> 8) & Filter.LeastThreeBits,\n      };\n      return result.ok({\n        newState: recalculateOutOfSyncGameState(outOfSyncState),\n        undone,\n      });\n    }\n\n    const outOfSyncState = cloneState(state);\n    const encodedPly = outOfSyncState.plies.pop()!;\n    const ply = decodePly(encodedPly);\n    let undone: SnipeStep | Drop | AnimalStep;\n\n    if (ply.plyType === PlyType.TwoAnimalSteps) {\n      const encodedFirstStep =\n        (ply.first.destination << 8) | (ply.first.moved << 3) | 0b001;\n      outOfSyncState.pendingAnimalStep = encodedFirstStep;\n\n      undone = ply.second;\n    } else {\n      undone = ply;\n    }\n\n    return result.ok({\n      newState: recalculateOutOfSyncGameState(outOfSyncState),\n      undone,\n    });\n  }\n\n  function recalculateOutOfSyncGameState(\n    originalMutState: GameState\n  ): GameState {\n    let mutState = originalMutState;\n    const stateAnalyzer = getStateAnalyzer(mutState);\n\n    mutState.currentBoard = new Int32Array(mutState.initialBoard);\n\n    const plies = mutState.plies.map(decodePly);\n    const encodedPendingAnimalStep = mutState.pendingAnimalStep;\n\n    mutState.plies = [];\n    mutState.pendingAnimalStep = 0;\n    mutState.turn = Player.Beta;\n\n    plies.forEach((ply) => {\n      if (ply.plyType === PlyType.TwoAnimalSteps) {\n        stateAnalyzer.setState(mutState);\n        mutState = stateAnalyzer.forcePerform(ply.first);\n        stateAnalyzer.setState(mutState);\n        mutState = stateAnalyzer.forcePerform(ply.second);\n      } else {\n        stateAnalyzer.setState(mutState);\n        mutState = stateAnalyzer.forcePerform(ply);\n      }\n    });\n\n    if (encodedPendingAnimalStep) {\n      stateAnalyzer.setState(mutState);\n      const step: AnimalStep = {\n        moved: (encodedPendingAnimalStep >>> 3) & Filter.LeastFiveBits,\n        destination: (encodedPendingAnimalStep >>> 8) & Filter.LeastThreeBits,\n      };\n      mutState = stateAnalyzer.forcePerform(step);\n    }\n\n    return mutState;\n  }\n\n  function tryPerform(\n    atomic: Atomic\n  ): Result<GameState, IllegalGameStateUpdate> {\n    return getReasonWhyAtomicIsIllegal(atomic).match({\n      some: result.err,\n      none: () => result.ok(forcePerform(atomic)),\n    });\n  }\n\n  function getReasonWhyAtomicIsIllegal(\n    atomic: Atomic\n  ): Option<IllegalGameStateUpdate> {\n    if (isEitherSnipeCaptured()) {\n      return option.some(IllegalGameStateUpdate.SnipeAlreadyCaptured);\n    }\n\n    if (\"plyType\" in atomic) {\n      switch (atomic.plyType) {\n        case PlyType.SnipeStep: {\n          if (state.pendingAnimalStep) {\n            return option.some(IllegalGameStateUpdate.AlreadyMovedAnimal);\n          }\n\n          const moved = snipeOf(state.turn);\n          if (!isInRange(moved, state.turn, atomic.destination)) {\n            return option.some(\n              IllegalGameStateUpdate.StepDestinationOutOfRange\n            );\n          }\n\n          const location = getSnipeLocation(moved) as Row;\n          const animals =\n            state.currentBoard[location * 3 + Offset.AlphaAnimals] |\n            state.currentBoard[location * 3 + Offset.BetaAnimals];\n          const snipes = state.currentBoard[location * 3 + Offset.Snipes];\n          const enemySnipeFilter =\n            state.turn === Player.Alpha ? 1 << Player.Beta : 1 << Player.Alpha;\n          if (!(animals | (snipes & enemySnipeFilter))) {\n            return option.some(\n              IllegalGameStateUpdate.CannotEmptyRowWithoutImmediatelyWinning\n            );\n          }\n\n          return option.none();\n        }\n\n        case PlyType.Drop: {\n          if (state.pendingAnimalStep) {\n            return option.some(IllegalGameStateUpdate.AlreadyMovedAnimal);\n          }\n\n          const reserveAnimals =\n            state.currentBoard[\n              (state.turn === Player.Alpha\n                ? CardLocation.AlphaReserve\n                : CardLocation.BetaReserve) *\n                3 +\n                (state.turn === Player.Alpha\n                  ? Offset.AlphaAnimals\n                  : Offset.BetaAnimals)\n            ];\n          if (!((1 << atomic.dropped) & reserveAnimals)) {\n            return option.some(\n              IllegalGameStateUpdate.DroppedAnimalNotInReserve\n            );\n          }\n\n          if (!(reserveAnimals & ~(1 << atomic.dropped))) {\n            return option.some(IllegalGameStateUpdate.CannotEmptyReserve);\n          }\n\n          if (\n            canRetreat(atomic.dropped) &&\n            !legalRetreaterDrops[state.turn].includes(atomic.destination)\n          ) {\n            return option.some(\n              IllegalGameStateUpdate.CannotDropRetreaterOnEnemysBackTwoRows\n            );\n          }\n\n          return option.none();\n        }\n      }\n    } else {\n      const location = getAnimalLocation(atomic.moved);\n\n      if (isReserve(location)) {\n        return option.some(IllegalGameStateUpdate.MovedCardInReserve);\n      }\n\n      const friendlyAnimals =\n        state.currentBoard[\n          location * 3 +\n            (state.turn === Player.Alpha\n              ? Offset.AlphaAnimals\n              : Offset.BetaAnimals)\n        ];\n      if (!((1 << atomic.moved) & friendlyAnimals)) {\n        return option.some(IllegalGameStateUpdate.NotYourAnimal);\n      }\n\n      if (!isInRange(atomic.moved, state.turn, atomic.destination)) {\n        return option.some(IllegalGameStateUpdate.StepDestinationOutOfRange);\n      }\n\n      if (\n        state.pendingAnimalStep &&\n        ((state.pendingAnimalStep >>> 3) & Filter.LeastFiveBits) ===\n          atomic.moved\n      ) {\n        return option.some(IllegalGameStateUpdate.CannotMoveSameAnimalTwice);\n      }\n\n      const destAnimals =\n        state.currentBoard[atomic.destination * 3 + Offset.AlphaAnimals] |\n        state.currentBoard[atomic.destination * 3 + Offset.BetaAnimals];\n      const activatesTriplet = doesStepActivateTriplet(\n        destAnimals,\n        atomic.moved\n      );\n\n      const destSnipes =\n        state.currentBoard[atomic.destination * 3 + Offset.Snipes];\n      const enemySnipeFilter =\n        state.turn === Player.Alpha ? 1 << Player.Beta : 1 << Player.Alpha;\n      const enemySnipeInDest = destSnipes & enemySnipeFilter;\n\n      const sourceAnimals =\n        state.currentBoard[location * 3 + Offset.AlphaAnimals] |\n        state.currentBoard[location * 3 + Offset.BetaAnimals];\n      const sourceSnipes = state.currentBoard[location * 3 + Offset.Snipes];\n      const doesSourceRowHaveAnotherCard =\n        (sourceAnimals & ~(1 << atomic.moved)) | sourceSnipes;\n\n      const friendlySnipeFilter =\n        state.turn === Player.Alpha ? 1 << Player.Alpha : 1 << Player.Beta;\n      const friendlySnipeInDest = destSnipes & friendlySnipeFilter;\n\n      if (doesSourceRowHaveAnotherCard) {\n        if (activatesTriplet && friendlySnipeInDest && !enemySnipeInDest) {\n          return option.some(\n            IllegalGameStateUpdate.CannotCaptureOwnSnipeWithoutAlsoCapturingOpponents\n          );\n        } else {\n          return option.none();\n        }\n      } else {\n        if (activatesTriplet && enemySnipeInDest) {\n          return option.none();\n        } else {\n          return option.some(\n            IllegalGameStateUpdate.CannotEmptyRowWithoutImmediatelyWinning\n          );\n        }\n      }\n    }\n  }\n\n  function isInRange(\n    movedType: CardType,\n    movedAllegiance: Player,\n    destination: Row\n  ): boolean {\n    const location = getCardLocation(movedType);\n\n    if (isReserve(location)) {\n      return false;\n    }\n\n    return (\n      oneRowForward(location, movedAllegiance) === destination ||\n      (canRetreat(movedType) &&\n        oneRowBackward(location, movedAllegiance) === destination)\n    );\n  }\n\n  function forcePerform(atomic: Atomic): GameState {\n    if (\"plyType\" in atomic) {\n      switch (atomic.plyType) {\n        case PlyType.SnipeStep:\n          return forcePerformSnipeStep(atomic);\n        case PlyType.Drop:\n          return forcePerformDrop(atomic);\n      }\n    } else {\n      return forcePerformAnimalStep(atomic);\n    }\n  }\n\n  function forcePerformSnipeStep(step: SnipeStep): GameState {\n    const friendlySnipeLocation = getCardLocation(snipeOf(state.turn)) as Row;\n    const friendlySnipeSet = 1 << state.turn;\n    const removeFriendlySnipeFilter = ~friendlySnipeSet;\n\n    const newState = cloneState(state);\n    newState.currentBoard[\n      friendlySnipeLocation * 3 + Offset.Snipes\n    ] &= removeFriendlySnipeFilter;\n    newState.currentBoard[\n      step.destination * 3 + Offset.Snipes\n    ] |= friendlySnipeSet;\n\n    newState.plies.push((step.destination << 3) | PlyTag.SnipeStep);\n\n    newState.turn = opponentOf(newState.turn);\n\n    return newState;\n  }\n\n  function cloneState(src: GameState): GameState {\n    return {\n      stateVersion: src.stateVersion,\n      initialBoard: new Int32Array(src.initialBoard),\n      currentBoard: new Int32Array(src.currentBoard),\n      turn: src.turn,\n      plies: src.plies.slice(),\n      pendingAnimalStep: src.pendingAnimalStep,\n    };\n  }\n\n  function forcePerformDrop(drop: Drop): GameState {\n    const reserve =\n      state.turn === Player.Alpha\n        ? CardLocation.AlphaReserve\n        : CardLocation.BetaReserve;\n    const friendlyOffset =\n      state.turn === Player.Alpha ? Offset.AlphaAnimals : Offset.BetaAnimals;\n    const droppedSet = 1 << drop.dropped;\n    const removeDroppedFilter = ~droppedSet;\n\n    const newState = cloneState(state);\n    newState.currentBoard[reserve * 3 + friendlyOffset] &= removeDroppedFilter;\n    newState.currentBoard[drop.destination * 3 + friendlyOffset] |= droppedSet;\n\n    newState.plies.push(\n      (drop.destination << 8) | (drop.dropped << 3) | PlyTag.Drop\n    );\n\n    newState.turn = opponentOf(newState.turn);\n\n    return newState;\n  }\n\n  function forcePerformAnimalStep(step: AnimalStep): GameState {\n    const start = getCardLocation(step.moved) as Row;\n    const friendlyOffset =\n      state.turn === Player.Alpha ? Offset.AlphaAnimals : Offset.BetaAnimals;\n\n    const destAnimalsBeforeStep =\n      state.currentBoard[step.destination * 3 + Offset.AlphaAnimals] |\n      state.currentBoard[step.destination * 3 + Offset.BetaAnimals];\n\n    const newState = cloneState(state);\n\n    const movedSet = 1 << step.moved;\n    const removeMovedFilter = ~movedSet;\n    newState.currentBoard[start * 3 + friendlyOffset] &= removeMovedFilter;\n\n    if (doesStepActivateTriplet(destAnimalsBeforeStep, step.moved)) {\n      const friendlyReserve =\n        state.turn === Player.Alpha\n          ? CardLocation.AlphaReserve\n          : CardLocation.BetaReserve;\n      const destSnipesBeforeStep =\n        state.currentBoard[step.destination * 3 + Offset.Snipes];\n      const enemyOffset =\n        state.turn === Player.Alpha ? Offset.BetaAnimals : Offset.AlphaAnimals;\n\n      newState.currentBoard[\n        friendlyReserve * 3 + friendlyOffset\n      ] |= destAnimalsBeforeStep;\n      newState.currentBoard[\n        friendlyReserve * 3 + Offset.Snipes\n      ] |= destSnipesBeforeStep;\n\n      newState.currentBoard[step.destination * 3 + friendlyOffset] = movedSet;\n      newState.currentBoard[step.destination * 3 + enemyOffset] = 0;\n      newState.currentBoard[step.destination * 3 + Offset.Snipes] = 0;\n    } else {\n      newState.currentBoard[step.destination * 3 + friendlyOffset] |= movedSet;\n    }\n\n    if (newState.pendingAnimalStep) {\n      const encodePlyWithIncorrectTag =\n        (step.destination << 16) |\n        (step.moved << 11) |\n        newState.pendingAnimalStep;\n      newState.plies.push(\n        (encodePlyWithIncorrectTag & ~Filter.LeastThreeBits) |\n          PlyTag.TwoAnimalSteps\n      );\n      newState.pendingAnimalStep = 0;\n      newState.turn = opponentOf(newState.turn);\n    } else {\n      newState.pendingAnimalStep =\n        (step.destination << 8) | (step.moved << 3) | 0b001;\n    }\n\n    return newState;\n  }\n\n  function serialize(): string {\n    return JSON.stringify(state, (_key, value) => {\n      if (value instanceof Int32Array) {\n        return Array.from(value);\n      } else {\n        return value;\n      }\n    });\n  }\n\n  function toNodeKey(): string {\n    const { currentBoard } = state;\n    return String.fromCharCode(\n      // Animals\n      currentBoard[0] & Filter.LeastSixteenBits,\n      currentBoard[0] >>> 16,\n      currentBoard[1] & Filter.LeastSixteenBits,\n      currentBoard[1] >>> 16,\n      currentBoard[3] & Filter.LeastSixteenBits,\n      currentBoard[3] >>> 16,\n      currentBoard[4] & Filter.LeastSixteenBits,\n      currentBoard[4] >>> 16,\n      currentBoard[6] & Filter.LeastSixteenBits,\n      currentBoard[6] >>> 16,\n      currentBoard[7] & Filter.LeastSixteenBits,\n      currentBoard[7] >>> 16,\n      currentBoard[9] & Filter.LeastSixteenBits,\n      currentBoard[9] >>> 16,\n      currentBoard[10] & Filter.LeastSixteenBits,\n      currentBoard[10] >>> 16,\n      currentBoard[12] & Filter.LeastSixteenBits,\n      currentBoard[12] >>> 16,\n      currentBoard[13] & Filter.LeastSixteenBits,\n      currentBoard[13] >>> 16,\n      currentBoard[15] & Filter.LeastSixteenBits,\n      currentBoard[15] >>> 16,\n      currentBoard[16] & Filter.LeastSixteenBits,\n      currentBoard[16] >>> 16,\n      currentBoard[18] & Filter.LeastSixteenBits,\n      currentBoard[18] >>> 16,\n      currentBoard[19] & Filter.LeastSixteenBits,\n      currentBoard[19] >>> 16,\n      currentBoard[21] & Filter.LeastSixteenBits,\n      currentBoard[21] >>> 16,\n      currentBoard[22] & Filter.LeastSixteenBits,\n      currentBoard[22] >>> 16,\n\n      // Snipes\n      currentBoard[2] |\n        (currentBoard[5] << 2) |\n        (currentBoard[8] << 4) |\n        (currentBoard[11] << 6) |\n        (currentBoard[14] << 8) |\n        (currentBoard[17] << 10) |\n        (currentBoard[20] << 12) |\n        (currentBoard[23] << 14),\n\n      // Turn and animal step\n      (state.turn << 1) | (state.pendingAnimalStep & Filter.LeastBit)\n    );\n  }\n\n  function setState(newState: GameState): void {\n    state = newState;\n  }\n}\n","import { Option, option } from \"rusty-ts\";\nimport { getStateAnalyzer } from \"./stateAnalyzer\";\nimport { bitCount, Filter } from \"./bitwiseUtils\";\nimport { cardProperties } from \"./cardMaps\";\nimport { canRetreat, isRow, oneRowBackward, oneRowForward } from \"./gameUtil\";\nimport randInt from \"./randInt\";\nimport {\n  allRows,\n  AnimalStep,\n  AnimalType,\n  Atomic,\n  CardLocation,\n  Drop,\n  GameState,\n  legalRetreaterDrops,\n  Player,\n  PlyType,\n  Row,\n  SnipeStep,\n  MctsAnalysisSnapshot,\n} from \"./types\";\n\nexport const NODE_SIZE_IN_I32S = 22;\n\nconst ROOT_NODE_INDEX = 0;\nconst NO_WINNER = -1;\nconst STATE_SIZE_IN_I32S = 17;\nconst ALPHA_WINS = 0b11_1111_1110;\nconst BETA_WINS = 0b11_1111_1111;\nconst NO_MOVED_ANIMAL = 0b10_0000;\n\nconst EXPLORATION_CONSTANT = Math.sqrt(2);\n\nexport interface MctsAnalyzer {\n  performRollout(): void;\n\n  getRootPointer(): NodePointer;\n  getNodeSummary(pointer: NodePointer): NodeSummary;\n  getChildPointersFromBestToWorst(pointer: NodePointer): NodePointer[];\n\n  getSnapshot(): MctsAnalysisSnapshot;\n\n  getInternalData(): MctsAnalyzerInternalData;\n}\n\n/** This is a \"fake\" type. */\nexport interface NodePointer {\n  readonly nodePointerTag: unique symbol;\n}\n\nexport interface NodeSummary {\n  pointer: NodePointer;\n  atomic: Option<Atomic>;\n  value: number;\n  rollouts: number;\n}\n\nexport interface MctsAnalyzerInternalData {\n  heapBuffer: ArrayBuffer;\n  mallocIndex: number;\n}\n\nenum NodeOffsets {\n  SnipeSetsTurnNumberAndMovedAnimal = 16,\n  ParentIndex = 17,\n  Atomic = 18,\n  Value = 19,\n  Rollouts = 20,\n  ChildListStartIndex = 21,\n}\n\ntype QuicklyPerformableAtomic =\n  | QuicklyPerformableSnipeStep\n  | QuicklyPerformableDrop\n  | QuicklyPerformableAnimalStep;\n\nenum QuicklyPerformableAtomicType {\n  SnipeStep,\n  Drop,\n  AnimalStep,\n}\n\ninterface QuicklyPerformableSnipeStep extends SnipeStep {\n  qp_atomicType: QuicklyPerformableAtomicType.SnipeStep;\n  qp_activePlayer: Player;\n  qp_snipeLocation: Row;\n}\n\ninterface QuicklyPerformableDrop extends Drop {\n  qp_atomicType: QuicklyPerformableAtomicType.Drop;\n  qp_activePlayer: Player;\n}\n\ninterface QuicklyPerformableAnimalStep extends AnimalStep {\n  qp_atomicType: QuicklyPerformableAtomicType.AnimalStep;\n  qp_startIndex: number;\n  qp_activePlayer: Player;\n  qp_inactivePlayer: Player;\n  qp_doesStepActivateTriplet: boolean;\n}\n\nexport function getMctsAnalyzerIfStateIsNonTerminal(\n  rootState: GameState,\n  turnNumber: number,\n  heapSizeInI32s: number\n): Option<MctsAnalyzer> {\n  const stateAnalyzer = getStateAnalyzer(rootState);\n  if (stateAnalyzer.isGameOver()) {\n    return option.none();\n  } else {\n    return option.some(\n      getMctsAnalyzerForNonTerminalState(rootState, turnNumber, heapSizeInI32s)\n    );\n  }\n}\n\nfunction getMctsAnalyzerForNonTerminalState(\n  rootState: GameState,\n  turnNumber: number,\n  heapSizeInI32s: number\n): MctsAnalyzer {\n  const heap = new Int32Array(heapSizeInI32s);\n  let mallocIndex = 0;\n\n  writeRootState();\n\n  const internalData: MctsAnalyzerInternalData = {\n    heapBuffer: heap.buffer,\n    mallocIndex,\n  };\n  const uninitialized = getMctsAnalyzerFromInternalDataWithoutInitializing(\n    internalData\n  );\n\n  uninitialized.performRollout();\n  uninitialized.performRollout();\n\n  return uninitialized;\n\n  function writeRootState(): void {\n    if (mallocIndex !== 0) {\n      throw new Error(\"Cannot writeRootState() if heap is not empty.\");\n    }\n\n    const { currentBoard, pendingAnimalStep } = rootState;\n\n    heap[0] = currentBoard[0];\n    heap[1] = currentBoard[1];\n\n    heap[2] = currentBoard[3];\n    heap[3] = currentBoard[4];\n\n    heap[4] = currentBoard[6];\n    heap[5] = currentBoard[7];\n\n    heap[6] = currentBoard[9];\n    heap[7] = currentBoard[10];\n\n    heap[8] = currentBoard[12];\n    heap[9] = currentBoard[13];\n\n    heap[10] = currentBoard[15];\n    heap[11] = currentBoard[16];\n\n    heap[12] = currentBoard[18];\n    heap[13] = currentBoard[19];\n\n    heap[14] = currentBoard[21];\n    heap[15] = currentBoard[22];\n\n    heap[16] =\n      ((pendingAnimalStep === 0\n        ? NO_MOVED_ANIMAL\n        : (pendingAnimalStep >>> 3) & Filter.LeastFiveBits) <<\n        26) |\n      (turnNumber << 16) |\n      (currentBoard[23] << 14) |\n      (currentBoard[20] << 12) |\n      (currentBoard[17] << 10) |\n      (currentBoard[14] << 8) |\n      (currentBoard[11] << 6) |\n      (currentBoard[8] << 4) |\n      (currentBoard[5] << 2) |\n      currentBoard[2];\n\n    heap[NodeOffsets.ParentIndex] = -1;\n    heap[NodeOffsets.Atomic] = -1;\n    heap[NodeOffsets.Value] = 0;\n    heap[NodeOffsets.Rollouts] = 0;\n    heap[NodeOffsets.ChildListStartIndex] = -1;\n\n    mallocIndex = 22;\n  }\n}\n\nexport function getMctsAnalyzerFromInternalDataWithoutInitializing(\n  internalData: MctsAnalyzerInternalData\n): MctsAnalyzer {\n  const heap = new Int32Array(internalData.heapBuffer);\n  const tempState = new Int32Array(STATE_SIZE_IN_I32S);\n  let mallocIndex = internalData.mallocIndex;\n\n  return {\n    performRollout,\n\n    getRootPointer,\n    getNodeSummary,\n    getChildPointersFromBestToWorst,\n\n    getSnapshot,\n\n    getInternalData,\n  };\n\n  function performRollout(): void {\n    let nodeIndex = ROOT_NODE_INDEX;\n    while (!isLeaf(nodeIndex)) {\n      nodeIndex = selectBestChild(nodeIndex);\n    }\n    const leafIndex = nodeIndex;\n\n    if (getRollouts(leafIndex) === 0 && leafIndex !== ROOT_NODE_INDEX) {\n      rolloutIfNonTerminalThenBackPropagate(leafIndex);\n    } else {\n      const winner = getImmediateWinner(heap, leafIndex);\n      if (~winner) {\n        updateAndBackPropagateRollout(leafIndex, winner);\n        markAsEffectivelyTerminal(leafIndex, winner);\n      } else {\n        addChildrenAndRolloutFirstChild(leafIndex);\n      }\n    }\n  }\n\n  function isLeaf(nodeIndex: number): boolean {\n    const childListStartIndex =\n      heap[nodeIndex + NodeOffsets.ChildListStartIndex];\n    // If childListStartIndex is null (negative), then\n    // heap[childListStartIndex] will be undefined,\n    // and (undefined | 0) === 0.\n    return (heap[childListStartIndex] | 0) === 0;\n  }\n\n  function selectBestChild(nodeIndex: number): number {\n    const childListStartIndex =\n      heap[nodeIndex + NodeOffsets.ChildListStartIndex];\n    const childCount = heap[childListStartIndex];\n    const nodeRollouts = getRollouts(nodeIndex);\n    const turnNumberAndMovedAnimal =\n      heap[nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>> 16;\n    const activePlayer = turnNumberAndMovedAnimal & 0b1;\n    const inactivePlayer = ~turnNumberAndMovedAnimal & 0b1;\n\n    let bestIndex = getNthElementOfChildList(childListStartIndex, 0);\n    let bestScore = getUcbScore(bestIndex, nodeRollouts);\n\n    if (getEffectiveWinner(bestIndex) === activePlayer) {\n      return bestIndex;\n    }\n\n    if (getEffectiveWinner(bestIndex) === inactivePlayer) {\n      bestScore = -Infinity;\n    }\n\n    for (let i = 1; i < childCount; i++) {\n      const childIndex = getNthElementOfChildList(childListStartIndex, i);\n      const winner = getEffectiveWinner(childIndex);\n\n      if (winner === activePlayer) {\n        return childIndex;\n      }\n\n      if (winner === inactivePlayer) {\n        continue;\n      }\n\n      const childScore = getUcbScore(childIndex, nodeRollouts);\n\n      if (childScore > bestScore) {\n        bestIndex = childIndex;\n        bestScore = childScore;\n      }\n    }\n    return bestIndex;\n  }\n\n  function getRollouts(nodeIndex: number): number {\n    return heap[nodeIndex + NodeOffsets.Rollouts];\n  }\n\n  function getNthElementOfChildList(\n    childListStartIndex: number,\n    n: number\n  ): number {\n    return heap[childListStartIndex + 1 + n];\n  }\n\n  function rolloutIfNonTerminalThenBackPropagate(nodeIndex: number): void {\n    const winner = getImmediateWinner(heap, nodeIndex);\n\n    if (~winner) {\n      markAsEffectivelyTerminal(nodeIndex, winner);\n    }\n\n    const rolledOutWinner = ~winner ? winner : rollout(nodeIndex);\n    updateAndBackPropagateRollout(nodeIndex, rolledOutWinner);\n  }\n\n  function rollout(nodeIndex: number): Player {\n    copyNodeStateIntoTempState(nodeIndex);\n    let legalAtomics = getLegalAtomics(tempState);\n    while (legalAtomics.length > 0) {\n      const selected = legalAtomics[randInt(0, legalAtomics.length)];\n      performAtomic(selected, tempState);\n      legalAtomics = getLegalAtomics(tempState);\n    }\n\n    return getImmediateWinner(tempState, 0);\n  }\n\n  function copyNodeStateIntoTempState(nodeIndex: number): void {\n    tempState.set(heap.subarray(nodeIndex, nodeIndex + STATE_SIZE_IN_I32S));\n  }\n\n  function getLegalAtomics(out: Int32Array): QuicklyPerformableAtomic[] {\n    const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n\n    if ((etc & 0b10) | ((etc >>> 14) & 0b1)) {\n      return [];\n    }\n\n    const atomics: QuicklyPerformableAtomic[] = [];\n\n    const activePlayer: Player = (etc >>> 16) & 0b1;\n    const inactivePlayer: Player = activePlayer ^ 0b1;\n    const activePlayerLegalRetreaterDrops = legalRetreaterDrops[activePlayer];\n\n    // Only add full plies if there is no pending subply\n    if (getOptMovedAnimal(out) === NO_MOVED_ANIMAL) {\n      // Snipe steps\n      {\n        if (snipeCannotBeFound(etc, activePlayer)) {\n          console.log(\"etc\", etc);\n          debugger;\n        }\n\n        const activeSnipeLocation = getActiveSnipeLocation(etc, activePlayer);\n        if (isRow(activeSnipeLocation)) {\n          const enemySnipeSet =\n            (etc >>> (activeSnipeLocation << 1)) & (1 << inactivePlayer);\n          const animalSet =\n            out[(activeSnipeLocation << 1) | activePlayer] |\n            out[(activeSnipeLocation << 1) | inactivePlayer];\n          if (enemySnipeSet | animalSet) {\n            const forward = oneRowForward(activeSnipeLocation, activePlayer);\n            if (isRow(forward)) {\n              atomics.push({\n                plyType: PlyType.SnipeStep,\n                destination: forward,\n\n                qp_atomicType: QuicklyPerformableAtomicType.SnipeStep,\n                qp_activePlayer: activePlayer,\n                qp_snipeLocation: activeSnipeLocation,\n              });\n            }\n\n            const backward = oneRowBackward(activeSnipeLocation, activePlayer);\n            if (isRow(backward)) {\n              atomics.push({\n                plyType: PlyType.SnipeStep,\n                destination: backward,\n\n                qp_atomicType: QuicklyPerformableAtomicType.SnipeStep,\n                qp_activePlayer: activePlayer,\n                qp_snipeLocation: activeSnipeLocation,\n              });\n            }\n          }\n        }\n      }\n\n      // Drops\n      {\n        const reserveAnimalSet = getReserveAnimalSet(activePlayer, out);\n\n        if (bitCount(reserveAnimalSet) > 1) {\n          for (let animalType = 0; animalType <= 31; animalType++) {\n            if ((1 << animalType) & reserveAnimalSet) {\n              const destinations = canRetreat(animalType)\n                ? activePlayerLegalRetreaterDrops\n                : allRows;\n              const destinationsLen = destinations.length;\n              for (let i = 0; i < destinationsLen; i++) {\n                atomics.push({\n                  plyType: PlyType.Drop,\n                  dropped: animalType,\n                  destination: destinations[i],\n\n                  qp_atomicType: QuicklyPerformableAtomicType.Drop,\n                  qp_activePlayer: activePlayer,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Animal steps can be performed regardless of the previous action\n    for (let row: Row = 1; row <= 6; row++) {\n      const startIndex = (row << 1) | activePlayer;\n      const friendlyAnimalSet = out[startIndex];\n\n      if (friendlyAnimalSet === 0) {\n        continue;\n      }\n\n      const animalSet = friendlyAnimalSet | out[(row << 1) + inactivePlayer];\n      const snipes = (etc >>> (row << 1)) & Filter.LeastTwoBits;\n      const doesRowHaveAtLeastTwoCards = snipes || bitCount(animalSet) > 1;\n      const previouslyMovedAnimal = etc >>> 26;\n\n      const forward = oneRowForward(row, activePlayer);\n      const isForwardRow = forward !== 0 && forward !== 7;\n      const isForwardNotRow: 0 | 2 = (((!isForwardRow as unknown) as 0 | 1) <<\n        1) as 0 | 2;\n      const forwardSnipesAndExtraneousGreaterBits = etc >>> (forward << 1);\n      const isFriendlySnipeInForwardRow =\n        (forwardSnipesAndExtraneousGreaterBits & (1 << activePlayer)) >>>\n        isForwardNotRow;\n      const isEnemySnipeInForwardRow =\n        (forwardSnipesAndExtraneousGreaterBits & (1 << inactivePlayer)) >>>\n        isForwardNotRow;\n\n      const backward = oneRowBackward(row, activePlayer);\n      const isBackwardRow = backward !== 0 && backward !== 7;\n      const isBackwardNotRow: 0 | 2 = (((!isBackwardRow as unknown) as 0 | 1) <<\n        1) as 0 | 2;\n      const backwardSnipesAndExtraneousGreaterBits = etc >>> (backward << 1);\n      const isFriendlySnipeInBackwardRow =\n        (backwardSnipesAndExtraneousGreaterBits & (1 << activePlayer)) >>>\n        isBackwardNotRow;\n      const isEnemySnipeInBackwardRow =\n        (backwardSnipesAndExtraneousGreaterBits & (1 << inactivePlayer)) >>>\n        isBackwardNotRow;\n\n      for (let animalType = 0; animalType <= 31; animalType++) {\n        if (previouslyMovedAnimal === animalType) {\n          continue;\n        }\n\n        if ((1 << animalType) & friendlyAnimalSet) {\n          const doesForwardStepActivateTriplet = doesStepActivateTriplet(\n            forward,\n            animalType,\n            out\n          );\n          const canThisAnimalRetreat = canRetreat(animalType);\n          const canThisAnimalActivateTripletByRetreating =\n            canThisAnimalRetreat &&\n            doesStepActivateTriplet(backward, animalType, out);\n\n          if (doesRowHaveAtLeastTwoCards) {\n            if (\n              isForwardRow &&\n              !(\n                isFriendlySnipeInForwardRow &&\n                !isEnemySnipeInForwardRow &&\n                doesForwardStepActivateTriplet\n              )\n            ) {\n              atomics.push({\n                moved: animalType,\n                destination: forward as Row,\n\n                qp_atomicType: QuicklyPerformableAtomicType.AnimalStep,\n                qp_startIndex: startIndex,\n                qp_activePlayer: activePlayer,\n                qp_inactivePlayer: inactivePlayer,\n                qp_doesStepActivateTriplet: doesForwardStepActivateTriplet,\n              });\n            }\n\n            if (canThisAnimalRetreat) {\n              if (\n                isBackwardRow &&\n                !(\n                  isFriendlySnipeInBackwardRow &&\n                  !isEnemySnipeInBackwardRow &&\n                  canThisAnimalActivateTripletByRetreating\n                )\n              ) {\n                atomics.push({\n                  moved: animalType,\n                  destination: backward as Row,\n\n                  qp_atomicType: QuicklyPerformableAtomicType.AnimalStep,\n                  qp_startIndex: startIndex,\n                  qp_activePlayer: activePlayer,\n                  qp_inactivePlayer: inactivePlayer,\n                  qp_doesStepActivateTriplet: canThisAnimalActivateTripletByRetreating,\n                });\n              }\n            }\n          } else {\n            if (\n              isForwardRow &&\n              isEnemySnipeInForwardRow &&\n              doesForwardStepActivateTriplet\n            ) {\n              atomics.push({\n                moved: animalType,\n                destination: forward as Row,\n\n                qp_atomicType: QuicklyPerformableAtomicType.AnimalStep,\n                qp_startIndex: startIndex,\n                qp_activePlayer: activePlayer,\n                qp_inactivePlayer: inactivePlayer,\n                qp_doesStepActivateTriplet: doesForwardStepActivateTriplet,\n              });\n            }\n\n            if (\n              canThisAnimalActivateTripletByRetreating &&\n              isBackwardRow &&\n              isEnemySnipeInBackwardRow\n            ) {\n              atomics.push({\n                moved: animalType,\n                destination: backward as Row,\n\n                qp_atomicType: QuicklyPerformableAtomicType.AnimalStep,\n                qp_startIndex: startIndex,\n                qp_activePlayer: activePlayer,\n                qp_inactivePlayer: inactivePlayer,\n                qp_doesStepActivateTriplet: canThisAnimalActivateTripletByRetreating,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return atomics;\n  }\n\n  function getOptMovedAnimal(out: Int32Array): number {\n    return out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>> 26;\n  }\n\n  function getActiveSnipeLocation(\n    etc: number,\n    activePlayer: Player\n  ): CardLocation {\n    const activeSnipe = 1 << activePlayer;\n    for (let i = 0; i <= 14; i += 2) {\n      if ((etc >>> i) & activeSnipe) {\n        return i >>> 1;\n      }\n    }\n\n    throw new Error(\n      \"Impossible: \" + Player[activePlayer] + \" snipe cannot be found.\"\n    );\n  }\n\n  function snipeCannotBeFound(etc: number, activePlayer: Player): boolean {\n    const activeSnipe = 1 << activePlayer;\n    for (let i = 0; i <= 14; i += 2) {\n      if ((etc >>> i) & activeSnipe) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getReserveAnimalSet(player: Player, out: Int32Array): number {\n    return out[getReserveIndex(player)];\n  }\n\n  function getReserveIndex(player: Player): 0 | 15 {\n    if (player === Player.Alpha) {\n      return 0;\n    } else {\n      return 15;\n    }\n  }\n\n  function doesStepActivateTriplet(\n    destination: CardLocation,\n    newAnimal: AnimalType,\n    out: Int32Array\n  ): boolean {\n    const oldAnimals = out[destination << 1] | out[(destination << 1) + 1];\n\n    let rowElementCounts = cardProperties[newAnimal].elementCounts;\n\n    for (let animalType: AnimalType = 0; animalType <= 31; animalType++) {\n      if ((1 << animalType) & oldAnimals) {\n        rowElementCounts |= cardProperties[animalType].elementCounts;\n      }\n    }\n\n    const [shift1, shift2] = cardProperties[newAnimal].tripletShifts;\n    return (\n      ((rowElementCounts >>> shift1) & 0b111) === 0b111 ||\n      ((rowElementCounts >>> shift2) & 0b111) === 0b111\n    );\n  }\n\n  function performAtomic(\n    atomic: QuicklyPerformableAtomic,\n    out: Int32Array\n  ): void {\n    if (atomic.qp_atomicType === QuicklyPerformableAtomicType.SnipeStep) {\n      return performSnipeStep(atomic, out);\n    } else if (atomic.qp_atomicType === QuicklyPerformableAtomicType.Drop) {\n      return performDrop(atomic, out);\n    } else {\n      return performAnimalStep(atomic, out);\n    }\n  }\n\n  function performSnipeStep(\n    atomic: QuicklyPerformableSnipeStep,\n    out: Int32Array\n  ): void {\n    const debug_before = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n\n    const snipe = 1 << atomic.qp_activePlayer;\n    out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] &= ~(\n      snipe <<\n      (atomic.qp_snipeLocation << 1)\n    );\n    out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] |=\n      snipe << (atomic.destination << 1);\n\n    const debug_after = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n\n    if (\n      snipeCannotBeFound(debug_after, 0) ||\n      snipeCannotBeFound(debug_after, 1)\n    ) {\n      console.log(\n        \"before\",\n        debug_before,\n        \"after\",\n        debug_after,\n        \"was already broken\",\n        snipeCannotBeFound(debug_before, 0) ||\n          snipeCannotBeFound(debug_before, 1),\n        \"atomic\",\n        atomic\n      );\n    }\n\n    const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n    const turnNumber = (etc >>> 16) & Filter.LeastTenBits;\n    out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] =\n      (etc & 0b1111_1100_0000_0000_1111_1111_1111_1111) |\n      ((turnNumber + 1) << 16);\n  }\n\n  function performDrop(atomic: QuicklyPerformableDrop, out: Int32Array): void {\n    const reserveIndex = getReserveIndex(atomic.qp_activePlayer);\n    const droppedSet = 1 << atomic.dropped;\n\n    out[reserveIndex] &= ~droppedSet;\n    out[(atomic.destination << 1) + atomic.qp_activePlayer] |= droppedSet;\n\n    const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n    const turnNumber = (etc >>> 16) & Filter.LeastTenBits;\n    out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] =\n      (etc & 0b1111_1100_0000_0000_1111_1111_1111_1111) |\n      ((turnNumber + 1) << 16);\n  }\n\n  function performAnimalStep(\n    atomic: QuicklyPerformableAnimalStep,\n    out: Int32Array\n  ): void {\n    const startIndex = atomic.qp_startIndex;\n    const movedSet = 1 << atomic.moved;\n\n    out[startIndex] &= ~movedSet;\n\n    const destAlphaIndex = atomic.destination << 1;\n\n    if (atomic.qp_doesStepActivateTriplet) {\n      out[getReserveIndex(atomic.qp_activePlayer)] |=\n        out[destAlphaIndex] | out[destAlphaIndex | 0b1];\n      out[destAlphaIndex | atomic.qp_activePlayer] = movedSet;\n      out[destAlphaIndex | atomic.qp_inactivePlayer] = 0;\n\n      const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n      const capturedSnipesSet = (etc >>> destAlphaIndex) & Filter.LeastTwoBits;\n      out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] =\n        (etc & ~(0b11 << destAlphaIndex)) |\n        (capturedSnipesSet << (atomic.qp_activePlayer ? 14 : 0));\n    } else {\n      out[destAlphaIndex | atomic.qp_activePlayer] |= movedSet;\n    }\n\n    const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n    if (etc >>> 31) {\n      // If moved animal does not exist, set moved animal to atomic.moved.\n      out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] =\n        (etc & 0b0000_0011_1111_1111_1111_1111_1111_1111) |\n        (atomic.moved << 26);\n    } else {\n      // If moved animal exists, set moved animal to null and increment the turn number.\n      out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] =\n        (((etc & 0b0000_0011_1111_1111_1111_1111_1111_1111) |\n          0b1000_0000_0000_0000_0000_0000_0000_0000) &\n          0b1111_1100_0000_0000_1111_1111_1111_1111) |\n        ((((etc >>> 16) & Filter.LeastTenBits) + 1) << 16);\n    }\n  }\n\n  function getImmediateWinner(\n    state: Int32Array,\n    offset: number\n  ): Player | typeof NO_WINNER {\n    const etc = state[offset + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n    if (etc & 0b10) {\n      return Player.Alpha;\n    } else if ((etc >>> 14) & 0b01) {\n      return Player.Beta;\n    } else if (\n      !hasAtLeastOneLegalAtomic(\n        state.subarray(offset, offset + STATE_SIZE_IN_I32S)\n      )\n    ) {\n      return ~(etc >>> 16) & 0b1;\n    } else {\n      return NO_WINNER;\n    }\n  }\n\n  function getEffectiveWinner(nodeIndex: number): Player | typeof NO_WINNER {\n    const turnNumber =\n      (heap[nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>> 16) &\n      Filter.LeastTenBits;\n\n    if (turnNumber === ALPHA_WINS) {\n      return Player.Alpha;\n    } else if (turnNumber === BETA_WINS) {\n      return Player.Beta;\n    } else {\n      return NO_WINNER;\n    }\n  }\n\n  function hasAtLeastOneLegalAtomic(out: Int32Array): boolean {\n    const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n\n    if ((etc & 0b10) | ((etc >>> 14) & 0b1)) {\n      return false;\n    }\n\n    const activePlayer: Player = (etc >>> 16) & 0b1;\n    const inactivePlayer: Player = activePlayer ^ 0b1;\n    const activePlayerLegalRetreaterDrops = legalRetreaterDrops[activePlayer];\n\n    // Only add full plies if there is no pending subply\n    if (getOptMovedAnimal(out) === NO_MOVED_ANIMAL) {\n      // Snipe steps\n      {\n        if (snipeCannotBeFound(etc, activePlayer)) {\n          console.log(\"etc\", etc);\n          debugger;\n        }\n\n        const activeSnipeLocation = getActiveSnipeLocation(etc, activePlayer);\n        if (isRow(activeSnipeLocation)) {\n          const enemySnipeSet =\n            (etc >>> (activeSnipeLocation << 1)) & (1 << inactivePlayer);\n          const animalSet =\n            out[(activeSnipeLocation << 1) | activePlayer] |\n            out[(activeSnipeLocation << 1) | inactivePlayer];\n          if (enemySnipeSet | animalSet) {\n            const forward = oneRowForward(activeSnipeLocation, activePlayer);\n            if (isRow(forward)) {\n              return true;\n            }\n\n            const backward = oneRowBackward(activeSnipeLocation, activePlayer);\n            if (isRow(backward)) {\n              return true;\n            }\n          }\n        }\n      }\n\n      // Drops\n      {\n        const reserveAnimalSet = getReserveAnimalSet(activePlayer, out);\n\n        if (bitCount(reserveAnimalSet) > 1) {\n          for (let animalType = 0; animalType <= 31; animalType++) {\n            if ((1 << animalType) & reserveAnimalSet) {\n              const destinations = canRetreat(animalType)\n                ? activePlayerLegalRetreaterDrops\n                : allRows;\n              const destinationsLen = destinations.length;\n              for (let i = 0; i < destinationsLen; i++) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Animal steps can be performed regardless of the previous action\n    for (let row: Row = 1; row <= 6; row++) {\n      const startIndex = (row << 1) | activePlayer;\n      const friendlyAnimalSet = out[startIndex];\n\n      if (friendlyAnimalSet === 0) {\n        continue;\n      }\n\n      const animalSet = friendlyAnimalSet | out[(row << 1) + inactivePlayer];\n      const snipes = (etc >>> (row << 1)) & Filter.LeastTwoBits;\n      const doesRowHaveAtLeastTwoCards = snipes || bitCount(animalSet) > 1;\n      const previouslyMovedAnimal = etc >>> 26;\n\n      const forward = oneRowForward(row, activePlayer);\n      const isForwardRow = forward !== 0 && forward !== 7;\n      const isForwardNotRow: 0 | 2 = (((!isForwardRow as unknown) as 0 | 1) <<\n        1) as 0 | 2;\n      const forwardSnipesAndExtraneousGreaterBits = etc >>> (forward << 1);\n      const isFriendlySnipeInForwardRow =\n        (forwardSnipesAndExtraneousGreaterBits & (1 << activePlayer)) >>>\n        isForwardNotRow;\n      const isEnemySnipeInForwardRow =\n        (forwardSnipesAndExtraneousGreaterBits & (1 << inactivePlayer)) >>>\n        isForwardNotRow;\n\n      const backward = oneRowBackward(row, activePlayer);\n      const isBackwardRow = backward !== 0 && backward !== 7;\n      const isBackwardNotRow: 0 | 2 = (((!isBackwardRow as unknown) as 0 | 1) <<\n        1) as 0 | 2;\n      const backwardSnipesAndExtraneousGreaterBits = etc >>> (backward << 1);\n      const isFriendlySnipeInBackwardRow =\n        (backwardSnipesAndExtraneousGreaterBits & (1 << activePlayer)) >>>\n        isBackwardNotRow;\n      const isEnemySnipeInBackwardRow =\n        (backwardSnipesAndExtraneousGreaterBits & (1 << inactivePlayer)) >>>\n        isBackwardNotRow;\n\n      for (let animalType = 0; animalType <= 31; animalType++) {\n        if (previouslyMovedAnimal === animalType) {\n          continue;\n        }\n\n        if ((1 << animalType) & friendlyAnimalSet) {\n          const doesForwardStepActivateTriplet = doesStepActivateTriplet(\n            forward,\n            animalType,\n            out\n          );\n          const canThisAnimalRetreat = canRetreat(animalType);\n          const canThisAnimalActivateTripletByRetreating =\n            canThisAnimalRetreat &&\n            doesStepActivateTriplet(backward, animalType, out);\n\n          if (doesRowHaveAtLeastTwoCards) {\n            if (\n              isForwardRow &&\n              !(\n                isFriendlySnipeInForwardRow &&\n                !isEnemySnipeInForwardRow &&\n                doesForwardStepActivateTriplet\n              )\n            ) {\n              return true;\n            }\n\n            if (canThisAnimalRetreat) {\n              if (\n                isBackwardRow &&\n                !(\n                  isFriendlySnipeInBackwardRow &&\n                  !isEnemySnipeInBackwardRow &&\n                  canThisAnimalActivateTripletByRetreating\n                )\n              ) {\n                return true;\n              }\n            }\n          } else {\n            if (\n              isForwardRow &&\n              isEnemySnipeInForwardRow &&\n              doesForwardStepActivateTriplet\n            ) {\n              return true;\n            }\n\n            if (\n              canThisAnimalActivateTripletByRetreating &&\n              isBackwardRow &&\n              isEnemySnipeInBackwardRow\n            ) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function addChildrenAndRolloutFirstChild(nodeIndex: number): void {\n    const childIndexes: number[] = [];\n\n    const atomics = getLegalAtomics(\n      heap.subarray(nodeIndex, nodeIndex + STATE_SIZE_IN_I32S)\n    );\n    const atomicsLen = atomics.length;\n    for (let i = 0; i < atomicsLen; i++) {\n      const atomic = atomics[i];\n\n      const childIndex = malloc(NODE_SIZE_IN_I32S);\n      childIndexes.push(childIndex);\n      createChildOf(nodeIndex, atomic, childIndex);\n    }\n\n    const childIndexesLen = childIndexes.length;\n    const childListStartIndex = malloc(1 + childIndexesLen);\n\n    heap[nodeIndex + NodeOffsets.ChildListStartIndex] = childListStartIndex;\n\n    heap[childListStartIndex] = childIndexesLen;\n\n    for (let i = 0; i < childIndexesLen; i++) {\n      heap[childListStartIndex + 1 + i] = childIndexes[i];\n    }\n\n    if (childIndexesLen) {\n      rolloutIfNonTerminalThenBackPropagate(childIndexes[0]);\n    }\n  }\n\n  function malloc(space: number): number {\n    if (mallocIndex > heap.length - space) {\n      throw new Error(\"Monte Carlo Tree heap has ran out of space.\");\n    }\n\n    const address = mallocIndex;\n    mallocIndex += space;\n    return address;\n  }\n\n  function createChildOf(\n    nodeIndex: number,\n    atomic: QuicklyPerformableAtomic,\n    destIndex: number\n  ): void {\n    heap.set(heap.subarray(nodeIndex, nodeIndex + 17), destIndex);\n\n    heap[destIndex + NodeOffsets.ParentIndex] = nodeIndex;\n    heap[destIndex + NodeOffsets.Atomic] = encodeAtomic(atomic);\n    heap[destIndex + NodeOffsets.Value] = 0;\n    heap[destIndex + NodeOffsets.Rollouts] = 0;\n    heap[destIndex + NodeOffsets.ChildListStartIndex] = -1;\n\n    performAtomic(\n      atomic,\n      heap.subarray(destIndex, destIndex + STATE_SIZE_IN_I32S)\n    );\n  }\n\n  function encodeAtomic(atomic: QuicklyPerformableAtomic): number {\n    if (atomic.qp_atomicType === QuicklyPerformableAtomicType.SnipeStep) {\n      return (atomic.destination << 3) | 0b001;\n    } else if (atomic.qp_atomicType === QuicklyPerformableAtomicType.Drop) {\n      return (atomic.destination << 8) | (atomic.dropped << 3) | 0b010;\n    } else {\n      return (atomic.destination << 8) | (atomic.moved << 3) | 0b011;\n    }\n  }\n\n  function decodeAtomic(encoded: number): Atomic {\n    const tag = encoded & Filter.LeastThreeBits;\n    if (tag === 0b001) {\n      return {\n        plyType: PlyType.SnipeStep,\n        destination: encoded >>> 3,\n      };\n    } else if (tag === 0b010) {\n      return {\n        plyType: PlyType.Drop,\n        dropped: (encoded >>> 3) & Filter.LeastFiveBits,\n        destination: encoded >>> 8,\n      };\n    } else {\n      return {\n        moved: (encoded >>> 3) & Filter.LeastFiveBits,\n        destination: encoded >>> 8,\n      };\n    }\n  }\n\n  function getUcbScore(nodeIndex: number, parentRollouts: number): number {\n    const nodeRollouts = getRollouts(nodeIndex);\n    if (nodeRollouts === 0) {\n      return Infinity;\n    }\n\n    const meanValue = getValue(nodeIndex) / nodeRollouts;\n    return (\n      meanValue +\n      EXPLORATION_CONSTANT * Math.sqrt(Math.log(parentRollouts) / nodeRollouts)\n    );\n  }\n\n  function getValue(nodeIndex: number): number {\n    return heap[nodeIndex + NodeOffsets.Value];\n  }\n\n  function updateAndBackPropagateRollout(\n    leafIndex: number,\n    winner: Player\n  ): void {\n    let nodeIndex = leafIndex;\n    let parentIndex = heap[nodeIndex + NodeOffsets.ParentIndex];\n\n    while (~parentIndex) {\n      heap[nodeIndex + NodeOffsets.Value] += ((winner ===\n        getActivePlayerOfNonTerminalState(parentIndex)) as unknown) as 1 | 0;\n      heap[nodeIndex + NodeOffsets.Rollouts] += 1;\n\n      nodeIndex = parentIndex;\n      parentIndex = heap[nodeIndex + NodeOffsets.ParentIndex];\n    }\n\n    heap[nodeIndex + NodeOffsets.Value] += ((winner ===\n      getActivePlayerOfNonTerminalState(nodeIndex)) as unknown) as 1 | 0;\n    heap[nodeIndex + NodeOffsets.Rollouts] += 1;\n  }\n\n  function getActivePlayerOfNonTerminalState(nodeIndex: number): Player {\n    return (\n      (heap[nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>> 16) &\n      0b1\n    );\n  }\n\n  function markAsEffectivelyTerminal(leafIndex: number, winner: Player): void {\n    const winnerBits = (0b11_1111_1110 | winner) << 16;\n\n    let nodeIndex = leafIndex;\n    let parentIndex = getParentIndex(nodeIndex);\n\n    while (\n      ~parentIndex &&\n      ((heap[parentIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>>\n        16) &\n        0b1) ===\n        winner\n    ) {\n      const etcIndex =\n        nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal;\n      const etc = heap[etcIndex];\n      heap[etcIndex] =\n        (etc & 0b1111_1100_0000_0000_1111_1111_1111_1111) | winnerBits;\n\n      nodeIndex = parentIndex;\n      parentIndex = getParentIndex(nodeIndex);\n    }\n\n    const etcIndex = nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal;\n    const etc = heap[etcIndex];\n    heap[etcIndex] =\n      (etc & 0b1111_1100_0000_0000_1111_1111_1111_1111) | winnerBits;\n  }\n\n  function getParentIndex(nodeIndex: number): number {\n    return heap[nodeIndex + NodeOffsets.ParentIndex];\n  }\n\n  function getRootPointer(): NodePointer {\n    return indexToPointer(ROOT_NODE_INDEX);\n  }\n\n  function getNodeSummary(pointer: NodePointer): NodeSummary {\n    const nodeIndex = pointerToIndex(pointer);\n    return {\n      pointer,\n      atomic:\n        heap[nodeIndex + NodeOffsets.ParentIndex] === -1\n          ? option.none()\n          : option.some(decodeAtomic(heap[nodeIndex + NodeOffsets.Atomic])),\n      value: heap[nodeIndex + NodeOffsets.Value],\n      rollouts: heap[nodeIndex + NodeOffsets.Rollouts],\n    };\n  }\n\n  function getChildPointersFromBestToWorst(\n    pointer: NodePointer\n  ): NodePointer[] {\n    const nodeIndex = pointerToIndex(pointer);\n\n    const turn =\n      (heap[nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>> 16) &\n      Filter.LeastTenBits;\n    const optActivePlayer: Player | -1 =\n      turn === ALPHA_WINS || turn === BETA_WINS ? -1 : turn & 0b1;\n\n    const childListStartIndex =\n      heap[nodeIndex + NodeOffsets.ChildListStartIndex];\n    const childListLen = heap[childListStartIndex];\n    const indexesAndScores: { index: number; score: number }[] = [];\n\n    for (let i = 0; i < childListLen; i++) {\n      const childIndex = heap[childListStartIndex + 1 + i];\n\n      const optWinner = getEffectiveWinner(childIndex);\n      let score: number;\n\n      if (optWinner !== -1 && optActivePlayer !== -1) {\n        score = optWinner === optActivePlayer ? Infinity : -Infinity;\n      } else if (optWinner !== -1) {\n        const childTurn =\n          (heap[childIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>>\n            16) &\n          Filter.LeastTenBits;\n        score = childTurn === turn ? Infinity : -Infinity;\n      } else {\n        const childRollouts = heap[childIndex + NodeOffsets.Rollouts];\n        score = childRollouts;\n      }\n\n      indexesAndScores.push({ index: childIndex, score });\n    }\n\n    return indexesAndScores\n      .sort((a, b) => b.score - a.score)\n      .map((scoreIndex) => indexToPointer(scoreIndex.index));\n  }\n\n  function getSnapshot(): MctsAnalysisSnapshot {\n    const root = getNodeSummary(getRootPointer());\n    const childWithBestAtomic = getSummaryOfChildWithBestAtomic();\n\n    return {\n      currentStateValue: root.value,\n      currentStateRollouts: root.rollouts,\n\n      bestAtomic: childWithBestAtomic.atomic.expect(\n        \"Impossible: Child node does not have atomic.\"\n      ),\n      bestAtomicValue: childWithBestAtomic.value,\n      bestAtomicRollouts: childWithBestAtomic.rollouts,\n    };\n  }\n\n  function getSummaryOfChildWithBestAtomic(): NodeSummary {\n    const bestChildIndex = getIndexOfChildWithBestAtomic();\n\n    return {\n      pointer: indexToPointer(bestChildIndex),\n      atomic: option.some(\n        decodeAtomic(heap[bestChildIndex + NodeOffsets.Atomic])\n      ),\n      value: heap[bestChildIndex + NodeOffsets.Value],\n      rollouts: heap[bestChildIndex + NodeOffsets.Rollouts],\n    };\n  }\n\n  function getIndexOfChildWithBestAtomic(): number {\n    const rootActivePlayer =\n      (heap[ROOT_NODE_INDEX + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>>\n        16) &\n      0b1;\n    const rootInactivePlayer = ~rootActivePlayer & 0b1;\n\n    const rootChildListStartIndex =\n      heap[ROOT_NODE_INDEX + NodeOffsets.ChildListStartIndex];\n    const rootChildListLen = heap[rootChildListStartIndex];\n\n    let bestChildIndex = -1;\n    for (let i = 0; i < rootChildListLen; i++) {\n      const childIndex = heap[rootChildListStartIndex + 1 + i];\n\n      if (bestChildIndex === -1) {\n        bestChildIndex = childIndex;\n        continue;\n      }\n\n      const winner = getEffectiveWinner(childIndex);\n\n      if (winner === rootActivePlayer) {\n        return childIndex;\n      }\n\n      if (winner === rootInactivePlayer) {\n        continue;\n      }\n\n      if (\n        heap[childIndex + NodeOffsets.Rollouts] >\n          heap[bestChildIndex + NodeOffsets.Rollouts] ||\n        getEffectiveWinner(bestChildIndex) === rootInactivePlayer\n      ) {\n        bestChildIndex = childIndex;\n      }\n    }\n\n    if (bestChildIndex === -1) {\n      throw new Error(\"Impossible: Root node has no children.\");\n    }\n\n    return bestChildIndex;\n  }\n\n  function getInternalData(): MctsAnalyzerInternalData {\n    return { heapBuffer: heap.buffer, mallocIndex };\n  }\n}\n\nexport function pointerToIndex(pointer: NodePointer): number {\n  return (pointer as unknown) as number;\n}\n\nexport function indexToPointer(nodeIndex: number): NodePointer {\n  return (nodeIndex as unknown) as NodePointer;\n}\n","import { option, Option } from \"rusty-ts\";\nimport {\n  getMctsAnalyzerIfStateIsNonTerminal,\n  MctsAnalyzer,\n  NODE_SIZE_IN_I32S,\n  getMctsAnalyzerFromInternalDataWithoutInitializing,\n} from \"../mcts\";\nimport {\n  MctsWorkerRequest,\n  UpdateSnapshotNotification,\n  UpdateGameStateRequest,\n  MctsWorkerMessageType,\n  PauseAnalyzerRequest,\n  PauseAnalyzerResponse,\n  ResumeAnalyzerRequest,\n  StopTimeChangeNotification,\n} from \"../types\";\n\nexport {};\n\nconst ROLLOUT_BATCH_SIZE = 5000;\nconst UNCERTAINTY_THRESHOLD = 1e-3;\nconst MAX_MEAN_VALUE_BEFORE_DECLARING_VICTORY = 1 - UNCERTAINTY_THRESHOLD;\nconst MIN_MEAN_VALUE_BEFORE_DECLARING_DEFEAT = UNCERTAINTY_THRESHOLD;\nconst MIN_ROLLOUTS_NEEDED_TO_DECLARE_STATE_TERMINAL = 1e6;\nconst MIN_MILLISECONDS_BETWEEN_POSTS = 0.2e3;\n\ndeclare const self: Worker;\n\nlet optMctsAnalyzer: Option<MctsAnalyzer> = option.none();\nlet lastPosted = 0;\nlet optStopTime: Option<number> = option.none();\n\nself.addEventListener(\"message\", (e) => {\n  const data = e.data;\n  if (\"object\" === typeof data && data !== null) {\n    const message: MctsWorkerRequest = data;\n    switch (message.messageType) {\n      case MctsWorkerMessageType.UpdateGameStateRequest:\n        onGameStateUpdateRequest(message);\n        break;\n      case MctsWorkerMessageType.PauseAnalyzerRequest:\n        onPauseAnalyzerRequest(message);\n        break;\n      case MctsWorkerMessageType.ResumeAnalyzerRequest:\n        onResumeAnalyzerRequest(message);\n        break;\n      default: {\n        // Force exhaustive matching\n\n        // eslint-disable-next-line\n        const unreachable: never = message;\n      }\n    }\n  }\n});\n\nfunction onGameStateUpdateRequest(message: UpdateGameStateRequest): void {\n  const newGameState = message.gameState;\n\n  optMctsAnalyzer = getMctsAnalyzerIfStateIsNonTerminal(\n    newGameState,\n    newGameState.plies.length + 3,\n    NODE_SIZE_IN_I32S * 2e7\n  );\n\n  updateOptStopTime(message.thinkingTimeInMS);\n}\n\nfunction updateOptStopTime(thinkingTimeInMS: number): void {\n  if (Number.isFinite(thinkingTimeInMS)) {\n    optStopTime = option.some(Date.now() + thinkingTimeInMS);\n  } else {\n    optStopTime = option.none();\n  }\n\n  const stopTimeNotification: StopTimeChangeNotification = {\n    messageType: MctsWorkerMessageType.StopTimeChangeNotification,\n    optStopTime: optStopTime.unwrapOr(null),\n  };\n  self.postMessage(stopTimeNotification);\n}\n\nfunction onPauseAnalyzerRequest(_message: PauseAnalyzerRequest): void {\n  optMctsAnalyzer.ifSome((mctsAnalyzer) => {\n    const internalData = mctsAnalyzer.getInternalData();\n    optMctsAnalyzer = option.none();\n\n    const message: PauseAnalyzerResponse = {\n      messageType: MctsWorkerMessageType.PauseAnalyzerResponse,\n      internalData,\n    };\n    self.postMessage(message, [internalData.heapBuffer]);\n  });\n}\n\nfunction onResumeAnalyzerRequest(message: ResumeAnalyzerRequest): void {\n  optMctsAnalyzer = option.some(\n    getMctsAnalyzerFromInternalDataWithoutInitializing(message.internalData)\n  );\n}\n\nfunction analysisUpdateLoop() {\n  optMctsAnalyzer.match({\n    none: () => {\n      const message: UpdateSnapshotNotification = {\n        messageType: MctsWorkerMessageType.UpdateSnapshotNotification,\n        optSnapshot: null,\n      };\n      self.postMessage(message);\n    },\n\n    some: (analyzer) => {\n      const root = analyzer.getNodeSummary(analyzer.getRootPointer());\n      const meanValue = root.value / root.rollouts;\n      const isTerminal =\n        root.rollouts >= MIN_ROLLOUTS_NEEDED_TO_DECLARE_STATE_TERMINAL &&\n        (meanValue > MAX_MEAN_VALUE_BEFORE_DECLARING_VICTORY ||\n          meanValue < MIN_MEAN_VALUE_BEFORE_DECLARING_DEFEAT);\n      const isOutOfThinkingTime = optStopTime.someSatisfies(\n        (stopTime) => Date.now() > stopTime\n      );\n\n      if (!isTerminal && !isOutOfThinkingTime) {\n        for (let i = 0; i < ROLLOUT_BATCH_SIZE; i++) {\n          analyzer.performRollout();\n        }\n      }\n\n      const now = Date.now();\n      const shouldPost = now > lastPosted + MIN_MILLISECONDS_BETWEEN_POSTS;\n      if (shouldPost) {\n        postAnalysisUpdate(analyzer);\n        lastPosted = now;\n      }\n    },\n  });\n\n  requestAnimationFrame(analysisUpdateLoop);\n}\n\nfunction postAnalysisUpdate(analyzer: MctsAnalyzer): void {\n  const message: UpdateSnapshotNotification = {\n    messageType: MctsWorkerMessageType.UpdateSnapshotNotification,\n    optSnapshot: analyzer.getSnapshot(),\n  };\n  self.postMessage(message);\n}\n\nanalysisUpdateLoop();\n"],"sourceRoot":""}