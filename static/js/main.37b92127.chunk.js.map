{"version":3,"sources":["workers/mcts.ts","types.ts","cardMaps.ts","bitwiseUtils.ts","gameStateFactory.ts","randInt.ts","gameUtil.ts","stateAnalyzer.ts","mcts.ts","components/InlineAtomic.tsx","components/NodeStats.tsx","components/AnalysisNode.tsx","components/AnimalStepView.tsx","components/CardView.tsx","components/ElementMatrix.tsx","components/FutureAnimalStepView.tsx","components/PlyView.tsx","stateSavers.ts","workers/mcts.importable.js","mctsService.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Worker","SuggestionDetailLevel","CardLocation","CardType","allCardLocations","AlphaReserve","Row1","Row2","Row3","Row4","Row5","Row6","BetaReserve","allRows","Player","allAnimalTypes","Mouse1","Ox1","Tiger1","Rabbit1","Dragon1","Snake1","Horse1","Ram1","Monkey1","Rooster1","Dog1","Boar1","Fish1","Elephant1","Squid1","Frog1","Mouse2","Ox2","Tiger2","Rabbit2","Dragon2","Snake2","Horse2","Ram2","Monkey2","Rooster2","Dog2","Boar2","Fish2","Elephant2","Squid2","Frog2","PlyType","IllegalGameStateUpdate","Element","ElementCount","TripletShift","MctsWorkerMessageType","legalRetreaterDrops","Alpha","Beta","Offset","Filter","PlyTag","cardProperties","elements","option","some","double","Fire","single","Earth","elementCounts","F2","E1","tripletShifts","canRetreat","Water","E2","W1","F3","None","Air","A2","A3","W2","A1","F1","W3","E3","AlphaSnipe","none","BetaSnipe","cardEmojis","bitCount","n","gameStateFactory","fromString","s","parsed","JSON","parse","key","value","Int32Array","stateVersion","fromBoard","board","initialBoard","location","cards","card","cardType","cardSet","offset","Snipes","allegiance","AlphaAnimals","BetaAnimals","currentBoard","turn","plies","pendingAnimalStep","randInt","inclMin","exclMax","diff","Math","floor","random","getRandomGameState","minors","majors","shuffle","alpha","slice","concat","map","beta","getShuffledDecks","pop","arr","len","length","k","i","j","temp","isReserve","opponentOf","player","snipeOf","oneRowForward","row","oneRowBackward","isRow","decodePly","ply","LeastThreeBits","SnipeStep","destination","plyType","Drop","LeastFiveBits","dropped","TwoAnimalSteps","firstCardType","firstDestination","secondCardType","secondDestination","first","moved","second","isAnimalStep","atomic","getStateAnalyzer","initState","state","getInitialState","getBoard","alphaAnimals","betaAnimals","forEach","animalType","push","snipes","getPlies","getPendingAnimalStep","isGameOver","getWinner","isSome","getTurn","getCardLocation","tryUndoSubPly","result","err","NothingToUndo","outOfSyncState","cloneState","undone","ok","newState","recalculateOutOfSyncGameState","encodedFirstStep","tryPerform","isEitherSnipeCaptured","SnipeAlreadyCaptured","getAnimalLocation","MovedCardInReserve","friendlyAnimals","NotYourAnimal","isInRange","StepDestinationOutOfRange","CannotMoveSameAnimalTwice","activatesTriplet","doesStepActivateTriplet","destSnipes","enemySnipeFilter","enemySnipeInDest","sourceAnimals","sourceSnipes","doesSourceRowHaveAnotherCard","friendlySnipeFilter","friendlySnipeInDest","CannotCaptureOwnSnipeWithoutAlsoCapturingOpponents","CannotEmptyRowWithoutImmediatelyWinning","AlreadyMovedAnimal","getSnipeLocation","animals","reserveAnimals","includes","CannotDropRetreaterOnEnemysBackTwoRows","CannotEmptyReserve","DroppedAnimalNotInReserve","getReasonWhyAtomicIsIllegal","match","forcePerform","serialize","toNodeKey","String","fromCharCode","LeastSixteenBits","LeastBit","setState","getLegalAtomics","isAlphaSnipeCapturedByBeta","isBetaSnipeCapturedByAlpha","atomics","snipeLocation","forward","backward","reserve","desinations","doesRowHaveAtLeastTwoCards","forwardSnipes","backwardSnipes","oldAnimals","newAnimal","rowElementCounts","shift1","shift2","snipeFilter","Error","animalFilter","originalMutState","mutState","stateAnalyzer","encodedPendingAnimalStep","step","movedType","movedAllegiance","start","friendlyOffset","destAnimalsBeforeStep","movedSet","removeMovedFilter","friendlyReserve","destSnipesBeforeStep","enemyOffset","encodePlyWithIncorrectTag","forcePerformAnimalStep","friendlySnipeLocation","friendlySnipeSet","removeFriendlySnipeFilter","forcePerformSnipeStep","drop","droppedSet","removeDroppedFilter","forcePerformDrop","src","stringify","_key","Array","from","NodeOffsets","QuicklyPerformableAtomicType","NODE_SIZE_IN_I32S","EXPLORATION_CONSTANT","sqrt","getMctsAnalyzerIfStateIsNonTerminal","rootState","turnNumber","heapSizeInI32s","heap","mallocIndex","ParentIndex","Atomic","Value","Rollouts","ChildListStartIndex","writeRootState","uninitialized","getMctsAnalyzerFromInternalDataWithoutInitializing","heapBuffer","buffer","performRollout","getMctsAnalyzerForNonTerminalState","internalData","tempState","nodeIndex","isLeaf","selectBestChild","leafIndex","getRollouts","rolloutIfNonTerminalThenBackPropagate","winner","getImmediateWinner","updateAndBackPropagateRollout","markAsEffectivelyTerminal","childIndexes","subarray","atomicsLen","childIndex","malloc","createChildOf","childIndexesLen","childListStartIndex","addChildrenAndRolloutFirstChild","getRootPointer","getNodeSummary","getChildPointersFromBestToWorst","pointer","SnipeSetsTurnNumberAndMovedAnimal","LeastTenBits","optActivePlayer","childListLen","indexesAndScores","optWinner","getEffectiveWinner","score","Infinity","childTurn","childRollouts","index","sort","a","b","scoreIndex","getSnapshot","root","childWithBestAtomic","bestChildIndex","rootActivePlayer","rootInactivePlayer","rootChildListStartIndex","rootChildListLen","getIndexOfChildWithBestAtomic","decodeAtomic","rollouts","getSummaryOfChildWithBestAtomic","currentStateValue","currentStateRollouts","bestAtomic","expect","bestAtomicValue","bestAtomicRollouts","getInternalData","childCount","nodeRollouts","turnNumberAndMovedAnimal","activePlayer","inactivePlayer","bestIndex","getNthElementOfChildList","bestScore","getUcbScore","childScore","set","copyNodeStateIntoTempState","legalAtomics","performAtomic","rollout","out","etc","activePlayerLegalRetreaterDrops","getOptMovedAnimal","snipeCannotBeFound","console","log","activeSnipeLocation","getActiveSnipeLocation","qp_atomicType","qp_activePlayer","qp_snipeLocation","reserveAnimalSet","getReserveAnimalSet","destinations","destinationsLen","startIndex","friendlyAnimalSet","animalSet","LeastTwoBits","previouslyMovedAnimal","isForwardRow","isForwardNotRow","forwardSnipesAndExtraneousGreaterBits","isFriendlySnipeInForwardRow","isEnemySnipeInForwardRow","isBackwardRow","isBackwardNotRow","backwardSnipesAndExtraneousGreaterBits","isFriendlySnipeInBackwardRow","isEnemySnipeInBackwardRow","doesForwardStepActivateTriplet","canThisAnimalRetreat","canThisAnimalActivateTripletByRetreating","AnimalStep","qp_startIndex","qp_inactivePlayer","qp_doesStepActivateTriplet","activeSnipe","getReserveIndex","debug_before","snipe","debug_after","performSnipeStep","reserveIndex","performDrop","destAlphaIndex","capturedSnipesSet","performAnimalStep","enemySnipeSet","hasAtLeastOneLegalAtomic","space","address","destIndex","encodeAtomic","encoded","tag","parentRollouts","getValue","parentIndex","getActivePlayerOfNonTerminalState","winnerBits","getParentIndex","etcIndex","pointerToIndex","indexToPointer","Ellipsis","InlineAtomic","plyNumber","ellipsis","plyMakerEmoji","getEmoji","Before","className","After","NodeStats","meanValue","toFixed","AnalysisNode","analyzer","suggestionDetailLevels","isTherePendingAnimalStep","viewedNode","onDetailLevelChange","optDetailLevel","detailLevel","undefined","pointersToConsideredChildren","pointers","BestAction","AllActions","SuggestionDetailLevelMenu","onChange","childPointer","childSummary","someSatisfies","plyNumberAfterPerformingChildAtomic","isTherePendingAnimalStepAfterPerformingChildAtomic","event","level","target","AnimalStepView","gameUtil","CardView","isSelected","onCardClicked","onClick","ElementMatrix","selectedCard","ElementMatrixCell","amount","element","cardsWithElements","filter","countElement","getCardsWithElements","renderCard","unwrapOr","FutureAnimalStepView","PlyView","LocalStorageKeys","MctsWorker","getMctsService","worker","snapshotListeners","pauseListeners","stopTimeChangeListeners","addEventListener","onWorkerMessage","updateGameState","optThinkingTime","thinkingTime","message","messageType","UpdateGameStateRequest","gameState","thinkingTimeInMS","postMessage","pause","PauseAnalyzerRequest","resume","ResumeAnalyzerRequest","onSnapshot","listener","onPause","onStopTimeChange","data","LogNotification","onWorkerLogNotification","UpdateSnapshotNotification","optSnapshot","fromVoidable","onUpdateSnapshotNotification","PauseAnalyzerResponse","mctsAnalyzer","onTransferAnalyzerResponse","StopTimeChangeNotification","optStopTime","onStopTimeChangeNotification","gameStateSaver","stateStr","localStorage","getItem","GameState","setItem","futureSubPlyStackSaver","FutureSubPlyStack","jsonified","thinkingTimeSaver","ThinkingTimeInMilliseconds","optThinkingTimeInMS","App","props","mctsService","unwrapOrElse","newGameState","futureSubPlyStack","newStack","ux","selectedCardType","analysisSuggestionDetailLevels","mctsState","isRunning","mostRecentSnapshot","thinkingTimeInputValue","timeInMS","stopTime","loadState","bindMethods","window","app","this","onMctsServiceSnapshot","onMctsServicePause","onMctsServiceOnStopTimeChange","bind","onResetGameClicked","onUndoSubPlyClicked","onRedoSubPlyClicked","isBestAtomicLegal","onPauseAnalyzerClicked","onResumeAnalyzerClicked","onTimeLimitEnabledChange","onThinkingTimeInputChange","renderMatrixView","Date","now","diffInSeconds","ceil","max","renderSnipesIn","e","HTMLTableCellElement","classList","contains","onRowNumberClicked","zeroBasedPlyNumber","renderFutureSubPlies","type","checked","isWellFormedDecimalInteger","analysis","afterPerformingBest","currentStateMeanValue","bestAtomicMeanValue","renderExpandableAnalysis","equalsSome","renderCards","isBeta","isAlpha","chronological","reverse","preTurnsAnimalStep","turns","postTurnsAnimalStep","next","nextNext","rootSummary","clicked","selectedType","updateUxState","newUxState","prevState","ifSome","selected","tryDrop","trySnipeStep","tryAnimalStep","dropResult","updateGameStateOrAlertError","res","saveAndUpdateGameState","errorCode","alert","stepResult","getFutureSubPlyStackAfterUndoing","stack","nextAtomic","redoResult","ifOk","confirm","legal","isOk","expandedNodeIndexes","resetAnalysisSuggestionDetailLevels","rootPointer","bestChildPointer","isNone","saveAndUpdateThinkingTime","parsedInMilliseconds","parseInt","React","Component","test","Boolean","hostname","mcts","WorkerMessageType","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.37b92127.chunk.js","sourcesContent":["module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"288d488608b0ccd2c35d.worker.js\");\n};","import { Option, Result } from \"rusty-ts\";\nimport { MctsAnalyzerInternalData, MctsAnalyzer } from \"./mcts\";\n\n/**\n * Increment this when making breaking changes\n * to state interfaces to ensure seralized state\n * compatibility detection will continue to work.\n */\nexport const STATE_VERSION = 14;\n\nexport interface AppState {\n  gameState: GameState;\n  ux: {\n    selectedCardType: Option<CardType>;\n    futureSubPlyStack: FutureSubPlyStack;\n    analysisSuggestionDetailLevels: {\n      [pointer: number]: SuggestionDetailLevel;\n    };\n  };\n  mctsState: MctsState;\n  thinkingTimeInMS: Option<number>;\n  thinkingTimeInputValue: string;\n  stopTime: Option<number>;\n}\n\nexport interface GameState {\n  stateVersion: typeof STATE_VERSION;\n  initialBoard: Int32Array;\n  currentBoard: Int32Array;\n  turn: Player;\n  plies: number[];\n  pendingAnimalStep: number;\n}\n\nexport interface FutureSubPlyStack {\n  stateVersion: typeof STATE_VERSION;\n  atomics: Atomic[];\n}\n\nexport type MctsState = MctsRunningState | MctsPausedState;\n\nexport interface MctsRunningState {\n  isRunning: true;\n  mostRecentSnapshot: Option<MctsAnalysisSnapshot>;\n}\n\nexport interface MctsPausedState {\n  isRunning: false;\n  analyzer: MctsAnalyzer;\n  expandedNodeIndexes: number[];\n}\n\nexport interface MctsAnalysisSnapshot {\n  currentStateValue: number;\n  currentStateRollouts: number;\n\n  bestAtomic: Atomic;\n  bestAtomicValue: number;\n  bestAtomicRollouts: number;\n}\n\nexport enum SuggestionDetailLevel {\n  None = \"None\",\n  BestAction = \"BestAction\",\n  AllActions = \"AllActions\",\n}\n\nexport interface MctsService {\n  updateGameState(state: GameState, optThinkingTimeInMS: Option<number>): void;\n  pause(): void;\n  resume(analyzer: MctsAnalyzer): void;\n\n  onSnapshot(listener: (analysis: Option<MctsAnalysisSnapshot>) => void): void;\n  onPause(listener: (analyzer: MctsAnalyzer) => void): void;\n  onStopTimeChange(listener: (stopTime: Option<number>) => void): void;\n}\n\nexport interface GameStateAnalyzer {\n  getInitialState(): GameState;\n  getBoard(): Board;\n  getPlies(): Ply[];\n  getPendingAnimalStep(): Option<AnimalStep>;\n  isGameOver(): boolean;\n  getWinner(): Option<Player>;\n  getTurn(): Player;\n  getCardLocation(cardType: CardType): CardLocation;\n  tryUndoSubPly(): Result<\n    { newState: GameState; undone: SnipeStep | Drop | AnimalStep },\n    IllegalGameStateUpdate\n  >;\n  tryPerform(atomic: Atomic): Result<GameState, IllegalGameStateUpdate>;\n  serialize(): string;\n  toNodeKey(): string;\n  setState(state: GameState): void;\n  getLegalAtomics(): Atomic[];\n  forcePerform(atomic: Atomic): GameState;\n}\n\nexport enum CardLocation {\n  AlphaReserve = 0,\n  Row1 = 1,\n  Row2 = 2,\n  Row3 = 3,\n  Row4 = 4,\n  Row5 = 5,\n  Row6 = 6,\n  BetaReserve = 7,\n}\n\nexport const allCardLocations: CardLocation[] = [\n  CardLocation.AlphaReserve,\n  CardLocation.Row1,\n  CardLocation.Row2,\n  CardLocation.Row3,\n  CardLocation.Row4,\n  CardLocation.Row5,\n  CardLocation.Row6,\n  CardLocation.BetaReserve,\n];\n\nexport const allRows: Row[] = [\n  CardLocation.Row1,\n  CardLocation.Row2,\n  CardLocation.Row3,\n  CardLocation.Row4,\n  CardLocation.Row5,\n  CardLocation.Row6,\n];\n\nexport interface Board {\n  [CardLocation.AlphaReserve]: Card[];\n  [CardLocation.Row1]: Card[];\n  [CardLocation.Row2]: Card[];\n  [CardLocation.Row3]: Card[];\n  [CardLocation.Row4]: Card[];\n  [CardLocation.Row5]: Card[];\n  [CardLocation.Row6]: Card[];\n  [CardLocation.BetaReserve]: Card[];\n}\n\nexport interface Card {\n  cardType: CardType;\n  allegiance: Player;\n}\n\nexport enum CardType {\n  Mouse1 = 0,\n  Ox1 = 1,\n  Tiger1 = 2,\n  Rabbit1 = 3,\n  Dragon1 = 4,\n  Snake1 = 5,\n  Horse1 = 6,\n  Ram1 = 7,\n  Monkey1 = 8,\n  Rooster1 = 9,\n  Dog1 = 10,\n  Boar1 = 11,\n\n  Fish1 = 12,\n  Elephant1 = 13,\n  Squid1 = 14,\n  Frog1 = 15,\n\n  Mouse2 = 16,\n  Ox2 = 17,\n  Tiger2 = 18,\n  Rabbit2 = 19,\n  Dragon2 = 20,\n  Snake2 = 21,\n  Horse2 = 22,\n  Ram2 = 23,\n  Monkey2 = 24,\n  Rooster2 = 25,\n  Dog2 = 26,\n  Boar2 = 27,\n\n  Fish2 = 28,\n  Elephant2 = 29,\n  Squid2 = 30,\n  Frog2 = 31,\n\n  AlphaSnipe = 32,\n  BetaSnipe = 33,\n}\n\nexport const allAnimalTypes: AnimalType[] = [\n  CardType.Mouse1,\n  CardType.Ox1,\n  CardType.Tiger1,\n  CardType.Rabbit1,\n  CardType.Dragon1,\n  CardType.Snake1,\n  CardType.Horse1,\n  CardType.Ram1,\n  CardType.Monkey1,\n  CardType.Rooster1,\n  CardType.Dog1,\n  CardType.Boar1,\n\n  CardType.Fish1,\n  CardType.Elephant1,\n  CardType.Squid1,\n  CardType.Frog1,\n\n  CardType.Mouse2,\n  CardType.Ox2,\n  CardType.Tiger2,\n  CardType.Rabbit2,\n  CardType.Dragon2,\n  CardType.Snake2,\n  CardType.Horse2,\n  CardType.Ram2,\n  CardType.Monkey2,\n  CardType.Rooster2,\n  CardType.Dog2,\n  CardType.Boar2,\n\n  CardType.Fish2,\n  CardType.Elephant2,\n  CardType.Squid2,\n  CardType.Frog2,\n];\n\nexport type AnimalType = Exclude<CardType, SnipeType>;\n\nexport type SnipeType = CardType.AlphaSnipe | CardType.BetaSnipe;\n\nexport enum Player {\n  Alpha = 0,\n  Beta = 1,\n}\n\nexport interface LegalRetreaterDrops {\n  [Player.Alpha]: Row[];\n  [Player.Beta]: Row[];\n}\n\nexport const legalRetreaterDrops: LegalRetreaterDrops = {\n  [Player.Alpha]: [\n    CardLocation.Row1,\n    CardLocation.Row2,\n    CardLocation.Row3,\n    CardLocation.Row4,\n  ],\n  [Player.Beta]: [\n    CardLocation.Row3,\n    CardLocation.Row4,\n    CardLocation.Row5,\n    CardLocation.Row6,\n  ],\n};\n\nexport type Ply = SnipeStep | Drop | TwoAnimalSteps;\n\nexport enum PlyType {\n  SnipeStep,\n  Drop,\n  TwoAnimalSteps,\n}\n\nexport interface SnipeStep {\n  plyType: PlyType.SnipeStep;\n  destination: Row;\n}\n\nexport interface Drop {\n  plyType: PlyType.Drop;\n  dropped: AnimalType;\n  destination: Row;\n}\n\nexport interface TwoAnimalSteps {\n  plyType: PlyType.TwoAnimalSteps;\n  first: AnimalStep;\n  second: AnimalStep;\n}\n\nexport interface AnimalStep {\n  moved: AnimalType;\n  destination: Row;\n}\n\nexport type Atomic = SnipeStep | Drop | AnimalStep;\n\nexport type Row =\n  | CardLocation.Row1\n  | CardLocation.Row2\n  | CardLocation.Row3\n  | CardLocation.Row4\n  | CardLocation.Row5\n  | CardLocation.Row6;\n\nexport enum IllegalGameStateUpdate {\n  SnipeAlreadyCaptured,\n  AlreadyMovedAnimal,\n  StepDestinationOutOfRange,\n  CannotEmptyRowWithoutImmediatelyWinning,\n  DroppedAnimalNotInReserve,\n  CannotEmptyReserve,\n  CannotDropRetreaterOnEnemysBackTwoRows,\n  MovedCardInReserve,\n  NotYourAnimal,\n  CannotMoveSameAnimalTwice,\n  CannotCaptureOwnSnipeWithoutAlsoCapturingOpponents,\n\n  NothingToUndo,\n}\n\nexport interface StateSaver<T> {\n  getState(): Option<T>;\n  setState(state: T): void;\n}\n\nexport interface CardMap<T> {\n  [CardType.Mouse1]: T;\n  [CardType.Ox1]: T;\n  [CardType.Tiger1]: T;\n  [CardType.Rabbit1]: T;\n  [CardType.Dragon1]: T;\n  [CardType.Snake1]: T;\n  [CardType.Horse1]: T;\n  [CardType.Ram1]: T;\n  [CardType.Monkey1]: T;\n  [CardType.Rooster1]: T;\n  [CardType.Dog1]: T;\n  [CardType.Boar1]: T;\n\n  [CardType.Fish1]: T;\n  [CardType.Elephant1]: T;\n  [CardType.Squid1]: T;\n  [CardType.Frog1]: T;\n\n  [CardType.Mouse2]: T;\n  [CardType.Ox2]: T;\n  [CardType.Tiger2]: T;\n  [CardType.Rabbit2]: T;\n  [CardType.Dragon2]: T;\n  [CardType.Snake2]: T;\n  [CardType.Horse2]: T;\n  [CardType.Ram2]: T;\n  [CardType.Monkey2]: T;\n  [CardType.Rooster2]: T;\n  [CardType.Dog2]: T;\n  [CardType.Boar2]: T;\n\n  [CardType.Fish2]: T;\n  [CardType.Elephant2]: T;\n  [CardType.Squid2]: T;\n  [CardType.Frog2]: T;\n\n  [CardType.AlphaSnipe]: T;\n  [CardType.BetaSnipe]: T;\n}\n\nexport interface CardProperties {\n  elements: Option<{ double: Element; single: Element }>;\n  elementCounts: number;\n  tripletShifts: [TripletShift, TripletShift];\n  canRetreat: boolean;\n}\n\nexport enum Element {\n  Fire,\n  Water,\n  Earth,\n  Air,\n}\n\nexport enum ElementCount {\n  F1 = 1 << 0,\n  F2 = 1 << 1,\n  F3 = 1 << 2,\n\n  W1 = 1 << 3,\n  W2 = 1 << 4,\n  W3 = 1 << 5,\n\n  E1 = 1 << 6,\n  E2 = 1 << 7,\n  E3 = 1 << 8,\n\n  A1 = 1 << 9,\n  A2 = 1 << 10,\n  A3 = 1 << 11,\n}\n\nexport enum TripletShift {\n  Fire = 0,\n  Water = 3,\n  Earth = 6,\n  Air = 9,\n  None = 12,\n}\n\nexport type MctsWorkerRequest =\n  | UpdateGameStateRequest\n  | PauseAnalyzerRequest\n  | ResumeAnalyzerRequest;\n\nexport type MctsWorkerNotification =\n  | LogNotification\n  | UpdateSnapshotNotification\n  | PauseAnalyzerResponse\n  | StopTimeChangeNotification;\n\nexport enum MctsWorkerMessageType {\n  UpdateGameStateRequest,\n  PauseAnalyzerRequest,\n  ResumeAnalyzerRequest,\n\n  LogNotification,\n  UpdateSnapshotNotification,\n  PauseAnalyzerResponse,\n  StopTimeChangeNotification,\n}\n\nexport interface UpdateGameStateRequest {\n  messageType: MctsWorkerMessageType.UpdateGameStateRequest;\n  gameState: GameState;\n  thinkingTimeInMS: number;\n}\n\nexport interface PauseAnalyzerRequest {\n  messageType: MctsWorkerMessageType.PauseAnalyzerRequest;\n}\n\nexport interface ResumeAnalyzerRequest {\n  messageType: MctsWorkerMessageType.ResumeAnalyzerRequest;\n  internalData: MctsAnalyzerInternalData;\n}\n\nexport interface LogNotification {\n  messageType: MctsWorkerMessageType.LogNotification;\n  data: unknown;\n}\n\nexport interface UpdateSnapshotNotification {\n  messageType: MctsWorkerMessageType.UpdateSnapshotNotification;\n  optSnapshot: MctsAnalysisSnapshot | null;\n}\n\nexport interface PauseAnalyzerResponse {\n  messageType: MctsWorkerMessageType.PauseAnalyzerResponse;\n  internalData: MctsAnalyzerInternalData;\n}\n\nexport interface StopTimeChangeNotification {\n  messageType: MctsWorkerMessageType.StopTimeChangeNotification;\n  optStopTime: number | null;\n}\n","import { option } from \"rusty-ts\";\nimport {\n  CardType,\n  Element,\n  CardMap,\n  CardProperties,\n  ElementCount,\n  TripletShift,\n} from \"./types\";\n\nexport const cardProperties: CardMap<CardProperties> = {\n  [CardType.Mouse1]: {\n    elements: option.some({ double: Element.Fire, single: Element.Earth }),\n    elementCounts: ElementCount.F2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Earth],\n    canRetreat: true,\n  },\n  [CardType.Ox1]: {\n    elements: option.some({ double: Element.Earth, single: Element.Water }),\n    elementCounts: ElementCount.E2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Water],\n    canRetreat: false,\n  },\n  [CardType.Tiger1]: {\n    elements: option.some({ double: Element.Fire, single: Element.Fire }),\n    elementCounts: ElementCount.F3,\n    tripletShifts: [TripletShift.Fire, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Rabbit1]: {\n    elements: option.some({ double: Element.Air, single: Element.Water }),\n    elementCounts: ElementCount.A2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Air, TripletShift.Water],\n    canRetreat: true,\n  },\n  [CardType.Dragon1]: {\n    elements: option.some({ double: Element.Air, single: Element.Air }),\n    elementCounts: ElementCount.A3,\n    tripletShifts: [TripletShift.Air, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Snake1]: {\n    elements: option.some({ double: Element.Water, single: Element.Earth }),\n    elementCounts: ElementCount.W2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Water, TripletShift.Earth],\n    canRetreat: true,\n  },\n  [CardType.Horse1]: {\n    elements: option.some({ double: Element.Fire, single: Element.Air }),\n    elementCounts: ElementCount.F2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Air],\n    canRetreat: false,\n  },\n  [CardType.Ram1]: {\n    elements: option.some({ double: Element.Earth, single: Element.Air }),\n    elementCounts: ElementCount.E2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Air],\n    canRetreat: true,\n  },\n  [CardType.Monkey1]: {\n    elements: option.some({ double: Element.Air, single: Element.Earth }),\n    elementCounts: ElementCount.A2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Air, TripletShift.Earth],\n    canRetreat: false,\n  },\n  [CardType.Rooster1]: {\n    elements: option.some({ double: Element.Air, single: Element.Fire }),\n    elementCounts: ElementCount.A2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Air, TripletShift.Fire],\n    canRetreat: false,\n  },\n  [CardType.Dog1]: {\n    elements: option.some({ double: Element.Fire, single: Element.Water }),\n    elementCounts: ElementCount.F2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Water],\n    canRetreat: false,\n  },\n  [CardType.Boar1]: {\n    elements: option.some({ double: Element.Earth, single: Element.Fire }),\n    elementCounts: ElementCount.E2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Fire],\n    canRetreat: true,\n  },\n\n  [CardType.Fish1]: {\n    elements: option.some({ double: Element.Water, single: Element.Water }),\n    elementCounts: ElementCount.W3,\n    tripletShifts: [TripletShift.Water, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Elephant1]: {\n    elements: option.some({ double: Element.Earth, single: Element.Earth }),\n    elementCounts: ElementCount.E3,\n    tripletShifts: [TripletShift.Earth, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Squid1]: {\n    elements: option.some({ double: Element.Water, single: Element.Fire }),\n    elementCounts: ElementCount.W2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Water, TripletShift.Fire],\n    canRetreat: true,\n  },\n  [CardType.Frog1]: {\n    elements: option.some({ double: Element.Water, single: Element.Air }),\n    elementCounts: ElementCount.W2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Water, TripletShift.Air],\n    canRetreat: false,\n  },\n\n  [CardType.Mouse2]: {\n    elements: option.some({ double: Element.Fire, single: Element.Earth }),\n    elementCounts: ElementCount.F2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Earth],\n    canRetreat: true,\n  },\n  [CardType.Ox2]: {\n    elements: option.some({ double: Element.Earth, single: Element.Water }),\n    elementCounts: ElementCount.E2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Water],\n    canRetreat: false,\n  },\n  [CardType.Tiger2]: {\n    elements: option.some({ double: Element.Fire, single: Element.Fire }),\n    elementCounts: ElementCount.F3,\n    tripletShifts: [TripletShift.Fire, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Rabbit2]: {\n    elements: option.some({ double: Element.Air, single: Element.Water }),\n    elementCounts: ElementCount.A2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Air, TripletShift.Water],\n    canRetreat: true,\n  },\n  [CardType.Dragon2]: {\n    elements: option.some({ double: Element.Air, single: Element.Air }),\n    elementCounts: ElementCount.A3,\n    tripletShifts: [TripletShift.Air, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Snake2]: {\n    elements: option.some({ double: Element.Water, single: Element.Earth }),\n    elementCounts: ElementCount.W2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Water, TripletShift.Earth],\n    canRetreat: true,\n  },\n  [CardType.Horse2]: {\n    elements: option.some({ double: Element.Fire, single: Element.Air }),\n    elementCounts: ElementCount.F2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Air],\n    canRetreat: false,\n  },\n  [CardType.Ram2]: {\n    elements: option.some({ double: Element.Earth, single: Element.Air }),\n    elementCounts: ElementCount.E2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Air],\n    canRetreat: true,\n  },\n  [CardType.Monkey2]: {\n    elements: option.some({ double: Element.Air, single: Element.Earth }),\n    elementCounts: ElementCount.A2 | ElementCount.E1,\n    tripletShifts: [TripletShift.Air, TripletShift.Earth],\n    canRetreat: false,\n  },\n  [CardType.Rooster2]: {\n    elements: option.some({ double: Element.Air, single: Element.Fire }),\n    elementCounts: ElementCount.A2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Air, TripletShift.Fire],\n    canRetreat: false,\n  },\n  [CardType.Dog2]: {\n    elements: option.some({ double: Element.Fire, single: Element.Water }),\n    elementCounts: ElementCount.F2 | ElementCount.W1,\n    tripletShifts: [TripletShift.Fire, TripletShift.Water],\n    canRetreat: false,\n  },\n  [CardType.Boar2]: {\n    elements: option.some({ double: Element.Earth, single: Element.Fire }),\n    elementCounts: ElementCount.E2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Earth, TripletShift.Fire],\n    canRetreat: true,\n  },\n\n  [CardType.Fish2]: {\n    elements: option.some({ double: Element.Water, single: Element.Water }),\n    elementCounts: ElementCount.W3,\n    tripletShifts: [TripletShift.Water, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Elephant2]: {\n    elements: option.some({ double: Element.Earth, single: Element.Earth }),\n    elementCounts: ElementCount.E3,\n    tripletShifts: [TripletShift.Earth, TripletShift.None],\n    canRetreat: false,\n  },\n  [CardType.Squid2]: {\n    elements: option.some({ double: Element.Water, single: Element.Fire }),\n    elementCounts: ElementCount.W2 | ElementCount.F1,\n    tripletShifts: [TripletShift.Water, TripletShift.Fire],\n    canRetreat: true,\n  },\n  [CardType.Frog2]: {\n    elements: option.some({ double: Element.Water, single: Element.Air }),\n    elementCounts: ElementCount.W2 | ElementCount.A1,\n    tripletShifts: [TripletShift.Water, TripletShift.Air],\n    canRetreat: false,\n  },\n\n  [CardType.AlphaSnipe]: {\n    elements: option.none(),\n    elementCounts: 0,\n    tripletShifts: [TripletShift.None, TripletShift.None],\n    canRetreat: true,\n  },\n  [CardType.BetaSnipe]: {\n    elements: option.none(),\n    elementCounts: 0,\n    tripletShifts: [TripletShift.None, TripletShift.None],\n    canRetreat: true,\n  },\n};\n\nexport const cardEmojis: CardMap<string> = {\n  [CardType.Mouse1]: \"🐀\",\n  [CardType.Mouse2]: \"🐀\",\n  [CardType.Ox1]: \"🐮\",\n  [CardType.Ox2]: \"🐮\",\n  [CardType.Tiger1]: \"🐯\",\n  [CardType.Tiger2]: \"🐯\",\n  [CardType.Rabbit1]: \"🐇\",\n  [CardType.Rabbit2]: \"🐇\",\n  [CardType.Dragon1]: \"🐉 \",\n  [CardType.Dragon2]: \"🐉 \",\n  [CardType.Snake1]: \"🐍\",\n  [CardType.Snake2]: \"🐍\",\n  [CardType.Horse1]: \"🐴\",\n  [CardType.Horse2]: \"🐴\",\n  [CardType.Ram1]: \"🐏\",\n  [CardType.Ram2]: \"🐏\",\n  [CardType.Monkey1]: \"🐵\",\n  [CardType.Monkey2]: \"🐵\",\n  [CardType.Rooster1]: \"🐓\",\n  [CardType.Rooster2]: \"🐓\",\n  [CardType.Dog1]: \"🐶\",\n  [CardType.Dog2]: \"🐶\",\n  [CardType.Boar1]: \"🐗\",\n  [CardType.Boar2]: \"🐗\",\n  [CardType.Fish1]: \"🐟\",\n  [CardType.Fish2]: \"🐟\",\n  [CardType.Elephant1]: \"🐘\",\n  [CardType.Elephant2]: \"🐘\",\n  [CardType.Squid1]: \"🦑\",\n  [CardType.Squid2]: \"🦑\",\n  [CardType.Frog1]: \"🐸\",\n  [CardType.Frog2]: \"🐸\",\n\n  [CardType.AlphaSnipe]: \"α\",\n  [CardType.BetaSnipe]: \"β\",\n};\n","export enum Offset {\n  AlphaAnimals = 0,\n  BetaAnimals = 1,\n  Snipes = 2,\n}\n\nexport enum Filter {\n  LeastBit = 0b1,\n  LeastTwoBits = 0b11,\n  LeastThreeBits = 0b111,\n  LeastFiveBits = 0b1_1111,\n  LeastSixBits = 0b11_1111,\n  LeastTenBits = 0b11_1111_1111,\n  LeastSixteenBits = 0b1111_1111_1111_1111,\n}\n\nexport enum PlyTag {\n  SnipeStep = 0b001,\n  Drop = 0b010,\n  TwoAnimalSteps = 0b011,\n}\n\n// https://stackoverflow.com/a/43122214/7215455\nexport function bitCount(n: number): number {\n  n = n - ((n >> 1) & 0x55555555);\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n  return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n}\n","import { Option, option } from \"rusty-ts\";\nimport { Offset } from \"./bitwiseUtils\";\nimport {\n  allCardLocations,\n  Board,\n  CardType,\n  GameState,\n  Player,\n  STATE_VERSION,\n} from \"./types\";\n\nexport interface GameStateFactory {\n  fromString(s: string): Option<GameState>;\n  fromBoard(board: Board): GameState;\n}\n\nexport const gameStateFactory: GameStateFactory = { fromString, fromBoard };\n\nfunction fromString(s: string): Option<GameState> {\n  const parsed = JSON.parse(s, (key, value) => {\n    if (key === \"initialBoard\" || key === \"currentBoard\") {\n      return new Int32Array(value);\n    } else {\n      return value;\n    }\n  });\n\n  if (parsed.stateVersion !== STATE_VERSION) {\n    return option.none();\n  }\n\n  return option.some(parsed);\n}\n\nfunction fromBoard(board: Board): GameState {\n  const initialBoard = new Int32Array(24);\n\n  for (const location of allCardLocations) {\n    const cards = board[location];\n    for (const card of cards) {\n      if (\n        card.cardType === CardType.AlphaSnipe ||\n        card.cardType === CardType.BetaSnipe\n      ) {\n        const cardSet = card.cardType === CardType.AlphaSnipe ? 1 : 1 << 1;\n        const offset = Offset.Snipes;\n        initialBoard[location * 3 + offset] |= cardSet;\n      } else {\n        const cardSet = 1 << card.cardType;\n        const offset =\n          card.allegiance === Player.Alpha\n            ? Offset.AlphaAnimals\n            : Offset.BetaAnimals;\n        initialBoard[location * 3 + offset] |= cardSet;\n      }\n    }\n  }\n\n  const data: GameState = {\n    stateVersion: STATE_VERSION,\n    initialBoard,\n    currentBoard: initialBoard,\n    turn: Player.Beta,\n    plies: [],\n    pendingAnimalStep: 0,\n  };\n\n  return data;\n}\n","export default function randInt(inclMin: number, exclMax: number): number {\n  const diff = exclMax - inclMin;\n  return inclMin + Math.floor(diff * Math.random());\n}\n","import { Filter, PlyTag } from \"./bitwiseUtils\";\nimport { cardProperties } from \"./cardMaps\";\nimport { gameStateFactory } from \"./gameStateFactory\";\nimport randInt from \"./randInt\";\nimport {\n  AnimalStep,\n  AnimalType,\n  Atomic,\n  Card,\n  CardLocation,\n  CardType,\n  GameState,\n  Player,\n  Ply,\n  PlyType,\n  Row,\n  SnipeType,\n} from \"./types\";\n\nexport function getRandomGameState(): GameState {\n  const { alpha, beta } = getShuffledDecks();\n  return gameStateFactory.fromBoard({\n    [CardLocation.AlphaReserve]: [alpha.pop()!],\n    [CardLocation.Row1]: [\n      alpha.pop()!,\n      { cardType: CardType.AlphaSnipe, allegiance: Player.Alpha },\n      alpha.pop()!,\n    ],\n    [CardLocation.Row2]: [\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n      alpha.pop()!,\n    ],\n    [CardLocation.Row3]: [alpha.pop()!],\n\n    [CardLocation.Row4]: [beta.pop()!],\n    [CardLocation.Row5]: [\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n      beta.pop()!,\n    ],\n    [CardLocation.Row6]: [\n      beta.pop()!,\n      { cardType: CardType.BetaSnipe, allegiance: Player.Beta },\n      beta.pop()!,\n    ],\n    [CardLocation.BetaReserve]: [beta.pop()!],\n  });\n}\n\nfunction getShuffledDecks(): { alpha: Card[]; beta: Card[] } {\n  const minors: CardType[] = [\n    CardType.Mouse1,\n    CardType.Ox1,\n    CardType.Rabbit1,\n    CardType.Snake1,\n    CardType.Horse1,\n    CardType.Ram1,\n    CardType.Monkey1,\n    CardType.Rooster1,\n    CardType.Dog1,\n    CardType.Boar1,\n\n    CardType.Squid1,\n    CardType.Frog1,\n\n    CardType.Mouse2,\n    CardType.Ox2,\n    CardType.Rabbit2,\n    CardType.Snake2,\n    CardType.Horse2,\n    CardType.Ram2,\n    CardType.Monkey2,\n    CardType.Rooster2,\n    CardType.Dog2,\n    CardType.Boar2,\n\n    CardType.Squid2,\n    CardType.Frog2,\n  ];\n  const majors: CardType[] = [\n    CardType.Tiger1,\n    CardType.Dragon1,\n    CardType.Fish1,\n    CardType.Elephant1,\n\n    CardType.Tiger2,\n    CardType.Dragon2,\n    CardType.Fish2,\n    CardType.Elephant2,\n  ];\n\n  shuffle(minors);\n  shuffle(majors);\n\n  const alpha: Card[] = minors\n    .slice(0, 12)\n    .concat(majors.slice(0, 4))\n    .map((cardType) => ({ cardType, allegiance: Player.Alpha }));\n  const beta: Card[] = minors\n    .slice(12)\n    .concat(majors.slice(4))\n    .map((cardType) => ({ cardType, allegiance: Player.Beta }));\n\n  shuffle(alpha);\n  shuffle(beta);\n\n  return { alpha, beta };\n}\n\nfunction shuffle(arr: unknown[]): void {\n  const SHUFFLE_REPETITIONS = 512;\n  const len = arr.length;\n\n  for (let k = 0; k < SHUFFLE_REPETITIONS; k++) {\n    for (let i = 0; i <= len - 2; i++) {\n      const j = randInt(i, len);\n      const temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n    }\n  }\n}\n\nexport function isReserve(\n  location: CardLocation\n): location is CardLocation.AlphaReserve | CardLocation.BetaReserve {\n  return (\n    location === CardLocation.AlphaReserve ||\n    location === CardLocation.BetaReserve\n  );\n}\n\nexport function canRetreat(cardType: CardType): boolean {\n  return cardProperties[cardType].canRetreat;\n}\n\nexport function opponentOf(player: Player): Player {\n  switch (player) {\n    case Player.Alpha:\n      return Player.Beta;\n    case Player.Beta:\n      return Player.Alpha;\n  }\n}\n\nexport function snipeOf(player: Player): SnipeType {\n  switch (player) {\n    case Player.Alpha:\n      return CardType.AlphaSnipe;\n    case Player.Beta:\n      return CardType.BetaSnipe;\n  }\n}\n\nexport function oneRowForward(row: Row, player: Player): CardLocation {\n  const diff = player === Player.Alpha ? 1 : -1;\n  return row + diff;\n}\n\nexport function oneRowBackward(row: Row, player: Player): CardLocation {\n  const diff = player === Player.Alpha ? -1 : 1;\n  return row + diff;\n}\n\nexport function isRow(location: CardLocation): location is Row {\n  return !(\n    location === CardLocation.AlphaReserve ||\n    location === CardLocation.BetaReserve\n  );\n}\n\nexport function decodePly(ply: number): Ply {\n  const tag = (ply & Filter.LeastThreeBits) as PlyTag;\n  switch (tag) {\n    case PlyTag.SnipeStep: {\n      const destination = ((ply >>> 3) & Filter.LeastThreeBits) as Row;\n      return { plyType: PlyType.SnipeStep, destination };\n    }\n\n    case PlyTag.Drop: {\n      const cardType = ((ply >>> 3) & Filter.LeastFiveBits) as AnimalType;\n      const destination = ((ply >>> 8) & Filter.LeastThreeBits) as Row;\n      return {\n        plyType: PlyType.Drop,\n        dropped: cardType,\n        destination,\n      };\n    }\n\n    case PlyTag.TwoAnimalSteps: {\n      const firstCardType = ((ply >>> 3) & Filter.LeastFiveBits) as AnimalType;\n      const firstDestination = ((ply >>> 8) & Filter.LeastThreeBits) as Row;\n      const secondCardType = ((ply >>> 11) &\n        Filter.LeastFiveBits) as AnimalType;\n      const secondDestination = ((ply >>> 16) & Filter.LeastThreeBits) as Row;\n      return {\n        plyType: PlyType.TwoAnimalSteps,\n        first: { moved: firstCardType, destination: firstDestination },\n        second: { moved: secondCardType, destination: secondDestination },\n      };\n    }\n  }\n}\n\nexport function isAnimalStep(atomic: Atomic): atomic is AnimalStep {\n  return !(\"plyType\" in atomic);\n}\n","import { Option, option, Result, result } from \"rusty-ts\";\nimport { bitCount, Filter, Offset, PlyTag } from \"./bitwiseUtils\";\nimport { cardProperties } from \"./cardMaps\";\nimport {\n  canRetreat,\n  decodePly,\n  isReserve,\n  isRow,\n  oneRowBackward,\n  oneRowForward,\n  opponentOf,\n  snipeOf,\n} from \"./gameUtil\";\nimport {\n  allAnimalTypes,\n  allCardLocations,\n  allRows,\n  AnimalStep,\n  AnimalType,\n  Atomic,\n  Board,\n  CardLocation,\n  CardType,\n  Drop,\n  GameStateAnalyzer,\n  GameState,\n  IllegalGameStateUpdate,\n  legalRetreaterDrops,\n  Player,\n  Ply,\n  PlyType,\n  Row,\n  SnipeStep,\n  SnipeType,\n} from \"./types\";\n\nexport function getStateAnalyzer(initState: GameState): GameStateAnalyzer {\n  let state = initState;\n\n  return {\n    getInitialState,\n    getBoard,\n    getPlies,\n    getPendingAnimalStep,\n    isGameOver,\n    getWinner,\n    getTurn,\n    getCardLocation,\n    tryUndoSubPly,\n    tryPerform,\n    serialize,\n    toNodeKey,\n    setState,\n    getLegalAtomics,\n    forcePerform,\n  };\n\n  function getInitialState(): GameState {\n    return {\n      stateVersion: state.stateVersion,\n      initialBoard: state.initialBoard,\n      currentBoard: state.initialBoard,\n      turn: Player.Beta,\n      plies: [],\n      pendingAnimalStep: 0,\n    };\n  }\n\n  function getBoard(): Board {\n    const board: Board = {\n      [CardLocation.AlphaReserve]: [],\n      [CardLocation.Row1]: [],\n      [CardLocation.Row2]: [],\n      [CardLocation.Row3]: [],\n      [CardLocation.Row4]: [],\n      [CardLocation.Row5]: [],\n      [CardLocation.Row6]: [],\n      [CardLocation.BetaReserve]: [],\n    };\n\n    for (const location of allCardLocations) {\n      const cards = board[location];\n\n      const alphaAnimals =\n        state.currentBoard[location * 3 + Offset.AlphaAnimals];\n      const betaAnimals = state.currentBoard[location * 3 + Offset.BetaAnimals];\n\n      allAnimalTypes.forEach((animalType) => {\n        if (((1 << animalType) & alphaAnimals) !== 0) {\n          cards.push({ cardType: animalType, allegiance: Player.Alpha });\n        }\n\n        if (((1 << animalType) & betaAnimals) !== 0) {\n          cards.push({ cardType: animalType, allegiance: Player.Beta });\n        }\n      });\n\n      const snipes = state.currentBoard[location * 3 + Offset.Snipes];\n\n      if (((1 << Player.Alpha) & snipes) !== 0) {\n        cards.push({ cardType: CardType.AlphaSnipe, allegiance: Player.Alpha });\n      }\n      if (((1 << Player.Beta) & snipes) !== 0) {\n        cards.push({ cardType: CardType.BetaSnipe, allegiance: Player.Beta });\n      }\n    }\n\n    return board;\n  }\n\n  function getPlies(): Ply[] {\n    return state.plies.map(decodePly);\n  }\n\n  function getPendingAnimalStep(): Option<AnimalStep> {\n    const { pendingAnimalStep } = state;\n\n    if (pendingAnimalStep === 0) {\n      return option.none();\n    }\n\n    const cardType = ((pendingAnimalStep >>> 3) &\n      Filter.LeastFiveBits) as AnimalType;\n    const destination = ((pendingAnimalStep >>> 8) &\n      Filter.LeastThreeBits) as Row;\n    return option.some({\n      moved: cardType,\n      destination,\n    });\n  }\n\n  function isGameOver(): boolean {\n    return getWinner().isSome();\n  }\n\n  function getWinner(): Option<Player> {\n    if (isAlphaSnipeCapturedByBeta()) {\n      return option.some(Player.Beta);\n    }\n\n    if (isBetaSnipeCapturedByAlpha()) {\n      return option.some(Player.Alpha);\n    }\n\n    if (getLegalAtomics().length === 0) {\n      return option.some(opponentOf(state.turn));\n    }\n\n    return option.none();\n  }\n\n  function isAlphaSnipeCapturedByBeta(): boolean {\n    const snipes =\n      state.currentBoard[CardLocation.BetaReserve * 3 + Offset.Snipes];\n    return ((1 << Player.Alpha) & snipes) !== 0;\n  }\n\n  function isBetaSnipeCapturedByAlpha(): boolean {\n    const snipes =\n      state.currentBoard[CardLocation.AlphaReserve * 3 + Offset.Snipes];\n    return ((1 << Player.Beta) & snipes) !== 0;\n  }\n\n  function getLegalAtomics(): Atomic[] {\n    if (isEitherSnipeCaptured()) {\n      return [];\n    }\n\n    const atomics: Atomic[] = [];\n\n    // Only add full plies if there is no pending subply\n    if (state.pendingAnimalStep === 0) {\n      // Snipe steps\n      {\n        const activeSnipe = snipeOf(state.turn);\n        const snipeLocation = getSnipeLocation(activeSnipe) as Row;\n        const animals =\n          state.currentBoard[snipeLocation * 3 + Offset.AlphaAnimals] |\n          state.currentBoard[snipeLocation * 3 + Offset.BetaAnimals];\n        const snipes = state.currentBoard[snipeLocation * 3 + Offset.Snipes];\n        const enemySnipeFilter = 1 << opponentOf(state.turn);\n        if ((snipes & enemySnipeFilter) | animals) {\n          const forward = oneRowForward(snipeLocation, state.turn);\n          if (isRow(forward)) {\n            atomics.push({\n              plyType: PlyType.SnipeStep,\n              destination: forward,\n            });\n          }\n\n          const backward = oneRowBackward(snipeLocation, state.turn);\n          if (isRow(backward)) {\n            atomics.push({\n              plyType: PlyType.SnipeStep,\n              destination: backward,\n            });\n          }\n        }\n      }\n\n      // Drops\n      {\n        const reserve =\n          state.turn === Player.Alpha\n            ? CardLocation.AlphaReserve\n            : CardLocation.BetaReserve;\n        const friendlyAnimals =\n          state.currentBoard[\n            reserve * 3 +\n              (state.turn === Player.Alpha\n                ? Offset.AlphaAnimals\n                : Offset.BetaAnimals)\n          ];\n\n        if (bitCount(friendlyAnimals) > 1) {\n          for (const cardType of allAnimalTypes) {\n            if ((1 << cardType) & friendlyAnimals) {\n              const desinations = canRetreat(cardType)\n                ? legalRetreaterDrops[state.turn]\n                : allRows;\n              for (const row of desinations) {\n                atomics.push({\n                  plyType: PlyType.Drop,\n                  dropped: cardType,\n                  destination: row,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Animal steps are always legal atomics, if there are any\n    for (const row of allRows) {\n      const friendlyAnimals =\n        state.currentBoard[\n          row * 3 +\n            (state.turn === Player.Alpha\n              ? Offset.AlphaAnimals\n              : Offset.BetaAnimals)\n        ];\n\n      if (!friendlyAnimals) {\n        continue;\n      }\n\n      const animals =\n        state.currentBoard[row * 3 + Offset.AlphaAnimals] |\n        state.currentBoard[row * 3 + Offset.BetaAnimals];\n      const snipes = state.currentBoard[row * 3 + Offset.Snipes];\n      const doesRowHaveAtLeastTwoCards = (bitCount(animals) >>> 1) | snipes;\n      const enemySnipeFilter =\n        state.turn === Player.Alpha ? 1 << Player.Beta : 1 << Player.Alpha;\n\n      for (const cardType of allAnimalTypes) {\n        if (\n          state.pendingAnimalStep &&\n          ((state.pendingAnimalStep >>> 3) & Filter.LeastFiveBits) === cardType\n        ) {\n          continue;\n        }\n\n        if ((1 << cardType) & friendlyAnimals) {\n          if (doesRowHaveAtLeastTwoCards) {\n            const friendlySnipeFilter =\n              state.turn === Player.Alpha\n                ? 1 << Player.Alpha\n                : 1 << Player.Beta;\n\n            const forward = oneRowForward(row, state.turn);\n            const forwardSnipes =\n              state.currentBoard[forward * 3 + Offset.Snipes];\n            if (\n              isRow(forward) &&\n              !(\n                forwardSnipes & friendlySnipeFilter &&\n                !(forwardSnipes & enemySnipeFilter) &&\n                doesStepActivateTriplet(\n                  state.currentBoard[forward * 3 + Offset.AlphaAnimals] |\n                    state.currentBoard[forward * 3 + Offset.BetaAnimals],\n                  cardType\n                )\n              )\n            ) {\n              atomics.push({ moved: cardType, destination: forward });\n            }\n\n            if (canRetreat(cardType)) {\n              const backward = oneRowBackward(row, state.turn);\n              const backwardSnipes =\n                state.currentBoard[backward * 3 + Offset.Snipes];\n              if (\n                isRow(backward) &&\n                !(\n                  backwardSnipes & friendlySnipeFilter &&\n                  !(backwardSnipes & enemySnipeFilter) &&\n                  doesStepActivateTriplet(\n                    state.currentBoard[backward * 3 + Offset.AlphaAnimals] |\n                      state.currentBoard[backward * 3 + Offset.BetaAnimals],\n                    cardType\n                  )\n                )\n              ) {\n                atomics.push({ moved: cardType, destination: backward });\n              }\n            }\n          } else {\n            const forward = oneRowForward(row, state.turn);\n            if (\n              isRow(forward) &&\n              snipes & enemySnipeFilter &&\n              doesStepActivateTriplet(\n                state.currentBoard[forward * 3 + Offset.AlphaAnimals] |\n                  state.currentBoard[forward * 3 + Offset.BetaAnimals],\n                cardType\n              )\n            ) {\n              atomics.push({ moved: cardType, destination: forward });\n            }\n\n            if (canRetreat(cardType)) {\n              const backward = oneRowBackward(row, state.turn);\n              if (\n                isRow(backward) &&\n                snipes & enemySnipeFilter &&\n                doesStepActivateTriplet(\n                  state.currentBoard[backward * 3 + Offset.AlphaAnimals] |\n                    state.currentBoard[backward * 3 + Offset.BetaAnimals],\n                  cardType\n                )\n              ) {\n                atomics.push({ moved: cardType, destination: backward });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return atomics;\n  }\n\n  function isEitherSnipeCaptured() {\n    return isAlphaSnipeCapturedByBeta() || isBetaSnipeCapturedByAlpha();\n  }\n\n  function doesStepActivateTriplet(\n    oldAnimals: number,\n    newAnimal: AnimalType\n  ): boolean {\n    let rowElementCounts = cardProperties[newAnimal].elementCounts;\n\n    for (const cardType of allAnimalTypes) {\n      if ((1 << cardType) & oldAnimals) {\n        rowElementCounts |= cardProperties[cardType].elementCounts;\n      }\n    }\n\n    const [shift1, shift2] = cardProperties[newAnimal].tripletShifts;\n    return (\n      ((rowElementCounts >>> shift1) & 0b111) === 0b111 ||\n      ((rowElementCounts >>> shift2) & 0b111) === 0b111\n    );\n  }\n\n  function getTurn(): Player {\n    return state.turn;\n  }\n\n  function getCardLocation(cardType: CardType): CardLocation {\n    switch (cardType) {\n      case CardType.AlphaSnipe:\n      case CardType.BetaSnipe:\n        return getSnipeLocation(cardType);\n      default:\n        return getAnimalLocation(cardType);\n    }\n  }\n\n  function getSnipeLocation(cardType: SnipeType): CardLocation {\n    const snipeFilter =\n      cardType === CardType.AlphaSnipe ? 1 << Player.Alpha : 1 << Player.Beta;\n\n    for (const location of allCardLocations) {\n      const snipes = state.currentBoard[location * 3 + Offset.Snipes];\n      if ((snipes & snipeFilter) !== 0) {\n        return location;\n      }\n    }\n\n    throw new Error(\n      \"Impossible: \" + CardType[cardType] + \" cannot be found in \" + serialize()\n    );\n  }\n\n  function getAnimalLocation(cardType: AnimalType): CardLocation {\n    const animalFilter = 1 << cardType;\n\n    for (const location of allCardLocations) {\n      const animals =\n        state.currentBoard[location * 3 + Offset.AlphaAnimals] |\n        state.currentBoard[location * 3 + Offset.BetaAnimals];\n      if ((animals & animalFilter) !== 0) {\n        return location;\n      }\n    }\n\n    throw new Error(\n      \"Impossible: \" + CardType[cardType] + \" cannot be found in \" + serialize()\n    );\n  }\n\n  function tryUndoSubPly(): Result<\n    { newState: GameState; undone: SnipeStep | Drop | AnimalStep },\n    IllegalGameStateUpdate\n  > {\n    if (state.plies.length === 0 && state.pendingAnimalStep === 0) {\n      return result.err(IllegalGameStateUpdate.NothingToUndo);\n    }\n\n    if (state.pendingAnimalStep !== 0) {\n      const outOfSyncState = cloneState(state);\n      outOfSyncState.pendingAnimalStep = 0;\n\n      const undone: AnimalStep = {\n        moved: (state.pendingAnimalStep >>> 3) & Filter.LeastFiveBits,\n        destination: (state.pendingAnimalStep >>> 8) & Filter.LeastThreeBits,\n      };\n      return result.ok({\n        newState: recalculateOutOfSyncGameState(outOfSyncState),\n        undone,\n      });\n    }\n\n    const outOfSyncState = cloneState(state);\n    const encodedPly = outOfSyncState.plies.pop()!;\n    const ply = decodePly(encodedPly);\n    let undone: SnipeStep | Drop | AnimalStep;\n\n    if (ply.plyType === PlyType.TwoAnimalSteps) {\n      const encodedFirstStep =\n        (ply.first.destination << 8) | (ply.first.moved << 3) | 0b001;\n      outOfSyncState.pendingAnimalStep = encodedFirstStep;\n\n      undone = ply.second;\n    } else {\n      undone = ply;\n    }\n\n    return result.ok({\n      newState: recalculateOutOfSyncGameState(outOfSyncState),\n      undone,\n    });\n  }\n\n  function recalculateOutOfSyncGameState(\n    originalMutState: GameState\n  ): GameState {\n    let mutState = originalMutState;\n    const stateAnalyzer = getStateAnalyzer(mutState);\n\n    mutState.currentBoard = new Int32Array(mutState.initialBoard);\n\n    const plies = mutState.plies.map(decodePly);\n    const encodedPendingAnimalStep = mutState.pendingAnimalStep;\n\n    mutState.plies = [];\n    mutState.pendingAnimalStep = 0;\n    mutState.turn = Player.Beta;\n\n    plies.forEach((ply) => {\n      if (ply.plyType === PlyType.TwoAnimalSteps) {\n        stateAnalyzer.setState(mutState);\n        mutState = stateAnalyzer.forcePerform(ply.first);\n        stateAnalyzer.setState(mutState);\n        mutState = stateAnalyzer.forcePerform(ply.second);\n      } else {\n        stateAnalyzer.setState(mutState);\n        mutState = stateAnalyzer.forcePerform(ply);\n      }\n    });\n\n    if (encodedPendingAnimalStep) {\n      stateAnalyzer.setState(mutState);\n      const step: AnimalStep = {\n        moved: (encodedPendingAnimalStep >>> 3) & Filter.LeastFiveBits,\n        destination: (encodedPendingAnimalStep >>> 8) & Filter.LeastThreeBits,\n      };\n      mutState = stateAnalyzer.forcePerform(step);\n    }\n\n    return mutState;\n  }\n\n  function tryPerform(\n    atomic: Atomic\n  ): Result<GameState, IllegalGameStateUpdate> {\n    return getReasonWhyAtomicIsIllegal(atomic).match({\n      some: result.err,\n      none: () => result.ok(forcePerform(atomic)),\n    });\n  }\n\n  function getReasonWhyAtomicIsIllegal(\n    atomic: Atomic\n  ): Option<IllegalGameStateUpdate> {\n    if (isEitherSnipeCaptured()) {\n      return option.some(IllegalGameStateUpdate.SnipeAlreadyCaptured);\n    }\n\n    if (\"plyType\" in atomic) {\n      switch (atomic.plyType) {\n        case PlyType.SnipeStep: {\n          if (state.pendingAnimalStep) {\n            return option.some(IllegalGameStateUpdate.AlreadyMovedAnimal);\n          }\n\n          const moved = snipeOf(state.turn);\n          if (!isInRange(moved, state.turn, atomic.destination)) {\n            return option.some(\n              IllegalGameStateUpdate.StepDestinationOutOfRange\n            );\n          }\n\n          const location = getSnipeLocation(moved) as Row;\n          const animals =\n            state.currentBoard[location * 3 + Offset.AlphaAnimals] |\n            state.currentBoard[location * 3 + Offset.BetaAnimals];\n          const snipes = state.currentBoard[location * 3 + Offset.Snipes];\n          const enemySnipeFilter =\n            state.turn === Player.Alpha ? 1 << Player.Beta : 1 << Player.Alpha;\n          if (!(animals | (snipes & enemySnipeFilter))) {\n            return option.some(\n              IllegalGameStateUpdate.CannotEmptyRowWithoutImmediatelyWinning\n            );\n          }\n\n          return option.none();\n        }\n\n        case PlyType.Drop: {\n          if (state.pendingAnimalStep) {\n            return option.some(IllegalGameStateUpdate.AlreadyMovedAnimal);\n          }\n\n          const reserveAnimals =\n            state.currentBoard[\n              (state.turn === Player.Alpha\n                ? CardLocation.AlphaReserve\n                : CardLocation.BetaReserve) *\n                3 +\n                (state.turn === Player.Alpha\n                  ? Offset.AlphaAnimals\n                  : Offset.BetaAnimals)\n            ];\n          if (!((1 << atomic.dropped) & reserveAnimals)) {\n            return option.some(\n              IllegalGameStateUpdate.DroppedAnimalNotInReserve\n            );\n          }\n\n          if (!(reserveAnimals & ~(1 << atomic.dropped))) {\n            return option.some(IllegalGameStateUpdate.CannotEmptyReserve);\n          }\n\n          if (\n            canRetreat(atomic.dropped) &&\n            !legalRetreaterDrops[state.turn].includes(atomic.destination)\n          ) {\n            return option.some(\n              IllegalGameStateUpdate.CannotDropRetreaterOnEnemysBackTwoRows\n            );\n          }\n\n          return option.none();\n        }\n      }\n    } else {\n      const location = getAnimalLocation(atomic.moved);\n\n      if (isReserve(location)) {\n        return option.some(IllegalGameStateUpdate.MovedCardInReserve);\n      }\n\n      const friendlyAnimals =\n        state.currentBoard[\n          location * 3 +\n            (state.turn === Player.Alpha\n              ? Offset.AlphaAnimals\n              : Offset.BetaAnimals)\n        ];\n      if (!((1 << atomic.moved) & friendlyAnimals)) {\n        return option.some(IllegalGameStateUpdate.NotYourAnimal);\n      }\n\n      if (!isInRange(atomic.moved, state.turn, atomic.destination)) {\n        return option.some(IllegalGameStateUpdate.StepDestinationOutOfRange);\n      }\n\n      if (\n        state.pendingAnimalStep &&\n        ((state.pendingAnimalStep >>> 3) & Filter.LeastFiveBits) ===\n          atomic.moved\n      ) {\n        return option.some(IllegalGameStateUpdate.CannotMoveSameAnimalTwice);\n      }\n\n      const destAnimals =\n        state.currentBoard[atomic.destination * 3 + Offset.AlphaAnimals] |\n        state.currentBoard[atomic.destination * 3 + Offset.BetaAnimals];\n      const activatesTriplet = doesStepActivateTriplet(\n        destAnimals,\n        atomic.moved\n      );\n\n      const destSnipes =\n        state.currentBoard[atomic.destination * 3 + Offset.Snipes];\n      const enemySnipeFilter =\n        state.turn === Player.Alpha ? 1 << Player.Beta : 1 << Player.Alpha;\n      const enemySnipeInDest = destSnipes & enemySnipeFilter;\n\n      const sourceAnimals =\n        state.currentBoard[location * 3 + Offset.AlphaAnimals] |\n        state.currentBoard[location * 3 + Offset.BetaAnimals];\n      const sourceSnipes = state.currentBoard[location * 3 + Offset.Snipes];\n      const doesSourceRowHaveAnotherCard =\n        (sourceAnimals & ~(1 << atomic.moved)) | sourceSnipes;\n\n      const friendlySnipeFilter =\n        state.turn === Player.Alpha ? 1 << Player.Alpha : 1 << Player.Beta;\n      const friendlySnipeInDest = destSnipes & friendlySnipeFilter;\n\n      if (doesSourceRowHaveAnotherCard) {\n        if (activatesTriplet && friendlySnipeInDest && !enemySnipeInDest) {\n          return option.some(\n            IllegalGameStateUpdate.CannotCaptureOwnSnipeWithoutAlsoCapturingOpponents\n          );\n        } else {\n          return option.none();\n        }\n      } else {\n        if (activatesTriplet && enemySnipeInDest) {\n          return option.none();\n        } else {\n          return option.some(\n            IllegalGameStateUpdate.CannotEmptyRowWithoutImmediatelyWinning\n          );\n        }\n      }\n    }\n  }\n\n  function isInRange(\n    movedType: CardType,\n    movedAllegiance: Player,\n    destination: Row\n  ): boolean {\n    const location = getCardLocation(movedType);\n\n    if (isReserve(location)) {\n      return false;\n    }\n\n    return (\n      oneRowForward(location, movedAllegiance) === destination ||\n      (canRetreat(movedType) &&\n        oneRowBackward(location, movedAllegiance) === destination)\n    );\n  }\n\n  function forcePerform(atomic: Atomic): GameState {\n    if (\"plyType\" in atomic) {\n      switch (atomic.plyType) {\n        case PlyType.SnipeStep:\n          return forcePerformSnipeStep(atomic);\n        case PlyType.Drop:\n          return forcePerformDrop(atomic);\n      }\n    } else {\n      return forcePerformAnimalStep(atomic);\n    }\n  }\n\n  function forcePerformSnipeStep(step: SnipeStep): GameState {\n    const friendlySnipeLocation = getCardLocation(snipeOf(state.turn)) as Row;\n    const friendlySnipeSet = 1 << state.turn;\n    const removeFriendlySnipeFilter = ~friendlySnipeSet;\n\n    const newState = cloneState(state);\n    newState.currentBoard[\n      friendlySnipeLocation * 3 + Offset.Snipes\n    ] &= removeFriendlySnipeFilter;\n    newState.currentBoard[\n      step.destination * 3 + Offset.Snipes\n    ] |= friendlySnipeSet;\n\n    newState.plies.push((step.destination << 3) | PlyTag.SnipeStep);\n\n    newState.turn = opponentOf(newState.turn);\n\n    return newState;\n  }\n\n  function cloneState(src: GameState): GameState {\n    return {\n      stateVersion: src.stateVersion,\n      initialBoard: new Int32Array(src.initialBoard),\n      currentBoard: new Int32Array(src.currentBoard),\n      turn: src.turn,\n      plies: src.plies.slice(),\n      pendingAnimalStep: src.pendingAnimalStep,\n    };\n  }\n\n  function forcePerformDrop(drop: Drop): GameState {\n    const reserve =\n      state.turn === Player.Alpha\n        ? CardLocation.AlphaReserve\n        : CardLocation.BetaReserve;\n    const friendlyOffset =\n      state.turn === Player.Alpha ? Offset.AlphaAnimals : Offset.BetaAnimals;\n    const droppedSet = 1 << drop.dropped;\n    const removeDroppedFilter = ~droppedSet;\n\n    const newState = cloneState(state);\n    newState.currentBoard[reserve * 3 + friendlyOffset] &= removeDroppedFilter;\n    newState.currentBoard[drop.destination * 3 + friendlyOffset] |= droppedSet;\n\n    newState.plies.push(\n      (drop.destination << 8) | (drop.dropped << 3) | PlyTag.Drop\n    );\n\n    newState.turn = opponentOf(newState.turn);\n\n    return newState;\n  }\n\n  function forcePerformAnimalStep(step: AnimalStep): GameState {\n    const start = getCardLocation(step.moved) as Row;\n    const friendlyOffset =\n      state.turn === Player.Alpha ? Offset.AlphaAnimals : Offset.BetaAnimals;\n\n    const destAnimalsBeforeStep =\n      state.currentBoard[step.destination * 3 + Offset.AlphaAnimals] |\n      state.currentBoard[step.destination * 3 + Offset.BetaAnimals];\n\n    const newState = cloneState(state);\n\n    const movedSet = 1 << step.moved;\n    const removeMovedFilter = ~movedSet;\n    newState.currentBoard[start * 3 + friendlyOffset] &= removeMovedFilter;\n\n    if (doesStepActivateTriplet(destAnimalsBeforeStep, step.moved)) {\n      const friendlyReserve =\n        state.turn === Player.Alpha\n          ? CardLocation.AlphaReserve\n          : CardLocation.BetaReserve;\n      const destSnipesBeforeStep =\n        state.currentBoard[step.destination * 3 + Offset.Snipes];\n      const enemyOffset =\n        state.turn === Player.Alpha ? Offset.BetaAnimals : Offset.AlphaAnimals;\n\n      newState.currentBoard[\n        friendlyReserve * 3 + friendlyOffset\n      ] |= destAnimalsBeforeStep;\n      newState.currentBoard[\n        friendlyReserve * 3 + Offset.Snipes\n      ] |= destSnipesBeforeStep;\n\n      newState.currentBoard[step.destination * 3 + friendlyOffset] = movedSet;\n      newState.currentBoard[step.destination * 3 + enemyOffset] = 0;\n      newState.currentBoard[step.destination * 3 + Offset.Snipes] = 0;\n    } else {\n      newState.currentBoard[step.destination * 3 + friendlyOffset] |= movedSet;\n    }\n\n    if (newState.pendingAnimalStep) {\n      const encodePlyWithIncorrectTag =\n        (step.destination << 16) |\n        (step.moved << 11) |\n        newState.pendingAnimalStep;\n      newState.plies.push(\n        (encodePlyWithIncorrectTag & ~Filter.LeastThreeBits) |\n          PlyTag.TwoAnimalSteps\n      );\n      newState.pendingAnimalStep = 0;\n      newState.turn = opponentOf(newState.turn);\n    } else {\n      newState.pendingAnimalStep =\n        (step.destination << 8) | (step.moved << 3) | 0b001;\n    }\n\n    return newState;\n  }\n\n  function serialize(): string {\n    return JSON.stringify(state, (_key, value) => {\n      if (value instanceof Int32Array) {\n        return Array.from(value);\n      } else {\n        return value;\n      }\n    });\n  }\n\n  function toNodeKey(): string {\n    const { currentBoard } = state;\n    return String.fromCharCode(\n      // Animals\n      currentBoard[0] & Filter.LeastSixteenBits,\n      currentBoard[0] >>> 16,\n      currentBoard[1] & Filter.LeastSixteenBits,\n      currentBoard[1] >>> 16,\n      currentBoard[3] & Filter.LeastSixteenBits,\n      currentBoard[3] >>> 16,\n      currentBoard[4] & Filter.LeastSixteenBits,\n      currentBoard[4] >>> 16,\n      currentBoard[6] & Filter.LeastSixteenBits,\n      currentBoard[6] >>> 16,\n      currentBoard[7] & Filter.LeastSixteenBits,\n      currentBoard[7] >>> 16,\n      currentBoard[9] & Filter.LeastSixteenBits,\n      currentBoard[9] >>> 16,\n      currentBoard[10] & Filter.LeastSixteenBits,\n      currentBoard[10] >>> 16,\n      currentBoard[12] & Filter.LeastSixteenBits,\n      currentBoard[12] >>> 16,\n      currentBoard[13] & Filter.LeastSixteenBits,\n      currentBoard[13] >>> 16,\n      currentBoard[15] & Filter.LeastSixteenBits,\n      currentBoard[15] >>> 16,\n      currentBoard[16] & Filter.LeastSixteenBits,\n      currentBoard[16] >>> 16,\n      currentBoard[18] & Filter.LeastSixteenBits,\n      currentBoard[18] >>> 16,\n      currentBoard[19] & Filter.LeastSixteenBits,\n      currentBoard[19] >>> 16,\n      currentBoard[21] & Filter.LeastSixteenBits,\n      currentBoard[21] >>> 16,\n      currentBoard[22] & Filter.LeastSixteenBits,\n      currentBoard[22] >>> 16,\n\n      // Snipes\n      currentBoard[2] |\n        (currentBoard[5] << 2) |\n        (currentBoard[8] << 4) |\n        (currentBoard[11] << 6) |\n        (currentBoard[14] << 8) |\n        (currentBoard[17] << 10) |\n        (currentBoard[20] << 12) |\n        (currentBoard[23] << 14),\n\n      // Turn and animal step\n      (state.turn << 1) | (state.pendingAnimalStep & Filter.LeastBit)\n    );\n  }\n\n  function setState(newState: GameState): void {\n    state = newState;\n  }\n}\n","import { Option, option } from \"rusty-ts\";\nimport { getStateAnalyzer } from \"./stateAnalyzer\";\nimport { bitCount, Filter } from \"./bitwiseUtils\";\nimport { cardProperties } from \"./cardMaps\";\nimport { canRetreat, isRow, oneRowBackward, oneRowForward } from \"./gameUtil\";\nimport randInt from \"./randInt\";\nimport {\n  allRows,\n  AnimalStep,\n  AnimalType,\n  Atomic,\n  CardLocation,\n  Drop,\n  GameState,\n  legalRetreaterDrops,\n  Player,\n  PlyType,\n  Row,\n  SnipeStep,\n  MctsAnalysisSnapshot,\n} from \"./types\";\n\nexport const NODE_SIZE_IN_I32S = 22;\n\nconst ROOT_NODE_INDEX = 0;\nconst NO_WINNER = -1;\nconst STATE_SIZE_IN_I32S = 17;\nconst ALPHA_WINS = 0b11_1111_1110;\nconst BETA_WINS = 0b11_1111_1111;\nconst NO_MOVED_ANIMAL = 0b10_0000;\n\nconst EXPLORATION_CONSTANT = Math.sqrt(2);\n\nexport interface MctsAnalyzer {\n  performRollout(): void;\n\n  getRootPointer(): NodePointer;\n  getNodeSummary(pointer: NodePointer): NodeSummary;\n  getChildPointersFromBestToWorst(pointer: NodePointer): NodePointer[];\n\n  getSnapshot(): MctsAnalysisSnapshot;\n\n  getInternalData(): MctsAnalyzerInternalData;\n}\n\n/** This is a \"fake\" type. */\nexport interface NodePointer {\n  readonly nodePointerTag: unique symbol;\n}\n\nexport interface NodeSummary {\n  pointer: NodePointer;\n  atomic: Option<Atomic>;\n  value: number;\n  rollouts: number;\n}\n\nexport interface MctsAnalyzerInternalData {\n  heapBuffer: ArrayBuffer;\n  mallocIndex: number;\n}\n\nenum NodeOffsets {\n  SnipeSetsTurnNumberAndMovedAnimal = 16,\n  ParentIndex = 17,\n  Atomic = 18,\n  Value = 19,\n  Rollouts = 20,\n  ChildListStartIndex = 21,\n}\n\ntype QuicklyPerformableAtomic =\n  | QuicklyPerformableSnipeStep\n  | QuicklyPerformableDrop\n  | QuicklyPerformableAnimalStep;\n\nenum QuicklyPerformableAtomicType {\n  SnipeStep,\n  Drop,\n  AnimalStep,\n}\n\ninterface QuicklyPerformableSnipeStep extends SnipeStep {\n  qp_atomicType: QuicklyPerformableAtomicType.SnipeStep;\n  qp_activePlayer: Player;\n  qp_snipeLocation: Row;\n}\n\ninterface QuicklyPerformableDrop extends Drop {\n  qp_atomicType: QuicklyPerformableAtomicType.Drop;\n  qp_activePlayer: Player;\n}\n\ninterface QuicklyPerformableAnimalStep extends AnimalStep {\n  qp_atomicType: QuicklyPerformableAtomicType.AnimalStep;\n  qp_startIndex: number;\n  qp_activePlayer: Player;\n  qp_inactivePlayer: Player;\n  qp_doesStepActivateTriplet: boolean;\n}\n\nexport function getMctsAnalyzerIfStateIsNonTerminal(\n  rootState: GameState,\n  turnNumber: number,\n  heapSizeInI32s: number\n): Option<MctsAnalyzer> {\n  const stateAnalyzer = getStateAnalyzer(rootState);\n  if (stateAnalyzer.isGameOver()) {\n    return option.none();\n  } else {\n    return option.some(\n      getMctsAnalyzerForNonTerminalState(rootState, turnNumber, heapSizeInI32s)\n    );\n  }\n}\n\nfunction getMctsAnalyzerForNonTerminalState(\n  rootState: GameState,\n  turnNumber: number,\n  heapSizeInI32s: number\n): MctsAnalyzer {\n  const heap = new Int32Array(heapSizeInI32s);\n  let mallocIndex = 0;\n\n  writeRootState();\n\n  const internalData: MctsAnalyzerInternalData = {\n    heapBuffer: heap.buffer,\n    mallocIndex,\n  };\n  const uninitialized = getMctsAnalyzerFromInternalDataWithoutInitializing(\n    internalData\n  );\n\n  uninitialized.performRollout();\n  uninitialized.performRollout();\n\n  return uninitialized;\n\n  function writeRootState(): void {\n    if (mallocIndex !== 0) {\n      throw new Error(\"Cannot writeRootState() if heap is not empty.\");\n    }\n\n    const { currentBoard, pendingAnimalStep } = rootState;\n\n    heap[0] = currentBoard[0];\n    heap[1] = currentBoard[1];\n\n    heap[2] = currentBoard[3];\n    heap[3] = currentBoard[4];\n\n    heap[4] = currentBoard[6];\n    heap[5] = currentBoard[7];\n\n    heap[6] = currentBoard[9];\n    heap[7] = currentBoard[10];\n\n    heap[8] = currentBoard[12];\n    heap[9] = currentBoard[13];\n\n    heap[10] = currentBoard[15];\n    heap[11] = currentBoard[16];\n\n    heap[12] = currentBoard[18];\n    heap[13] = currentBoard[19];\n\n    heap[14] = currentBoard[21];\n    heap[15] = currentBoard[22];\n\n    heap[16] =\n      ((pendingAnimalStep === 0\n        ? NO_MOVED_ANIMAL\n        : (pendingAnimalStep >>> 3) & Filter.LeastFiveBits) <<\n        26) |\n      (turnNumber << 16) |\n      (currentBoard[23] << 14) |\n      (currentBoard[20] << 12) |\n      (currentBoard[17] << 10) |\n      (currentBoard[14] << 8) |\n      (currentBoard[11] << 6) |\n      (currentBoard[8] << 4) |\n      (currentBoard[5] << 2) |\n      currentBoard[2];\n\n    heap[NodeOffsets.ParentIndex] = -1;\n    heap[NodeOffsets.Atomic] = -1;\n    heap[NodeOffsets.Value] = 0;\n    heap[NodeOffsets.Rollouts] = 0;\n    heap[NodeOffsets.ChildListStartIndex] = -1;\n\n    mallocIndex = 22;\n  }\n}\n\nexport function getMctsAnalyzerFromInternalDataWithoutInitializing(\n  internalData: MctsAnalyzerInternalData\n): MctsAnalyzer {\n  const heap = new Int32Array(internalData.heapBuffer);\n  const tempState = new Int32Array(STATE_SIZE_IN_I32S);\n  let mallocIndex = internalData.mallocIndex;\n\n  return {\n    performRollout,\n\n    getRootPointer,\n    getNodeSummary,\n    getChildPointersFromBestToWorst,\n\n    getSnapshot,\n\n    getInternalData,\n  };\n\n  function performRollout(): void {\n    let nodeIndex = ROOT_NODE_INDEX;\n    while (!isLeaf(nodeIndex)) {\n      nodeIndex = selectBestChild(nodeIndex);\n    }\n    const leafIndex = nodeIndex;\n\n    if (getRollouts(leafIndex) === 0 && leafIndex !== ROOT_NODE_INDEX) {\n      rolloutIfNonTerminalThenBackPropagate(leafIndex);\n    } else {\n      const winner = getImmediateWinner(heap, leafIndex);\n      if (~winner) {\n        updateAndBackPropagateRollout(leafIndex, winner);\n        markAsEffectivelyTerminal(leafIndex, winner);\n      } else {\n        addChildrenAndRolloutFirstChild(leafIndex);\n      }\n    }\n  }\n\n  function isLeaf(nodeIndex: number): boolean {\n    const childListStartIndex =\n      heap[nodeIndex + NodeOffsets.ChildListStartIndex];\n    // If childListStartIndex is null (negative), then\n    // heap[childListStartIndex] will be undefined,\n    // and (undefined | 0) === 0.\n    return (heap[childListStartIndex] | 0) === 0;\n  }\n\n  function selectBestChild(nodeIndex: number): number {\n    const childListStartIndex =\n      heap[nodeIndex + NodeOffsets.ChildListStartIndex];\n    const childCount = heap[childListStartIndex];\n    const nodeRollouts = getRollouts(nodeIndex);\n    const turnNumberAndMovedAnimal =\n      heap[nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>> 16;\n    const activePlayer = turnNumberAndMovedAnimal & 0b1;\n    const inactivePlayer = ~turnNumberAndMovedAnimal & 0b1;\n\n    let bestIndex = getNthElementOfChildList(childListStartIndex, 0);\n    let bestScore = getUcbScore(bestIndex, nodeRollouts);\n\n    if (getEffectiveWinner(bestIndex) === activePlayer) {\n      return bestIndex;\n    }\n\n    if (getEffectiveWinner(bestIndex) === inactivePlayer) {\n      bestScore = -Infinity;\n    }\n\n    for (let i = 1; i < childCount; i++) {\n      const childIndex = getNthElementOfChildList(childListStartIndex, i);\n      const winner = getEffectiveWinner(childIndex);\n\n      if (winner === activePlayer) {\n        return childIndex;\n      }\n\n      if (winner === inactivePlayer) {\n        continue;\n      }\n\n      const childScore = getUcbScore(childIndex, nodeRollouts);\n\n      if (childScore > bestScore) {\n        bestIndex = childIndex;\n        bestScore = childScore;\n      }\n    }\n    return bestIndex;\n  }\n\n  function getRollouts(nodeIndex: number): number {\n    return heap[nodeIndex + NodeOffsets.Rollouts];\n  }\n\n  function getNthElementOfChildList(\n    childListStartIndex: number,\n    n: number\n  ): number {\n    return heap[childListStartIndex + 1 + n];\n  }\n\n  function rolloutIfNonTerminalThenBackPropagate(nodeIndex: number): void {\n    const winner = getImmediateWinner(heap, nodeIndex);\n\n    if (~winner) {\n      markAsEffectivelyTerminal(nodeIndex, winner);\n    }\n\n    const rolledOutWinner = ~winner ? winner : rollout(nodeIndex);\n    updateAndBackPropagateRollout(nodeIndex, rolledOutWinner);\n  }\n\n  function rollout(nodeIndex: number): Player {\n    copyNodeStateIntoTempState(nodeIndex);\n    let legalAtomics = getLegalAtomics(tempState);\n    while (legalAtomics.length > 0) {\n      const selected = legalAtomics[randInt(0, legalAtomics.length)];\n      performAtomic(selected, tempState);\n      legalAtomics = getLegalAtomics(tempState);\n    }\n\n    return getImmediateWinner(tempState, 0);\n  }\n\n  function copyNodeStateIntoTempState(nodeIndex: number): void {\n    tempState.set(heap.subarray(nodeIndex, nodeIndex + STATE_SIZE_IN_I32S));\n  }\n\n  function getLegalAtomics(out: Int32Array): QuicklyPerformableAtomic[] {\n    const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n\n    if ((etc & 0b10) | ((etc >>> 14) & 0b1)) {\n      return [];\n    }\n\n    const atomics: QuicklyPerformableAtomic[] = [];\n\n    const activePlayer: Player = (etc >>> 16) & 0b1;\n    const inactivePlayer: Player = activePlayer ^ 0b1;\n    const activePlayerLegalRetreaterDrops = legalRetreaterDrops[activePlayer];\n\n    // Only add full plies if there is no pending subply\n    if (getOptMovedAnimal(out) === NO_MOVED_ANIMAL) {\n      // Snipe steps\n      {\n        if (snipeCannotBeFound(etc, activePlayer)) {\n          console.log(\"etc\", etc);\n          debugger;\n        }\n\n        const activeSnipeLocation = getActiveSnipeLocation(etc, activePlayer);\n        if (isRow(activeSnipeLocation)) {\n          const enemySnipeSet =\n            (etc >>> (activeSnipeLocation << 1)) & (1 << inactivePlayer);\n          const animalSet =\n            out[(activeSnipeLocation << 1) | activePlayer] |\n            out[(activeSnipeLocation << 1) | inactivePlayer];\n          if (enemySnipeSet | animalSet) {\n            const forward = oneRowForward(activeSnipeLocation, activePlayer);\n            if (isRow(forward)) {\n              atomics.push({\n                plyType: PlyType.SnipeStep,\n                destination: forward,\n\n                qp_atomicType: QuicklyPerformableAtomicType.SnipeStep,\n                qp_activePlayer: activePlayer,\n                qp_snipeLocation: activeSnipeLocation,\n              });\n            }\n\n            const backward = oneRowBackward(activeSnipeLocation, activePlayer);\n            if (isRow(backward)) {\n              atomics.push({\n                plyType: PlyType.SnipeStep,\n                destination: backward,\n\n                qp_atomicType: QuicklyPerformableAtomicType.SnipeStep,\n                qp_activePlayer: activePlayer,\n                qp_snipeLocation: activeSnipeLocation,\n              });\n            }\n          }\n        }\n      }\n\n      // Drops\n      {\n        const reserveAnimalSet = getReserveAnimalSet(activePlayer, out);\n\n        if (bitCount(reserveAnimalSet) > 1) {\n          for (let animalType = 0; animalType <= 31; animalType++) {\n            if ((1 << animalType) & reserveAnimalSet) {\n              const destinations = canRetreat(animalType)\n                ? activePlayerLegalRetreaterDrops\n                : allRows;\n              const destinationsLen = destinations.length;\n              for (let i = 0; i < destinationsLen; i++) {\n                atomics.push({\n                  plyType: PlyType.Drop,\n                  dropped: animalType,\n                  destination: destinations[i],\n\n                  qp_atomicType: QuicklyPerformableAtomicType.Drop,\n                  qp_activePlayer: activePlayer,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Animal steps can be performed regardless of the previous action\n    for (let row: Row = 1; row <= 6; row++) {\n      const startIndex = (row << 1) | activePlayer;\n      const friendlyAnimalSet = out[startIndex];\n\n      if (friendlyAnimalSet === 0) {\n        continue;\n      }\n\n      const animalSet = friendlyAnimalSet | out[(row << 1) + inactivePlayer];\n      const snipes = (etc >>> (row << 1)) & Filter.LeastTwoBits;\n      const doesRowHaveAtLeastTwoCards = snipes || bitCount(animalSet) > 1;\n      const previouslyMovedAnimal = etc >>> 26;\n\n      const forward = oneRowForward(row, activePlayer);\n      const isForwardRow = forward !== 0 && forward !== 7;\n      const isForwardNotRow: 0 | 2 = (((!isForwardRow as unknown) as 0 | 1) <<\n        1) as 0 | 2;\n      const forwardSnipesAndExtraneousGreaterBits = etc >>> (forward << 1);\n      const isFriendlySnipeInForwardRow =\n        (forwardSnipesAndExtraneousGreaterBits & (1 << activePlayer)) >>>\n        isForwardNotRow;\n      const isEnemySnipeInForwardRow =\n        (forwardSnipesAndExtraneousGreaterBits & (1 << inactivePlayer)) >>>\n        isForwardNotRow;\n\n      const backward = oneRowBackward(row, activePlayer);\n      const isBackwardRow = backward !== 0 && backward !== 7;\n      const isBackwardNotRow: 0 | 2 = (((!isBackwardRow as unknown) as 0 | 1) <<\n        1) as 0 | 2;\n      const backwardSnipesAndExtraneousGreaterBits = etc >>> (backward << 1);\n      const isFriendlySnipeInBackwardRow =\n        (backwardSnipesAndExtraneousGreaterBits & (1 << activePlayer)) >>>\n        isBackwardNotRow;\n      const isEnemySnipeInBackwardRow =\n        (backwardSnipesAndExtraneousGreaterBits & (1 << inactivePlayer)) >>>\n        isBackwardNotRow;\n\n      for (let animalType = 0; animalType <= 31; animalType++) {\n        if (previouslyMovedAnimal === animalType) {\n          continue;\n        }\n\n        if ((1 << animalType) & friendlyAnimalSet) {\n          const doesForwardStepActivateTriplet = doesStepActivateTriplet(\n            forward,\n            animalType,\n            out\n          );\n          const canThisAnimalRetreat = canRetreat(animalType);\n          const canThisAnimalActivateTripletByRetreating =\n            canThisAnimalRetreat &&\n            doesStepActivateTriplet(backward, animalType, out);\n\n          if (doesRowHaveAtLeastTwoCards) {\n            if (\n              isForwardRow &&\n              !(\n                isFriendlySnipeInForwardRow &&\n                !isEnemySnipeInForwardRow &&\n                doesForwardStepActivateTriplet\n              )\n            ) {\n              atomics.push({\n                moved: animalType,\n                destination: forward as Row,\n\n                qp_atomicType: QuicklyPerformableAtomicType.AnimalStep,\n                qp_startIndex: startIndex,\n                qp_activePlayer: activePlayer,\n                qp_inactivePlayer: inactivePlayer,\n                qp_doesStepActivateTriplet: doesForwardStepActivateTriplet,\n              });\n            }\n\n            if (canThisAnimalRetreat) {\n              if (\n                isBackwardRow &&\n                !(\n                  isFriendlySnipeInBackwardRow &&\n                  !isEnemySnipeInBackwardRow &&\n                  canThisAnimalActivateTripletByRetreating\n                )\n              ) {\n                atomics.push({\n                  moved: animalType,\n                  destination: backward as Row,\n\n                  qp_atomicType: QuicklyPerformableAtomicType.AnimalStep,\n                  qp_startIndex: startIndex,\n                  qp_activePlayer: activePlayer,\n                  qp_inactivePlayer: inactivePlayer,\n                  qp_doesStepActivateTriplet: canThisAnimalActivateTripletByRetreating,\n                });\n              }\n            }\n          } else {\n            if (\n              isForwardRow &&\n              isEnemySnipeInForwardRow &&\n              doesForwardStepActivateTriplet\n            ) {\n              atomics.push({\n                moved: animalType,\n                destination: forward as Row,\n\n                qp_atomicType: QuicklyPerformableAtomicType.AnimalStep,\n                qp_startIndex: startIndex,\n                qp_activePlayer: activePlayer,\n                qp_inactivePlayer: inactivePlayer,\n                qp_doesStepActivateTriplet: doesForwardStepActivateTriplet,\n              });\n            }\n\n            if (\n              canThisAnimalActivateTripletByRetreating &&\n              isBackwardRow &&\n              isEnemySnipeInBackwardRow\n            ) {\n              atomics.push({\n                moved: animalType,\n                destination: backward as Row,\n\n                qp_atomicType: QuicklyPerformableAtomicType.AnimalStep,\n                qp_startIndex: startIndex,\n                qp_activePlayer: activePlayer,\n                qp_inactivePlayer: inactivePlayer,\n                qp_doesStepActivateTriplet: canThisAnimalActivateTripletByRetreating,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return atomics;\n  }\n\n  function getOptMovedAnimal(out: Int32Array): number {\n    return out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>> 26;\n  }\n\n  function getActiveSnipeLocation(\n    etc: number,\n    activePlayer: Player\n  ): CardLocation {\n    const activeSnipe = 1 << activePlayer;\n    for (let i = 0; i <= 14; i += 2) {\n      if ((etc >>> i) & activeSnipe) {\n        return i >>> 1;\n      }\n    }\n\n    throw new Error(\n      \"Impossible: \" + Player[activePlayer] + \" snipe cannot be found.\"\n    );\n  }\n\n  function snipeCannotBeFound(etc: number, activePlayer: Player): boolean {\n    const activeSnipe = 1 << activePlayer;\n    for (let i = 0; i <= 14; i += 2) {\n      if ((etc >>> i) & activeSnipe) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getReserveAnimalSet(player: Player, out: Int32Array): number {\n    return out[getReserveIndex(player)];\n  }\n\n  function getReserveIndex(player: Player): 0 | 15 {\n    if (player === Player.Alpha) {\n      return 0;\n    } else {\n      return 15;\n    }\n  }\n\n  function doesStepActivateTriplet(\n    destination: CardLocation,\n    newAnimal: AnimalType,\n    out: Int32Array\n  ): boolean {\n    const oldAnimals = out[destination << 1] | out[(destination << 1) + 1];\n\n    let rowElementCounts = cardProperties[newAnimal].elementCounts;\n\n    for (let animalType: AnimalType = 0; animalType <= 31; animalType++) {\n      if ((1 << animalType) & oldAnimals) {\n        rowElementCounts |= cardProperties[animalType].elementCounts;\n      }\n    }\n\n    const [shift1, shift2] = cardProperties[newAnimal].tripletShifts;\n    return (\n      ((rowElementCounts >>> shift1) & 0b111) === 0b111 ||\n      ((rowElementCounts >>> shift2) & 0b111) === 0b111\n    );\n  }\n\n  function performAtomic(\n    atomic: QuicklyPerformableAtomic,\n    out: Int32Array\n  ): void {\n    if (atomic.qp_atomicType === QuicklyPerformableAtomicType.SnipeStep) {\n      return performSnipeStep(atomic, out);\n    } else if (atomic.qp_atomicType === QuicklyPerformableAtomicType.Drop) {\n      return performDrop(atomic, out);\n    } else {\n      return performAnimalStep(atomic, out);\n    }\n  }\n\n  function performSnipeStep(\n    atomic: QuicklyPerformableSnipeStep,\n    out: Int32Array\n  ): void {\n    const debug_before = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n\n    const snipe = 1 << atomic.qp_activePlayer;\n    out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] &= ~(\n      snipe <<\n      (atomic.qp_snipeLocation << 1)\n    );\n    out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] |=\n      snipe << (atomic.destination << 1);\n\n    const debug_after = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n\n    if (\n      snipeCannotBeFound(debug_after, 0) ||\n      snipeCannotBeFound(debug_after, 1)\n    ) {\n      console.log(\n        \"before\",\n        debug_before,\n        \"after\",\n        debug_after,\n        \"was already broken\",\n        snipeCannotBeFound(debug_before, 0) ||\n          snipeCannotBeFound(debug_before, 1),\n        \"atomic\",\n        atomic\n      );\n    }\n\n    const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n    const turnNumber = (etc >>> 16) & Filter.LeastTenBits;\n    out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] =\n      (etc & 0b1111_1100_0000_0000_1111_1111_1111_1111) |\n      ((turnNumber + 1) << 16);\n  }\n\n  function performDrop(atomic: QuicklyPerformableDrop, out: Int32Array): void {\n    const reserveIndex = getReserveIndex(atomic.qp_activePlayer);\n    const droppedSet = 1 << atomic.dropped;\n\n    out[reserveIndex] &= ~droppedSet;\n    out[(atomic.destination << 1) + atomic.qp_activePlayer] |= droppedSet;\n\n    const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n    const turnNumber = (etc >>> 16) & Filter.LeastTenBits;\n    out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] =\n      (etc & 0b1111_1100_0000_0000_1111_1111_1111_1111) |\n      ((turnNumber + 1) << 16);\n  }\n\n  function performAnimalStep(\n    atomic: QuicklyPerformableAnimalStep,\n    out: Int32Array\n  ): void {\n    const startIndex = atomic.qp_startIndex;\n    const movedSet = 1 << atomic.moved;\n\n    out[startIndex] &= ~movedSet;\n\n    const destAlphaIndex = atomic.destination << 1;\n\n    if (atomic.qp_doesStepActivateTriplet) {\n      out[getReserveIndex(atomic.qp_activePlayer)] |=\n        out[destAlphaIndex] | out[destAlphaIndex | 0b1];\n      out[destAlphaIndex | atomic.qp_activePlayer] = movedSet;\n      out[destAlphaIndex | atomic.qp_inactivePlayer] = 0;\n\n      const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n      const capturedSnipesSet = (etc >>> destAlphaIndex) & Filter.LeastTwoBits;\n      out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] =\n        (etc & ~(0b11 << destAlphaIndex)) |\n        (capturedSnipesSet << (atomic.qp_activePlayer ? 14 : 0));\n    } else {\n      out[destAlphaIndex | atomic.qp_activePlayer] |= movedSet;\n    }\n\n    const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n    if (etc >>> 31) {\n      // If moved animal does not exist, set moved animal to atomic.moved.\n      out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] =\n        (etc & 0b0000_0011_1111_1111_1111_1111_1111_1111) |\n        (atomic.moved << 26);\n    } else {\n      // If moved animal exists, set moved animal to null and increment the turn number.\n      out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] =\n        (((etc & 0b0000_0011_1111_1111_1111_1111_1111_1111) |\n          0b1000_0000_0000_0000_0000_0000_0000_0000) &\n          0b1111_1100_0000_0000_1111_1111_1111_1111) |\n        ((((etc >>> 16) & Filter.LeastTenBits) + 1) << 16);\n    }\n  }\n\n  function getImmediateWinner(\n    state: Int32Array,\n    offset: number\n  ): Player | typeof NO_WINNER {\n    const etc = state[offset + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n    if (etc & 0b10) {\n      return Player.Alpha;\n    } else if ((etc >>> 14) & 0b01) {\n      return Player.Beta;\n    } else if (\n      !hasAtLeastOneLegalAtomic(\n        state.subarray(offset, offset + STATE_SIZE_IN_I32S)\n      )\n    ) {\n      return ~(etc >>> 16) & 0b1;\n    } else {\n      return NO_WINNER;\n    }\n  }\n\n  function getEffectiveWinner(nodeIndex: number): Player | typeof NO_WINNER {\n    const turnNumber =\n      (heap[nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>> 16) &\n      Filter.LeastTenBits;\n\n    if (turnNumber === ALPHA_WINS) {\n      return Player.Alpha;\n    } else if (turnNumber === BETA_WINS) {\n      return Player.Beta;\n    } else {\n      return NO_WINNER;\n    }\n  }\n\n  function hasAtLeastOneLegalAtomic(out: Int32Array): boolean {\n    const etc = out[NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal];\n\n    if ((etc & 0b10) | ((etc >>> 14) & 0b1)) {\n      return false;\n    }\n\n    const activePlayer: Player = (etc >>> 16) & 0b1;\n    const inactivePlayer: Player = activePlayer ^ 0b1;\n    const activePlayerLegalRetreaterDrops = legalRetreaterDrops[activePlayer];\n\n    // Only add full plies if there is no pending subply\n    if (getOptMovedAnimal(out) === NO_MOVED_ANIMAL) {\n      // Snipe steps\n      {\n        if (snipeCannotBeFound(etc, activePlayer)) {\n          console.log(\"etc\", etc);\n          debugger;\n        }\n\n        const activeSnipeLocation = getActiveSnipeLocation(etc, activePlayer);\n        if (isRow(activeSnipeLocation)) {\n          const enemySnipeSet =\n            (etc >>> (activeSnipeLocation << 1)) & (1 << inactivePlayer);\n          const animalSet =\n            out[(activeSnipeLocation << 1) | activePlayer] |\n            out[(activeSnipeLocation << 1) | inactivePlayer];\n          if (enemySnipeSet | animalSet) {\n            const forward = oneRowForward(activeSnipeLocation, activePlayer);\n            if (isRow(forward)) {\n              return true;\n            }\n\n            const backward = oneRowBackward(activeSnipeLocation, activePlayer);\n            if (isRow(backward)) {\n              return true;\n            }\n          }\n        }\n      }\n\n      // Drops\n      {\n        const reserveAnimalSet = getReserveAnimalSet(activePlayer, out);\n\n        if (bitCount(reserveAnimalSet) > 1) {\n          for (let animalType = 0; animalType <= 31; animalType++) {\n            if ((1 << animalType) & reserveAnimalSet) {\n              const destinations = canRetreat(animalType)\n                ? activePlayerLegalRetreaterDrops\n                : allRows;\n              const destinationsLen = destinations.length;\n              for (let i = 0; i < destinationsLen; i++) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Animal steps can be performed regardless of the previous action\n    for (let row: Row = 1; row <= 6; row++) {\n      const startIndex = (row << 1) | activePlayer;\n      const friendlyAnimalSet = out[startIndex];\n\n      if (friendlyAnimalSet === 0) {\n        continue;\n      }\n\n      const animalSet = friendlyAnimalSet | out[(row << 1) + inactivePlayer];\n      const snipes = (etc >>> (row << 1)) & Filter.LeastTwoBits;\n      const doesRowHaveAtLeastTwoCards = snipes || bitCount(animalSet) > 1;\n      const previouslyMovedAnimal = etc >>> 26;\n\n      const forward = oneRowForward(row, activePlayer);\n      const isForwardRow = forward !== 0 && forward !== 7;\n      const isForwardNotRow: 0 | 2 = (((!isForwardRow as unknown) as 0 | 1) <<\n        1) as 0 | 2;\n      const forwardSnipesAndExtraneousGreaterBits = etc >>> (forward << 1);\n      const isFriendlySnipeInForwardRow =\n        (forwardSnipesAndExtraneousGreaterBits & (1 << activePlayer)) >>>\n        isForwardNotRow;\n      const isEnemySnipeInForwardRow =\n        (forwardSnipesAndExtraneousGreaterBits & (1 << inactivePlayer)) >>>\n        isForwardNotRow;\n\n      const backward = oneRowBackward(row, activePlayer);\n      const isBackwardRow = backward !== 0 && backward !== 7;\n      const isBackwardNotRow: 0 | 2 = (((!isBackwardRow as unknown) as 0 | 1) <<\n        1) as 0 | 2;\n      const backwardSnipesAndExtraneousGreaterBits = etc >>> (backward << 1);\n      const isFriendlySnipeInBackwardRow =\n        (backwardSnipesAndExtraneousGreaterBits & (1 << activePlayer)) >>>\n        isBackwardNotRow;\n      const isEnemySnipeInBackwardRow =\n        (backwardSnipesAndExtraneousGreaterBits & (1 << inactivePlayer)) >>>\n        isBackwardNotRow;\n\n      for (let animalType = 0; animalType <= 31; animalType++) {\n        if (previouslyMovedAnimal === animalType) {\n          continue;\n        }\n\n        if ((1 << animalType) & friendlyAnimalSet) {\n          const doesForwardStepActivateTriplet = doesStepActivateTriplet(\n            forward,\n            animalType,\n            out\n          );\n          const canThisAnimalRetreat = canRetreat(animalType);\n          const canThisAnimalActivateTripletByRetreating =\n            canThisAnimalRetreat &&\n            doesStepActivateTriplet(backward, animalType, out);\n\n          if (doesRowHaveAtLeastTwoCards) {\n            if (\n              isForwardRow &&\n              !(\n                isFriendlySnipeInForwardRow &&\n                !isEnemySnipeInForwardRow &&\n                doesForwardStepActivateTriplet\n              )\n            ) {\n              return true;\n            }\n\n            if (canThisAnimalRetreat) {\n              if (\n                isBackwardRow &&\n                !(\n                  isFriendlySnipeInBackwardRow &&\n                  !isEnemySnipeInBackwardRow &&\n                  canThisAnimalActivateTripletByRetreating\n                )\n              ) {\n                return true;\n              }\n            }\n          } else {\n            if (\n              isForwardRow &&\n              isEnemySnipeInForwardRow &&\n              doesForwardStepActivateTriplet\n            ) {\n              return true;\n            }\n\n            if (\n              canThisAnimalActivateTripletByRetreating &&\n              isBackwardRow &&\n              isEnemySnipeInBackwardRow\n            ) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function addChildrenAndRolloutFirstChild(nodeIndex: number): void {\n    const childIndexes: number[] = [];\n\n    const atomics = getLegalAtomics(\n      heap.subarray(nodeIndex, nodeIndex + STATE_SIZE_IN_I32S)\n    );\n    const atomicsLen = atomics.length;\n    for (let i = 0; i < atomicsLen; i++) {\n      const atomic = atomics[i];\n\n      const childIndex = malloc(NODE_SIZE_IN_I32S);\n      childIndexes.push(childIndex);\n      createChildOf(nodeIndex, atomic, childIndex);\n    }\n\n    const childIndexesLen = childIndexes.length;\n    const childListStartIndex = malloc(1 + childIndexesLen);\n\n    heap[nodeIndex + NodeOffsets.ChildListStartIndex] = childListStartIndex;\n\n    heap[childListStartIndex] = childIndexesLen;\n\n    for (let i = 0; i < childIndexesLen; i++) {\n      heap[childListStartIndex + 1 + i] = childIndexes[i];\n    }\n\n    if (childIndexesLen) {\n      rolloutIfNonTerminalThenBackPropagate(childIndexes[0]);\n    }\n  }\n\n  function malloc(space: number): number {\n    if (mallocIndex > heap.length - space) {\n      throw new Error(\"Monte Carlo Tree heap has ran out of space.\");\n    }\n\n    const address = mallocIndex;\n    mallocIndex += space;\n    return address;\n  }\n\n  function createChildOf(\n    nodeIndex: number,\n    atomic: QuicklyPerformableAtomic,\n    destIndex: number\n  ): void {\n    heap.set(heap.subarray(nodeIndex, nodeIndex + 17), destIndex);\n\n    heap[destIndex + NodeOffsets.ParentIndex] = nodeIndex;\n    heap[destIndex + NodeOffsets.Atomic] = encodeAtomic(atomic);\n    heap[destIndex + NodeOffsets.Value] = 0;\n    heap[destIndex + NodeOffsets.Rollouts] = 0;\n    heap[destIndex + NodeOffsets.ChildListStartIndex] = -1;\n\n    performAtomic(\n      atomic,\n      heap.subarray(destIndex, destIndex + STATE_SIZE_IN_I32S)\n    );\n  }\n\n  function encodeAtomic(atomic: QuicklyPerformableAtomic): number {\n    if (atomic.qp_atomicType === QuicklyPerformableAtomicType.SnipeStep) {\n      return (atomic.destination << 3) | 0b001;\n    } else if (atomic.qp_atomicType === QuicklyPerformableAtomicType.Drop) {\n      return (atomic.destination << 8) | (atomic.dropped << 3) | 0b010;\n    } else {\n      return (atomic.destination << 8) | (atomic.moved << 3) | 0b011;\n    }\n  }\n\n  function decodeAtomic(encoded: number): Atomic {\n    const tag = encoded & Filter.LeastThreeBits;\n    if (tag === 0b001) {\n      return {\n        plyType: PlyType.SnipeStep,\n        destination: encoded >>> 3,\n      };\n    } else if (tag === 0b010) {\n      return {\n        plyType: PlyType.Drop,\n        dropped: (encoded >>> 3) & Filter.LeastFiveBits,\n        destination: encoded >>> 8,\n      };\n    } else {\n      return {\n        moved: (encoded >>> 3) & Filter.LeastFiveBits,\n        destination: encoded >>> 8,\n      };\n    }\n  }\n\n  function getUcbScore(nodeIndex: number, parentRollouts: number): number {\n    const nodeRollouts = getRollouts(nodeIndex);\n    if (nodeRollouts === 0) {\n      return Infinity;\n    }\n\n    const meanValue = getValue(nodeIndex) / nodeRollouts;\n    return (\n      meanValue +\n      EXPLORATION_CONSTANT * Math.sqrt(Math.log(parentRollouts) / nodeRollouts)\n    );\n  }\n\n  function getValue(nodeIndex: number): number {\n    return heap[nodeIndex + NodeOffsets.Value];\n  }\n\n  function updateAndBackPropagateRollout(\n    leafIndex: number,\n    winner: Player\n  ): void {\n    let nodeIndex = leafIndex;\n    let parentIndex = heap[nodeIndex + NodeOffsets.ParentIndex];\n\n    while (~parentIndex) {\n      heap[nodeIndex + NodeOffsets.Value] += ((winner ===\n        getActivePlayerOfNonTerminalState(parentIndex)) as unknown) as 1 | 0;\n      heap[nodeIndex + NodeOffsets.Rollouts] += 1;\n\n      nodeIndex = parentIndex;\n      parentIndex = heap[nodeIndex + NodeOffsets.ParentIndex];\n    }\n\n    heap[nodeIndex + NodeOffsets.Value] += ((winner ===\n      getActivePlayerOfNonTerminalState(nodeIndex)) as unknown) as 1 | 0;\n    heap[nodeIndex + NodeOffsets.Rollouts] += 1;\n  }\n\n  function getActivePlayerOfNonTerminalState(nodeIndex: number): Player {\n    return (\n      (heap[nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>> 16) &\n      0b1\n    );\n  }\n\n  function markAsEffectivelyTerminal(leafIndex: number, winner: Player): void {\n    const winnerBits = (0b11_1111_1110 | winner) << 16;\n\n    let nodeIndex = leafIndex;\n    let parentIndex = getParentIndex(nodeIndex);\n\n    while (\n      ~parentIndex &&\n      ((heap[parentIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>>\n        16) &\n        0b1) ===\n        winner\n    ) {\n      const etcIndex =\n        nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal;\n      const etc = heap[etcIndex];\n      heap[etcIndex] =\n        (etc & 0b1111_1100_0000_0000_1111_1111_1111_1111) | winnerBits;\n\n      nodeIndex = parentIndex;\n      parentIndex = getParentIndex(nodeIndex);\n    }\n\n    const etcIndex = nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal;\n    const etc = heap[etcIndex];\n    heap[etcIndex] =\n      (etc & 0b1111_1100_0000_0000_1111_1111_1111_1111) | winnerBits;\n  }\n\n  function getParentIndex(nodeIndex: number): number {\n    return heap[nodeIndex + NodeOffsets.ParentIndex];\n  }\n\n  function getRootPointer(): NodePointer {\n    return indexToPointer(ROOT_NODE_INDEX);\n  }\n\n  function getNodeSummary(pointer: NodePointer): NodeSummary {\n    const nodeIndex = pointerToIndex(pointer);\n    return {\n      pointer,\n      atomic:\n        heap[nodeIndex + NodeOffsets.ParentIndex] === -1\n          ? option.none()\n          : option.some(decodeAtomic(heap[nodeIndex + NodeOffsets.Atomic])),\n      value: heap[nodeIndex + NodeOffsets.Value],\n      rollouts: heap[nodeIndex + NodeOffsets.Rollouts],\n    };\n  }\n\n  function getChildPointersFromBestToWorst(\n    pointer: NodePointer\n  ): NodePointer[] {\n    const nodeIndex = pointerToIndex(pointer);\n\n    const turn =\n      (heap[nodeIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>> 16) &\n      Filter.LeastTenBits;\n    const optActivePlayer: Player | -1 =\n      turn === ALPHA_WINS || turn === BETA_WINS ? -1 : turn & 0b1;\n\n    const childListStartIndex =\n      heap[nodeIndex + NodeOffsets.ChildListStartIndex];\n    const childListLen = heap[childListStartIndex];\n    const indexesAndScores: { index: number; score: number }[] = [];\n\n    for (let i = 0; i < childListLen; i++) {\n      const childIndex = heap[childListStartIndex + 1 + i];\n\n      const optWinner = getEffectiveWinner(childIndex);\n      let score: number;\n\n      if (optWinner !== -1 && optActivePlayer !== -1) {\n        score = optWinner === optActivePlayer ? Infinity : -Infinity;\n      } else if (optWinner !== -1) {\n        const childTurn =\n          (heap[childIndex + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>>\n            16) &\n          Filter.LeastTenBits;\n        score = childTurn === turn ? Infinity : -Infinity;\n      } else {\n        const childRollouts = heap[childIndex + NodeOffsets.Rollouts];\n        score = childRollouts;\n      }\n\n      indexesAndScores.push({ index: childIndex, score });\n    }\n\n    return indexesAndScores\n      .sort((a, b) => b.score - a.score)\n      .map((scoreIndex) => indexToPointer(scoreIndex.index));\n  }\n\n  function getSnapshot(): MctsAnalysisSnapshot {\n    const root = getNodeSummary(getRootPointer());\n    const childWithBestAtomic = getSummaryOfChildWithBestAtomic();\n\n    return {\n      currentStateValue: root.value,\n      currentStateRollouts: root.rollouts,\n\n      bestAtomic: childWithBestAtomic.atomic.expect(\n        \"Impossible: Child node does not have atomic.\"\n      ),\n      bestAtomicValue: childWithBestAtomic.value,\n      bestAtomicRollouts: childWithBestAtomic.rollouts,\n    };\n  }\n\n  function getSummaryOfChildWithBestAtomic(): NodeSummary {\n    const bestChildIndex = getIndexOfChildWithBestAtomic();\n\n    return {\n      pointer: indexToPointer(bestChildIndex),\n      atomic: option.some(\n        decodeAtomic(heap[bestChildIndex + NodeOffsets.Atomic])\n      ),\n      value: heap[bestChildIndex + NodeOffsets.Value],\n      rollouts: heap[bestChildIndex + NodeOffsets.Rollouts],\n    };\n  }\n\n  function getIndexOfChildWithBestAtomic(): number {\n    const rootActivePlayer =\n      (heap[ROOT_NODE_INDEX + NodeOffsets.SnipeSetsTurnNumberAndMovedAnimal] >>>\n        16) &\n      0b1;\n    const rootInactivePlayer = ~rootActivePlayer & 0b1;\n\n    const rootChildListStartIndex =\n      heap[ROOT_NODE_INDEX + NodeOffsets.ChildListStartIndex];\n    const rootChildListLen = heap[rootChildListStartIndex];\n\n    let bestChildIndex = -1;\n    for (let i = 0; i < rootChildListLen; i++) {\n      const childIndex = heap[rootChildListStartIndex + 1 + i];\n\n      if (bestChildIndex === -1) {\n        bestChildIndex = childIndex;\n        continue;\n      }\n\n      const winner = getEffectiveWinner(childIndex);\n\n      if (winner === rootActivePlayer) {\n        return childIndex;\n      }\n\n      if (winner === rootInactivePlayer) {\n        continue;\n      }\n\n      if (\n        heap[childIndex + NodeOffsets.Rollouts] >\n          heap[bestChildIndex + NodeOffsets.Rollouts] ||\n        getEffectiveWinner(bestChildIndex) === rootInactivePlayer\n      ) {\n        bestChildIndex = childIndex;\n      }\n    }\n\n    if (bestChildIndex === -1) {\n      throw new Error(\"Impossible: Root node has no children.\");\n    }\n\n    return bestChildIndex;\n  }\n\n  function getInternalData(): MctsAnalyzerInternalData {\n    return { heapBuffer: heap.buffer, mallocIndex };\n  }\n}\n\nexport function pointerToIndex(pointer: NodePointer): number {\n  return (pointer as unknown) as number;\n}\n\nexport function indexToPointer(nodeIndex: number): NodePointer {\n  return (nodeIndex as unknown) as NodePointer;\n}\n","import React from \"react\";\nimport { cardEmojis } from \"../cardMaps\";\nimport { isAnimalStep } from \"../gameUtil\";\nimport { Atomic, CardType, PlyType } from \"../types\";\nimport \"./styles/InlineAtomic.css\";\n\ninterface Props {\n  atomic: Atomic;\n  plyNumber: number;\n  ellipsis: Ellipsis;\n}\n\nexport enum Ellipsis {\n  Before,\n  After,\n  None,\n}\n\nexport default function InlineAtomic({\n  atomic,\n  plyNumber,\n  ellipsis,\n}: Props): React.ReactElement {\n  const plyMakerEmoji =\n    plyNumber % 2 === 0\n      ? getEmoji(CardType.AlphaSnipe)\n      : getEmoji(CardType.BetaSnipe);\n\n  if (isAnimalStep(atomic)) {\n    switch (ellipsis) {\n      case Ellipsis.Before:\n        return (\n          <>\n            <div className=\"InlinePlyNumber\">{plyMakerEmoji + plyNumber}.</div>\n            {\" ...\"}\n            {getEmoji(atomic.moved)}\n            {atomic.destination}\n          </>\n        );\n      case Ellipsis.After:\n        return (\n          <>\n            <div className=\"InlinePlyNumber\">{plyMakerEmoji + plyNumber}.</div>{\" \"}\n            {getEmoji(atomic.moved)}\n            {atomic.destination}\n            {\", ...\"}\n          </>\n        );\n      case Ellipsis.None:\n        return (\n          <>\n            <div className=\"InlinePlyNumber\">{plyMakerEmoji + plyNumber}.</div>{\" \"}\n            {getEmoji(atomic.moved)}\n            {atomic.destination}\n          </>\n        );\n    }\n  } else {\n    switch (atomic.plyType) {\n      case PlyType.SnipeStep:\n        return (\n          <>\n            {\" \"}\n            <div className=\"InlinePlyNumber\">\n              {plyMakerEmoji + plyNumber}.\n            </div>{\" \"}\n            {plyMakerEmoji}\n            {atomic.destination}\n          </>\n        );\n      case PlyType.Drop:\n        return (\n          <>\n            <div className=\"InlinePlyNumber\">{plyMakerEmoji + plyNumber}.</div>\n            {\" !\"}\n            {getEmoji(atomic.dropped)}\n            {atomic.destination}\n          </>\n        );\n    }\n  }\n}\n\nfunction getEmoji(cardType: CardType): string {\n  return cardEmojis[cardType];\n}\n","import React from \"react\";\nimport \"./styles/NodeStats.css\";\n\ninterface Props {\n  value: number;\n  rollouts: number;\n}\n\nconst DIGITS_AFTER_DECIMAL = 3;\n\nexport default function NodeStats({\n  value,\n  rollouts,\n}: Props): React.ReactElement {\n  const meanValue = value / rollouts;\n  return (\n    <div className=\"NodeStats\">\n      [v̅ = {meanValue.toFixed(DIGITS_AFTER_DECIMAL)}, n = {rollouts}]\n    </div>\n  );\n}\n","import React from \"react\";\nimport { isAnimalStep } from \"../gameUtil\";\nimport {\n  MctsAnalyzer,\n  NodePointer,\n  NodeSummary,\n  pointerToIndex,\n} from \"../mcts\";\nimport { SuggestionDetailLevel } from \"../types\";\nimport InlineAtomic, { Ellipsis } from \"./InlineAtomic\";\nimport NodeStats from \"./NodeStats\";\n\ninterface Props {\n  analyzer: MctsAnalyzer;\n  suggestionDetailLevels: {\n    [pointer: number]: SuggestionDetailLevel | undefined;\n  };\n  plyNumber: number;\n  isTherePendingAnimalStep: boolean;\n  viewedNode: NodeSummary;\n  onDetailLevelChange(pointer: NodePointer, level: SuggestionDetailLevel): void;\n}\n\ninterface SuggestionDetailLevelMenuProps {\n  pointer: NodePointer;\n  detailLevel: SuggestionDetailLevel;\n  onChange(pointer: NodePointer, level: SuggestionDetailLevel): void;\n}\n\nexport default function AnalysisNode({\n  analyzer,\n  suggestionDetailLevels,\n  plyNumber,\n  isTherePendingAnimalStep,\n  viewedNode,\n  onDetailLevelChange,\n}: Props): React.ReactElement {\n  const optDetailLevel =\n    suggestionDetailLevels[pointerToIndex(viewedNode.pointer)];\n  const detailLevel: SuggestionDetailLevel =\n    optDetailLevel === undefined ? SuggestionDetailLevel.None : optDetailLevel;\n\n  const pointersToConsideredChildren: NodePointer[] = (() => {\n    const pointers = analyzer.getChildPointersFromBestToWorst(\n      viewedNode.pointer\n    );\n\n    switch (detailLevel) {\n      case SuggestionDetailLevel.None:\n        return [];\n\n      case SuggestionDetailLevel.BestAction:\n        return pointers.slice(0, 1);\n\n      case SuggestionDetailLevel.AllActions:\n        return pointers;\n    }\n  })();\n\n  return (\n    <div>\n      {viewedNode.atomic.match({\n        none: () => \"Current state:\",\n        some: (atomic) => (\n          <InlineAtomic\n            atomic={atomic}\n            plyNumber={plyNumber}\n            ellipsis={\n              isTherePendingAnimalStep ? Ellipsis.Before : Ellipsis.After\n            }\n          />\n        ),\n      })}{\" \"}\n      <NodeStats value={viewedNode.value} rollouts={viewedNode.rollouts} />{\" \"}\n      <SuggestionDetailLevelMenu\n        pointer={viewedNode.pointer}\n        detailLevel={detailLevel}\n        onChange={onDetailLevelChange}\n      />\n      <ol>\n        {pointersToConsideredChildren.map((childPointer, i) => {\n          const childSummary = analyzer.getNodeSummary(childPointer);\n          const {\n            plyNumberAfterPerformingChildAtomic,\n            isTherePendingAnimalStepAfterPerformingChildAtomic,\n          } = ((): {\n            plyNumberAfterPerformingChildAtomic: number;\n            isTherePendingAnimalStepAfterPerformingChildAtomic: boolean;\n          } => {\n            if (viewedNode.atomic.someSatisfies(isAnimalStep)) {\n              if (isTherePendingAnimalStep) {\n                return {\n                  plyNumberAfterPerformingChildAtomic: plyNumber + 1,\n                  isTherePendingAnimalStepAfterPerformingChildAtomic: false,\n                };\n              } else {\n                return {\n                  plyNumberAfterPerformingChildAtomic: plyNumber,\n                  isTherePendingAnimalStepAfterPerformingChildAtomic: true,\n                };\n              }\n            } else {\n              return {\n                plyNumberAfterPerformingChildAtomic: plyNumber + 1,\n                isTherePendingAnimalStepAfterPerformingChildAtomic: false,\n              };\n            }\n          })();\n\n          return (\n            <li key={i}>\n              <AnalysisNode\n                analyzer={analyzer}\n                suggestionDetailLevels={suggestionDetailLevels}\n                plyNumber={plyNumberAfterPerformingChildAtomic}\n                isTherePendingAnimalStep={\n                  isTherePendingAnimalStepAfterPerformingChildAtomic\n                }\n                viewedNode={childSummary}\n                onDetailLevelChange={onDetailLevelChange}\n              />\n            </li>\n          );\n        })}\n      </ol>\n    </div>\n  );\n}\n\nfunction SuggestionDetailLevelMenu({\n  pointer,\n  detailLevel,\n  onChange,\n}: SuggestionDetailLevelMenuProps): React.ReactElement {\n  function selectOnChange(event: React.ChangeEvent<HTMLSelectElement>): void {\n    const level = event.target.value as SuggestionDetailLevel;\n    onChange(pointer, level);\n  }\n\n  return (\n    <>\n      Display{\" \"}\n      <select value={detailLevel} onChange={selectOnChange}>\n        <option value={SuggestionDetailLevel.None}>no actions</option>\n        <option value={SuggestionDetailLevel.BestAction}>best action</option>\n        <option value={SuggestionDetailLevel.AllActions}>all actions</option>\n      </select>\n    </>\n  );\n}\n","import React from \"react\";\nimport { Option } from \"rusty-ts\";\nimport { cardEmojis } from \"../cardMaps\";\nimport * as gameUtil from \"../gameUtil\";\nimport { AnimalStep, CardType, Player } from \"../types\";\nimport \"./styles/AnimalStepView.css\";\n\ninterface Props {\n  step: AnimalStep;\n  plyNumber: number;\n  winner: Option<Player>;\n}\n\nexport default function AnimalStepView({\n  step,\n  plyNumber,\n  winner: optWinner,\n}: Props): React.ReactElement {\n  const plyMakerEmoji =\n    plyNumber % 2 === 0\n      ? getEmoji(CardType.AlphaSnipe)\n      : getEmoji(CardType.BetaSnipe);\n  return (\n    <li>\n      <div className=\"PlyNumber\">{plyMakerEmoji + plyNumber}.</div>{\" \"}\n      {getEmoji(step.moved)}\n      {step.destination}\n      {optWinner.match({\n        some: (winner) => {\n          const winnerEmoji = cardEmojis[gameUtil.snipeOf(winner)];\n          const loserEmoji =\n            cardEmojis[gameUtil.snipeOf(gameUtil.opponentOf(winner))];\n          return \", \" + winnerEmoji + \">\" + loserEmoji;\n        },\n\n        none: () => \", ...\",\n      })}\n    </li>\n  );\n}\n\nfunction getEmoji(cardType: CardType): string {\n  return cardEmojis[cardType];\n}\n","import React from \"react\";\nimport { cardEmojis } from \"../cardMaps\";\nimport * as gameUtil from \"../gameUtil\";\nimport { Card, Player } from \"../types\";\nimport \"./styles/CardView.css\";\n\ninterface Props {\n  card: Card;\n  isSelected: boolean;\n  onCardClicked(card: Card): void;\n}\n\nexport default function CardView({\n  card,\n  isSelected,\n  onCardClicked,\n}: Props): React.ReactElement {\n  return (\n    <div\n      className={\n        \"CardView\" +\n        (card.allegiance === Player.Alpha\n          ? \" CardView--alpha\"\n          : \" CardView--beta\") +\n        (isSelected ? \" CardView--selected\" : \"\") +\n        (gameUtil.canRetreat(card.cardType) ? \" CardView--canMoveBackward\" : \"\")\n      }\n      onClick={() => onCardClicked(card)}\n    >\n      {cardEmojis[card.cardType]}\n    </div>\n  );\n}\n","import React from \"react\";\nimport { Option } from \"rusty-ts\";\nimport { cardProperties } from \"../cardMaps\";\nimport { Card, CardType, Element, GameStateAnalyzer } from \"../types\";\nimport CardView from \"./CardView\";\nimport \"./styles/ElementMatrix.css\";\n\ninterface Props {\n  analyzer: GameStateAnalyzer;\n  cards: Card[];\n  selectedCard: Option<CardType>;\n  onCardClicked(card: Card): void;\n}\n\nexport default function ElementMatrix({\n  analyzer,\n  cards,\n  selectedCard,\n  onCardClicked,\n}: Props): React.ReactElement {\n  interface ElementMatrixCellProps {\n    amount: 1 | 2 | 3;\n    element: Element;\n  }\n\n  return (\n    <table className=\"ElementMatrix\">\n      <tbody>\n        <tr>\n          <ElementMatrixCell amount={1} element={Element.Fire} />\n          <ElementMatrixCell amount={1} element={Element.Water} />\n          <ElementMatrixCell amount={1} element={Element.Earth} />\n          <ElementMatrixCell amount={1} element={Element.Air} />\n        </tr>\n        <tr>\n          <ElementMatrixCell amount={2} element={Element.Fire} />\n          <ElementMatrixCell amount={2} element={Element.Water} />\n          <ElementMatrixCell amount={2} element={Element.Earth} />\n          <ElementMatrixCell amount={2} element={Element.Air} />\n        </tr>\n        <tr>\n          <ElementMatrixCell amount={3} element={Element.Fire} />\n          <ElementMatrixCell amount={3} element={Element.Water} />\n          <ElementMatrixCell amount={3} element={Element.Earth} />\n          <ElementMatrixCell amount={3} element={Element.Air} />\n        </tr>\n      </tbody>\n    </table>\n  );\n\n  function ElementMatrixCell({\n    amount,\n    element,\n  }: ElementMatrixCellProps): React.ReactElement {\n    const cardsWithElements = getCardsWithElements(cards, amount, element);\n    return (\n      <td\n        className={\n          \"ElementMatrixCell\" +\n          (cardsWithElements.length === 0 ? \" ElementMatrixCell--empty\" : \"\")\n        }\n      >\n        {cardsWithElements.map(renderCard)}\n      </td>\n    );\n  }\n\n  function renderCard(card: Card): React.ReactElement {\n    const isSelected = selectedCard.unwrapOr(null) === card.cardType;\n\n    return (\n      <CardView\n        key={card.cardType}\n        card={card}\n        isSelected={isSelected}\n        onCardClicked={onCardClicked}\n      />\n    );\n  }\n}\n\nfunction getCardsWithElements(\n  cards: Card[],\n  amount: number,\n  element: Element\n): Card[] {\n  return cards.filter(\n    (card) => countElement(card.cardType, element) === amount\n  );\n}\n\nfunction countElement(cardType: CardType, element: Element): number {\n  const { elements } = cardProperties[cardType];\n  return elements.match({\n    none: () => 0,\n    some: ({ double, single }) => {\n      if (double === single) {\n        if (double === element) {\n          return 3;\n        } else {\n          return 0;\n        }\n      }\n\n      if (double === element) {\n        return 2;\n      }\n\n      if (single === element) {\n        return 1;\n      }\n\n      return 0;\n    },\n  });\n}\n","import React from \"react\";\nimport { cardEmojis } from \"../cardMaps\";\nimport { AnimalStep, CardType } from \"../types\";\nimport \"./styles/AnimalStepView.css\";\n\ninterface Props {\n  step: AnimalStep;\n  plyNumber: number;\n}\n\nexport default function FutureAnimalStepView({\n  step,\n  plyNumber,\n}: Props): React.ReactElement {\n  const plyMakerEmoji =\n    plyNumber % 2 === 0\n      ? getEmoji(CardType.AlphaSnipe)\n      : getEmoji(CardType.BetaSnipe);\n  return (\n    <li>\n      <div className=\"PlyNumber\">{plyMakerEmoji + plyNumber}.</div>\n      {\" ...\"}\n      {getEmoji(step.moved)}\n      {step.destination}\n    </li>\n  );\n}\n\nfunction getEmoji(cardType: CardType): string {\n  return cardEmojis[cardType];\n}\n","import React from \"react\";\nimport { cardEmojis } from \"../cardMaps\";\nimport { CardType, Ply, PlyType } from \"../types\";\nimport \"./styles/PlyView.css\";\n\ninterface Props {\n  ply: Ply;\n  plyNumber: number;\n}\n\nexport default function PlyView({ ply, plyNumber }: Props): React.ReactElement {\n  const plyMakerEmoji =\n    plyNumber % 2 === 0\n      ? getEmoji(CardType.AlphaSnipe)\n      : getEmoji(CardType.BetaSnipe);\n  switch (ply.plyType) {\n    case PlyType.SnipeStep:\n      return (\n        <li>\n          <div className=\"PlyNumber\">{plyMakerEmoji + plyNumber}.</div>{\" \"}\n          {plyMakerEmoji}\n          {ply.destination}\n        </li>\n      );\n    case PlyType.Drop:\n      return (\n        <li>\n          <div className=\"PlyNumber\">{plyMakerEmoji + plyNumber}.</div>\n          {\" !\"}\n          {getEmoji(ply.dropped)}\n          {ply.destination}\n        </li>\n      );\n    case PlyType.TwoAnimalSteps:\n      return (\n        <li>\n          <div className=\"PlyNumber\">{plyMakerEmoji + plyNumber}.</div>{\" \"}\n          {getEmoji(ply.first.moved)}\n          {ply.first.destination}\n          {\", \"}\n          {getEmoji(ply.second.moved)}\n          {ply.second.destination}\n        </li>\n      );\n  }\n}\n\nfunction getEmoji(cardType: CardType): string {\n  return cardEmojis[cardType];\n}\n","import { option, Option } from \"rusty-ts\";\nimport { getStateAnalyzer } from \"./stateAnalyzer\";\nimport { gameStateFactory } from \"./gameStateFactory\";\nimport {\n  FutureSubPlyStack,\n  GameState,\n  StateSaver,\n  STATE_VERSION,\n} from \"./types\";\n\nenum LocalStorageKeys {\n  GameState = \"GameState\",\n  FutureSubPlyStack = \"FutureSubPlyStack\",\n  ThinkingTimeInMilliseconds = \"ThinkingTimeInMilliseconds\",\n}\n\nexport const gameStateSaver: StateSaver<GameState> = {\n  getState(): Option<GameState> {\n    const stateStr = localStorage.getItem(LocalStorageKeys.GameState);\n    if (stateStr === null) {\n      return option.none();\n    } else {\n      return gameStateFactory.fromString(stateStr);\n    }\n  },\n\n  setState(state: GameState): void {\n    const stateStr = getStateAnalyzer(state).serialize();\n    localStorage.setItem(LocalStorageKeys.GameState, stateStr);\n  },\n};\n\nexport const futureSubPlyStackSaver: StateSaver<FutureSubPlyStack> = {\n  getState(): Option<FutureSubPlyStack> {\n    const stateStr = localStorage.getItem(LocalStorageKeys.FutureSubPlyStack);\n    if (stateStr === null) {\n      return option.none();\n    } else {\n      const parsed = JSON.parse(stateStr);\n\n      if (parsed.stateVersion !== STATE_VERSION) {\n        return option.none();\n      }\n\n      parsed.pendingAnimalStep = option.fromVoidable(parsed.pendingAnimalStep);\n      return option.some(parsed);\n    }\n  },\n\n  setState(state: FutureSubPlyStack): void {\n    const jsonified = {\n      stateVersion: state.stateVersion,\n      atomics: state.atomics,\n    };\n    const stateStr = JSON.stringify(jsonified);\n    localStorage.setItem(LocalStorageKeys.FutureSubPlyStack, stateStr);\n  },\n};\n\nexport const thinkingTimeSaver: StateSaver<Option<number>> = {\n  getState(): Option<Option<number>> {\n    const stateStr = localStorage.getItem(\n      LocalStorageKeys.ThinkingTimeInMilliseconds\n    );\n    if (stateStr === null) {\n      return option.none();\n    } else {\n      const parsed: number | null = JSON.parse(stateStr);\n      const optThinkingTimeInMS = option.fromVoidable(parsed);\n      return option.some(optThinkingTimeInMS);\n    }\n  },\n\n  setState(state: Option<number>): void {\n    const jsonified = JSON.stringify(state.unwrapOr(null));\n    localStorage.setItem(\n      LocalStorageKeys.ThinkingTimeInMilliseconds,\n      jsonified\n    );\n  },\n};\n","// eslint-disable-next-line import/no-webpack-loader-syntax\nimport MctsWorker from \"worker-loader!./mcts\";\n\nexport default MctsWorker;\n","import { option, Option } from \"rusty-ts\";\nimport {\n  getMctsAnalyzerFromInternalDataWithoutInitializing,\n  MctsAnalyzer,\n} from \"./mcts\";\nimport {\n  GameState,\n  LogNotification,\n  MctsService,\n  MctsWorkerMessageType,\n  MctsWorkerNotification,\n  PauseAnalyzerRequest,\n  PauseAnalyzerResponse,\n  ResumeAnalyzerRequest,\n  UpdateGameStateRequest,\n  UpdateSnapshotNotification,\n  StopTimeChangeNotification,\n} from \"./types\";\nimport MctsWorker from \"./workers/mcts.importable\";\n\ntype SnapshotListener = Parameters<MctsService[\"onSnapshot\"]>[0];\ntype PauseListener = Parameters<MctsService[\"onPause\"]>[0];\ntype StopTimeChangeListener = Parameters<MctsService[\"onStopTimeChange\"]>[0];\n\nexport function getMctsService(): MctsService {\n  const worker = new MctsWorker();\n\n  const snapshotListeners: SnapshotListener[] = [];\n  const pauseListeners: PauseListener[] = [];\n  const stopTimeChangeListeners: StopTimeChangeListener[] = [];\n\n  addWorkerListener();\n\n  return {\n    updateGameState,\n    pause,\n    resume,\n\n    onSnapshot,\n    onPause,\n    onStopTimeChange,\n  };\n\n  function addWorkerListener(): void {\n    worker.addEventListener(\"message\", onWorkerMessage);\n  }\n\n  function onWorkerMessage(event: MessageEvent): void {\n    const { data } = event;\n    if (data !== null && \"object\" === typeof data) {\n      const message: MctsWorkerNotification = data;\n      switch (message.messageType) {\n        case MctsWorkerMessageType.LogNotification:\n          onWorkerLogNotification(message);\n          break;\n        case MctsWorkerMessageType.UpdateSnapshotNotification:\n          onUpdateSnapshotNotification(message);\n          break;\n        case MctsWorkerMessageType.PauseAnalyzerResponse:\n          onTransferAnalyzerResponse(message);\n          break;\n        case MctsWorkerMessageType.StopTimeChangeNotification:\n          onStopTimeChangeNotification(message);\n          break;\n        default: {\n          // Force exhaustive matching\n\n          // eslint-disable-next-line\n          const unreachable: never = message;\n        }\n      }\n    }\n  }\n\n  function onWorkerLogNotification(message: LogNotification): void {\n    console.log(\"MCTS Worker Log:\", message.data);\n  }\n\n  function onUpdateSnapshotNotification(\n    message: UpdateSnapshotNotification\n  ): void {\n    const optSnapshot = option.fromVoidable(message.optSnapshot);\n    for (const listener of snapshotListeners) {\n      listener(optSnapshot);\n    }\n  }\n\n  function onTransferAnalyzerResponse(message: PauseAnalyzerResponse): void {\n    const mctsAnalyzer = getMctsAnalyzerFromInternalDataWithoutInitializing(\n      message.internalData\n    );\n    for (const listener of pauseListeners) {\n      listener(mctsAnalyzer);\n    }\n  }\n\n  function onStopTimeChangeNotification(\n    message: StopTimeChangeNotification\n  ): void {\n    const optStopTime = option.fromVoidable(message.optStopTime);\n    for (const listener of stopTimeChangeListeners) {\n      listener(optStopTime);\n    }\n  }\n\n  function updateGameState(\n    state: GameState,\n    optThinkingTime: Option<number>\n  ): void {\n    const thinkingTime = optThinkingTime.unwrapOr(Infinity);\n    const message: UpdateGameStateRequest = {\n      messageType: MctsWorkerMessageType.UpdateGameStateRequest,\n      gameState: state,\n      thinkingTimeInMS: thinkingTime,\n    };\n    worker.postMessage(message);\n  }\n\n  function pause(): void {\n    const message: PauseAnalyzerRequest = {\n      messageType: MctsWorkerMessageType.PauseAnalyzerRequest,\n    };\n    worker.postMessage(message);\n  }\n\n  function resume(analyzer: MctsAnalyzer): void {\n    const internalData = analyzer.getInternalData();\n    const message: ResumeAnalyzerRequest = {\n      messageType: MctsWorkerMessageType.ResumeAnalyzerRequest,\n      internalData,\n    };\n    worker.postMessage(message, [internalData.heapBuffer]);\n  }\n\n  function onSnapshot(listener: SnapshotListener): void {\n    snapshotListeners.push(listener);\n  }\n\n  function onPause(listener: PauseListener): void {\n    pauseListeners.push(listener);\n  }\n\n  function onStopTimeChange(listener: StopTimeChangeListener): void {\n    stopTimeChangeListeners.push(listener);\n  }\n}\n","import React from \"react\";\nimport { option, Option, Result } from \"rusty-ts\";\nimport \"./App.css\";\nimport { cardEmojis } from \"./cardMaps\";\nimport AnalysisNode from \"./components/AnalysisNode\";\nimport AnimalStepView from \"./components/AnimalStepView\";\nimport CardView from \"./components/CardView\";\nimport ElementMatrix from \"./components/ElementMatrix\";\nimport FutureAnimalStepView from \"./components/FutureAnimalStepView\";\nimport PlyView from \"./components/PlyView\";\nimport * as gameUtil from \"./gameUtil\";\nimport { MctsAnalyzer, NodePointer, pointerToIndex } from \"./mcts\";\nimport { getMctsService } from \"./mctsService\";\nimport { getStateAnalyzer } from \"./stateAnalyzer\";\nimport {\n  futureSubPlyStackSaver,\n  gameStateSaver,\n  thinkingTimeSaver,\n} from \"./stateSavers\";\nimport {\n  AnimalStep,\n  AnimalType,\n  AppState,\n  Atomic,\n  Card,\n  CardLocation,\n  CardType,\n  Drop,\n  FutureSubPlyStack,\n  GameState,\n  IllegalGameStateUpdate,\n  MctsAnalysisSnapshot,\n  MctsPausedState,\n  MctsService,\n  Player,\n  Ply,\n  PlyType,\n  Row,\n  SnipeStep,\n  STATE_VERSION,\n  SuggestionDetailLevel,\n} from \"./types\";\n\nconst DEFAULT_THINKING_TIME_IN_MS = 90 * 1e3;\n\nexport default class App extends React.Component<{}, AppState> {\n  private mctsService: MctsService;\n\n  constructor(props: {}) {\n    super(props);\n\n    this.state = loadState();\n\n    this.bindMethods();\n\n    (window as any).app = this;\n\n    this.mctsService = getMctsService();\n  }\n\n  componentDidMount(): void {\n    this.mctsService.updateGameState(\n      this.state.gameState,\n      this.state.thinkingTimeInMS\n    );\n\n    this.mctsService.onSnapshot(this.onMctsServiceSnapshot);\n    this.mctsService.onPause(this.onMctsServicePause);\n    this.mctsService.onStopTimeChange(this.onMctsServiceOnStopTimeChange);\n  }\n\n  bindMethods(): void {\n    this.onCardClicked = this.onCardClicked.bind(this);\n    this.onResetGameClicked = this.onResetGameClicked.bind(this);\n    this.onUndoSubPlyClicked = this.onUndoSubPlyClicked.bind(this);\n    this.onRedoSubPlyClicked = this.onRedoSubPlyClicked.bind(this);\n    this.isBestAtomicLegal = this.isBestAtomicLegal.bind(this);\n    this.onMctsServiceSnapshot = this.onMctsServiceSnapshot.bind(this);\n    this.onMctsServicePause = this.onMctsServicePause.bind(this);\n    this.onPauseAnalyzerClicked = this.onPauseAnalyzerClicked.bind(this);\n    this.onResumeAnalyzerClicked = this.onResumeAnalyzerClicked.bind(this);\n    this.onDetailLevelChange = this.onDetailLevelChange.bind(this);\n    this.onTimeLimitEnabledChange = this.onTimeLimitEnabledChange.bind(this);\n    this.onThinkingTimeInputChange = this.onThinkingTimeInputChange.bind(this);\n    this.onMctsServiceOnStopTimeChange = this.onMctsServiceOnStopTimeChange.bind(\n      this\n    );\n  }\n\n  saveAndUpdateGameState(newGameState: GameState) {\n    gameStateSaver.setState(newGameState);\n    this.setState({\n      gameState: newGameState,\n    });\n\n    this.mctsService.updateGameState(newGameState, this.state.thinkingTimeInMS);\n  }\n\n  render(): React.ReactElement {\n    return this.renderMatrixView();\n  }\n\n  renderMatrixView(): React.ReactElement {\n    const stateAnalyzer = getStateAnalyzer(this.state.gameState);\n    const initialBoard = getStateAnalyzer(\n      stateAnalyzer.getInitialState()\n    ).getBoard();\n    const currentBoard = stateAnalyzer.getBoard();\n    const plies = stateAnalyzer.getPlies();\n    const { mctsState } = this.state;\n\n    const { selectedCardType: selectedCard } = this.state.ux;\n\n    return (\n      <div\n        className={\n          \"SnipeHunt\" +\n          this.state.thinkingTimeInMS.match({\n            none: () => \"\",\n            some: () => \" SnipeHunt--timed\",\n          })\n        }\n      >\n        {this.state.thinkingTimeInMS.match({\n          none: () => null,\n\n          some: () => (\n            <div className=\"SnipeHunt__TopTimer\">\n              <label>\n                Seconds remaining for this turn:{\" \"}\n                <span>\n                  {this.state.stopTime.match({\n                    none: () => \"Loading...\",\n                    some: (stopTime) => {\n                      const diff = stopTime - Date.now();\n                      const diffInSeconds = Math.ceil(diff * 1e-3);\n                      const clamped = Math.max(0, diffInSeconds);\n                      return (\n                        \"\" + clamped + \"/\" + this.state.thinkingTimeInputValue\n                      );\n                    },\n                  })}\n                </span>\n              </label>\n            </div>\n          ),\n        })}\n\n        <div className=\"SnipeHunt__Main\">\n          {stateAnalyzer.getWinner().match({\n            none: () => <div>Turn: {Player[stateAnalyzer.getTurn()]}</div>,\n            some: (winner) => <div>Winner: {Player[winner]}</div>,\n          })}\n\n          <div>\n            <table className=\"Board\">\n              <tbody>\n                <tr>\n                  <td className=\"BoardCell\">\n                    Reserve\n                    {this.renderSnipesIn(\n                      currentBoard[CardLocation.AlphaReserve]\n                    )}\n                  </td>\n                  <td className=\"BoardCell\">\n                    <ElementMatrix\n                      analyzer={stateAnalyzer}\n                      cards={currentBoard[CardLocation.AlphaReserve]}\n                      selectedCard={selectedCard}\n                      onCardClicked={this.onCardClicked}\n                    />\n                  </td>\n                </tr>\n                <tr>\n                  <td\n                    className=\"BoardCell\"\n                    onClick={(e) => {\n                      if (\n                        e.target instanceof HTMLTableCellElement &&\n                        e.target.classList.contains(\"BoardCell\")\n                      ) {\n                        this.onRowNumberClicked(1);\n                      }\n                    }}\n                  >\n                    1{this.renderSnipesIn(currentBoard[CardLocation.Row1])}\n                  </td>\n                  <td className=\"BoardCell\">\n                    <ElementMatrix\n                      analyzer={stateAnalyzer}\n                      cards={currentBoard[CardLocation.Row1]}\n                      selectedCard={selectedCard}\n                      onCardClicked={this.onCardClicked}\n                    />\n                  </td>\n                </tr>\n                <tr>\n                  <td\n                    className=\"BoardCell\"\n                    onClick={(e) => {\n                      if (\n                        e.target instanceof HTMLTableCellElement &&\n                        e.target.classList.contains(\"BoardCell\")\n                      ) {\n                        this.onRowNumberClicked(2);\n                      }\n                    }}\n                  >\n                    2{this.renderSnipesIn(currentBoard[CardLocation.Row2])}\n                  </td>\n                  <td className=\"BoardCell\">\n                    <ElementMatrix\n                      analyzer={stateAnalyzer}\n                      cards={currentBoard[CardLocation.Row2]}\n                      selectedCard={selectedCard}\n                      onCardClicked={this.onCardClicked}\n                    />\n                  </td>\n                </tr>\n                <tr>\n                  <td\n                    className=\"BoardCell\"\n                    onClick={(e) => {\n                      if (\n                        e.target instanceof HTMLTableCellElement &&\n                        e.target.classList.contains(\"BoardCell\")\n                      ) {\n                        this.onRowNumberClicked(3);\n                      }\n                    }}\n                  >\n                    3{this.renderSnipesIn(currentBoard[CardLocation.Row3])}\n                  </td>\n                  <td className=\"BoardCell\">\n                    <ElementMatrix\n                      analyzer={stateAnalyzer}\n                      cards={currentBoard[CardLocation.Row3]}\n                      selectedCard={selectedCard}\n                      onCardClicked={this.onCardClicked}\n                    />\n                  </td>\n                </tr>\n                <tr>\n                  <td\n                    className=\"BoardCell\"\n                    onClick={(e) => {\n                      if (\n                        e.target instanceof HTMLTableCellElement &&\n                        e.target.classList.contains(\"BoardCell\")\n                      ) {\n                        this.onRowNumberClicked(4);\n                      }\n                    }}\n                  >\n                    4{this.renderSnipesIn(currentBoard[CardLocation.Row4])}\n                  </td>\n                  <td className=\"BoardCell\">\n                    <ElementMatrix\n                      analyzer={stateAnalyzer}\n                      cards={currentBoard[CardLocation.Row4]}\n                      selectedCard={selectedCard}\n                      onCardClicked={this.onCardClicked}\n                    />\n                  </td>\n                </tr>\n                <tr>\n                  <td\n                    className=\"BoardCell\"\n                    onClick={(e) => {\n                      if (\n                        e.target instanceof HTMLTableCellElement &&\n                        e.target.classList.contains(\"BoardCell\")\n                      ) {\n                        this.onRowNumberClicked(5);\n                      }\n                    }}\n                  >\n                    5{this.renderSnipesIn(currentBoard[CardLocation.Row5])}\n                  </td>\n                  <td className=\"BoardCell\">\n                    <ElementMatrix\n                      analyzer={stateAnalyzer}\n                      cards={currentBoard[CardLocation.Row5]}\n                      selectedCard={selectedCard}\n                      onCardClicked={this.onCardClicked}\n                    />\n                  </td>\n                </tr>\n                <tr>\n                  <td\n                    className=\"BoardCell\"\n                    onClick={(e) => {\n                      if (\n                        e.target instanceof HTMLTableCellElement &&\n                        e.target.classList.contains(\"BoardCell\")\n                      ) {\n                        this.onRowNumberClicked(6);\n                      }\n                    }}\n                  >\n                    6{this.renderSnipesIn(currentBoard[CardLocation.Row6])}\n                  </td>\n                  <td className=\"BoardCell\">\n                    <ElementMatrix\n                      analyzer={stateAnalyzer}\n                      cards={currentBoard[CardLocation.Row6]}\n                      selectedCard={selectedCard}\n                      onCardClicked={this.onCardClicked}\n                    />\n                  </td>\n                </tr>\n                <tr>\n                  <td className=\"BoardCell\">\n                    Reserve\n                    {this.renderSnipesIn(\n                      currentBoard[CardLocation.BetaReserve]\n                    )}\n                  </td>\n                  <td className=\"BoardCell\">\n                    <ElementMatrix\n                      analyzer={stateAnalyzer}\n                      cards={currentBoard[CardLocation.BetaReserve]}\n                      selectedCard={selectedCard}\n                      onCardClicked={this.onCardClicked}\n                    />\n                  </td>\n                </tr>\n              </tbody>\n            </table>\n          </div>\n          <div>\n            <h3>Plies</h3>\n            <ol className=\"Plies\">\n              <li>\n                <div className=\"PlyNumber\">\n                  {cardEmojis[CardType.BetaSnipe] + \"1\"}.\n                </div>{\" \"}\n                =\n                {initialBoard[CardLocation.BetaReserve].map(\n                  (card) => cardEmojis[card.cardType]\n                )}\n                ;{\" \"}\n                {initialBoard[CardLocation.Row6].map(\n                  (card) => cardEmojis[card.cardType]\n                )}\n                ;{\" \"}\n                {initialBoard[CardLocation.Row5].map(\n                  (card) => cardEmojis[card.cardType]\n                )}\n                ;{\" \"}\n                {initialBoard[CardLocation.Row4].map(\n                  (card) => cardEmojis[card.cardType]\n                )}\n              </li>\n              <li>\n                <div className=\"PlyNumber\">\n                  {cardEmojis[CardType.AlphaSnipe] + \"2\"}.\n                </div>{\" \"}\n                =\n                {initialBoard[CardLocation.AlphaReserve].map(\n                  (card) => cardEmojis[card.cardType]\n                )}\n                ;{\" \"}\n                {initialBoard[CardLocation.Row1].map(\n                  (card) => cardEmojis[card.cardType]\n                )}\n                ;{\" \"}\n                {initialBoard[CardLocation.Row2].map(\n                  (card) => cardEmojis[card.cardType]\n                )}\n                ;{\" \"}\n                {initialBoard[CardLocation.Row3].map(\n                  (card) => cardEmojis[card.cardType]\n                )}\n              </li>\n\n              {plies.map((ply, zeroBasedPlyNumber) => {\n                const plyNumber = zeroBasedPlyNumber + 3;\n                return <PlyView ply={ply} plyNumber={plyNumber} />;\n              })}\n\n              {stateAnalyzer.getPendingAnimalStep().match({\n                none: () => null,\n                some: (step) => (\n                  <AnimalStepView\n                    step={step}\n                    plyNumber={plies.length + 3}\n                    winner={stateAnalyzer.getWinner()}\n                  />\n                ),\n              })}\n\n              {stateAnalyzer.getWinner().match({\n                none: () => null,\n                some: (winner) => {\n                  const winnerEmoji = cardEmojis[gameUtil.snipeOf(winner)];\n                  const loserEmoji =\n                    cardEmojis[gameUtil.snipeOf(gameUtil.opponentOf(winner))];\n                  return winnerEmoji + \">\" + loserEmoji;\n                },\n              })}\n            </ol>\n            <h4>Future sub plies</h4>\n            <ol className=\"Plies\">{this.renderFutureSubPlies()}</ol>\n            <button onClick={this.onUndoSubPlyClicked}>Back</button>\n            <button onClick={this.onRedoSubPlyClicked}>Forward</button>\n          </div>\n          <button onClick={this.onResetGameClicked}>Reset</button>\n          <div>\n            <h3>\n              MCTS{\" \"}\n              {mctsState.isRunning ? (\n                <button onClick={this.onPauseAnalyzerClicked}>Pause</button>\n              ) : (\n                <button onClick={this.onResumeAnalyzerClicked}>Resume</button>\n              )}\n            </h3>\n\n            <div>\n              {this.state.thinkingTimeInMS.match({\n                none: () => (\n                  <div>\n                    <h4 className=\"Inline\">Time limit</h4>{\" \"}\n                    <input\n                      type=\"checkbox\"\n                      checked={false}\n                      onChange={this.onTimeLimitEnabledChange}\n                    />\n                  </div>\n                ),\n\n                some: (thinkingTimeInMS) => (\n                  <>\n                    <div>\n                      <label>\n                        <h4 className=\"Inline\">Time limit</h4>{\" \"}\n                        <input\n                          type=\"checkbox\"\n                          checked={true}\n                          onChange={this.onTimeLimitEnabledChange}\n                        />\n                      </label>\n                    </div>\n\n                    <div>\n                      <label>\n                        Seconds per turn:{\" \"}\n                        <input\n                          type=\"text\"\n                          className={\n                            isWellFormedDecimalInteger(\n                              this.state.thinkingTimeInputValue\n                            )\n                              ? \"\"\n                              : \"InvalidNumber\"\n                          }\n                          value={this.state.thinkingTimeInputValue}\n                          onChange={this.onThinkingTimeInputChange}\n                        />\n                      </label>\n                    </div>\n\n                    <div>\n                      <label>\n                        Seconds remaining for this turn:{\" \"}\n                        <span>\n                          {this.state.stopTime.match({\n                            none: () => \"Loading...\",\n                            some: (stopTime) => {\n                              const diff = stopTime - Date.now();\n                              const diffInSeconds = Math.ceil(diff * 1e-3);\n                              const clamped = Math.max(0, diffInSeconds);\n                              return \"\" + clamped;\n                            },\n                          })}\n                        </span>\n                      </label>\n                    </div>\n                  </>\n                ),\n              })}\n            </div>\n\n            {mctsState.isRunning\n              ? mctsState.mostRecentSnapshot.match({\n                  none: () =>\n                    stateAnalyzer.isGameOver() ? (\n                      <p>Game over</p>\n                    ) : (\n                      <p>Loading...</p>\n                    ),\n                  some: (analysis) => {\n                    const { bestAtomic } = analysis;\n                    const afterPerformingBest = getStateAnalyzer(\n                      stateAnalyzer.forcePerform(bestAtomic)\n                    );\n                    const currentStateMeanValue =\n                      analysis.currentStateValue /\n                      analysis.currentStateRollouts;\n                    const bestAtomicMeanValue =\n                      analysis.bestAtomicValue / analysis.bestAtomicRollouts;\n\n                    return (\n                      <>\n                        <h4>\n                          Best action (before: [v̅ ={\" \"}\n                          {currentStateMeanValue.toFixed(3)}, n ={\" \"}\n                          {analysis.currentStateRollouts}\n                          ], after: [v̅ = {bestAtomicMeanValue.toFixed(3)}, n ={\" \"}\n                          {analysis.bestAtomicRollouts}\n                          ]):\n                        </h4>\n                        {\"plyType\" in bestAtomic ? (\n                          <PlyView\n                            ply={bestAtomic}\n                            plyNumber={plies.length + 3}\n                          />\n                        ) : stateAnalyzer.getPendingAnimalStep().isSome() ? (\n                          <FutureAnimalStepView\n                            step={bestAtomic}\n                            plyNumber={plies.length + 3}\n                          />\n                        ) : (\n                          <AnimalStepView\n                            step={bestAtomic}\n                            plyNumber={plies.length + 3}\n                            winner={afterPerformingBest.getWinner()}\n                          />\n                        )}\n                      </>\n                    );\n                  },\n                })\n              : this.renderExpandableAnalysis(mctsState, plies.length + 2)}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  renderSnipesIn(cards: Card[]): React.ReactElement[] {\n    const selectedCardType = this.state.ux.selectedCardType.map((card) => card);\n    const snipes = cards.filter(\n      (card) =>\n        card.cardType === CardType.AlphaSnipe ||\n        card.cardType === CardType.BetaSnipe\n    );\n    return snipes.map((card) => {\n      const isSelected = selectedCardType.equalsSome(card.cardType);\n      return (\n        <CardView\n          key={card.cardType}\n          card={card}\n          isSelected={isSelected}\n          onCardClicked={this.onCardClicked}\n        />\n      );\n    });\n  }\n\n  renderTraditionalView(): React.ReactElement {\n    const stateAnalyzer = getStateAnalyzer(this.state.gameState);\n    const currentBoard = stateAnalyzer.getBoard();\n\n    return (\n      <table>\n        <tbody>\n          <tr>\n            <td>Reserve</td>\n            <td\n              className={\n                stateAnalyzer.isGameOver()\n                  ? \"\"\n                  : stateAnalyzer.getTurn() === Player.Alpha\n                  ? \"TurnIndicatorLight\"\n                  : \"\"\n              }\n            />\n            <td>{this.renderCards(currentBoard[CardLocation.AlphaReserve])}</td>\n          </tr>\n          <tr>\n            <td onClick={() => this.onRowNumberClicked(1)}>1</td>\n            <td>\n              {this.renderCards(currentBoard[CardLocation.Row1].filter(isBeta))}\n            </td>\n            <td>\n              {this.renderCards(\n                currentBoard[CardLocation.Row1].filter(isAlpha)\n              )}\n            </td>\n          </tr>\n          <tr>\n            <td onClick={() => this.onRowNumberClicked(2)}>2</td>\n            <td>\n              {this.renderCards(currentBoard[CardLocation.Row2].filter(isBeta))}\n            </td>\n            <td>\n              {this.renderCards(\n                currentBoard[CardLocation.Row2].filter(isAlpha)\n              )}\n            </td>\n          </tr>{\" \"}\n          <tr>\n            <td onClick={() => this.onRowNumberClicked(3)}>3</td>\n            <td>\n              {this.renderCards(currentBoard[CardLocation.Row3].filter(isBeta))}\n            </td>\n            <td>\n              {this.renderCards(\n                currentBoard[CardLocation.Row3].filter(isAlpha)\n              )}\n            </td>\n          </tr>{\" \"}\n          <tr>\n            <td onClick={() => this.onRowNumberClicked(4)}>4</td>\n            <td>\n              {this.renderCards(currentBoard[CardLocation.Row4].filter(isBeta))}\n            </td>\n            <td>\n              {this.renderCards(\n                currentBoard[CardLocation.Row4].filter(isAlpha)\n              )}\n            </td>\n          </tr>{\" \"}\n          <tr>\n            <td onClick={() => this.onRowNumberClicked(5)}>5</td>\n            <td>\n              {this.renderCards(currentBoard[CardLocation.Row5].filter(isBeta))}\n            </td>\n            <td>\n              {this.renderCards(\n                currentBoard[CardLocation.Row5].filter(isAlpha)\n              )}\n            </td>\n          </tr>{\" \"}\n          <tr>\n            <td onClick={() => this.onRowNumberClicked(6)}>6</td>\n            <td>\n              {this.renderCards(currentBoard[CardLocation.Row6].filter(isBeta))}\n            </td>\n            <td>\n              {this.renderCards(\n                currentBoard[CardLocation.Row6].filter(isAlpha)\n              )}\n            </td>\n          </tr>\n          <tr>\n            <td>Reserve</td>\n            <td\n              className={\n                stateAnalyzer.isGameOver()\n                  ? \"\"\n                  : stateAnalyzer.getTurn() === Player.Beta\n                  ? \"TurnIndicatorLight\"\n                  : \"\"\n              }\n            />\n            <td>{this.renderCards(currentBoard[CardLocation.BetaReserve])}</td>\n          </tr>\n        </tbody>\n      </table>\n    );\n  }\n\n  renderCards(cards: Card[]): React.ReactElement[] {\n    return cards.map((card) => (\n      <CardView\n        key={card.cardType}\n        card={card}\n        isSelected={this.state.ux.selectedCardType.match({\n          none: () => false,\n          some: (selectedCardType) => selectedCardType === card.cardType,\n        })}\n        onCardClicked={() => this.onCardClicked(card)}\n      />\n    ));\n  }\n\n  renderFutureSubPlies() {\n    const chronological = this.state.ux.futureSubPlyStack.atomics\n      .slice()\n      .reverse();\n    let preTurnsAnimalStep: Option<AnimalStep> = option.none();\n    const turns: Ply[] = [];\n    let postTurnsAnimalStep: Option<AnimalStep> = option.none();\n\n    let i = 0;\n    while (i < chronological.length) {\n      const next = chronological[i];\n\n      if (\"plyType\" in next) {\n        turns.push(next);\n        i++;\n      } else if (i + 1 < chronological.length) {\n        i++;\n        const nextNext = chronological[i];\n\n        if (\"plyType\" in nextNext) {\n          preTurnsAnimalStep = option.some(next);\n\n          turns.push(nextNext);\n          i++;\n        } else {\n          turns.push({\n            plyType: PlyType.TwoAnimalSteps,\n            first: next,\n            second: nextNext,\n          });\n          i++;\n        }\n      } else {\n        postTurnsAnimalStep = option.some(next);\n        i++;\n      }\n    }\n\n    const { plies } = this.state.gameState;\n    const stateAnalyzer = getStateAnalyzer(this.state.gameState);\n\n    return (\n      <>\n        {preTurnsAnimalStep.match({\n          none: () => null,\n          some: (step) => (\n            <FutureAnimalStepView step={step} plyNumber={plies.length + 3} />\n          ),\n        })}\n\n        {turns.map((ply, i) => (\n          <PlyView\n            ply={ply}\n            plyNumber={\n              plies.length +\n              3 +\n              preTurnsAnimalStep.match({ none: () => 0, some: () => 1 }) +\n              i\n            }\n          />\n        ))}\n\n        {postTurnsAnimalStep.match({\n          none: () => null,\n          some: (step) => (\n            <AnimalStepView\n              step={step}\n              plyNumber={\n                plies.length +\n                3 +\n                preTurnsAnimalStep.match({ none: () => 0, some: () => 1 }) +\n                turns.length\n              }\n              winner={getStateAnalyzer(\n                stateAnalyzer.forcePerform(step)\n              ).getWinner()}\n            />\n          ),\n        })}\n      </>\n    );\n  }\n\n  renderExpandableAnalysis(\n    mctsState: MctsPausedState,\n    plyNumber: number\n  ): React.ReactElement {\n    const isTherePendingAnimalStep = getStateAnalyzer(this.state.gameState)\n      .getPendingAnimalStep()\n      .isSome();\n\n    const mctsAnalyzer = mctsState.analyzer;\n    const rootSummary = mctsAnalyzer.getNodeSummary(\n      mctsAnalyzer.getRootPointer()\n    );\n\n    return (\n      <AnalysisNode\n        analyzer={mctsAnalyzer}\n        suggestionDetailLevels={this.state.ux.analysisSuggestionDetailLevels}\n        plyNumber={plyNumber}\n        isTherePendingAnimalStep={isTherePendingAnimalStep}\n        viewedNode={rootSummary}\n        onDetailLevelChange={this.onDetailLevelChange}\n      />\n    );\n  }\n\n  onCardClicked(clicked: Card): void {\n    const stateAnalyzer = getStateAnalyzer(this.state.gameState);\n    if (clicked.allegiance !== stateAnalyzer.getTurn()) {\n      return;\n    }\n\n    const { selectedCardType } = this.state.ux;\n    const isClickedCardAlreadySelected = selectedCardType.someSatisfies(\n      (selectedType) => selectedType === clicked.cardType\n    );\n    if (isClickedCardAlreadySelected) {\n      this.updateUxState({ selectedCardType: option.none() });\n    } else {\n      this.updateUxState({ selectedCardType: option.some(clicked.cardType) });\n    }\n  }\n\n  updateUxState(newUxState: Partial<AppState[\"ux\"]>): void {\n    this.setState((prevState) => {\n      const newState = {\n        ...prevState,\n        ux: {\n          ...prevState.ux,\n          ...newUxState,\n        },\n      };\n      futureSubPlyStackSaver.setState(newState.ux.futureSubPlyStack);\n      return newState;\n    });\n  }\n\n  onRowNumberClicked(row: Row): void {\n    const stateAnalyzer = getStateAnalyzer(this.state.gameState);\n\n    if (stateAnalyzer.isGameOver()) {\n      return;\n    }\n\n    const { selectedCardType: selectedCard } = this.state.ux;\n\n    selectedCard.ifSome((selected) => {\n      this.updateUxState({\n        futureSubPlyStack: {\n          stateVersion: STATE_VERSION,\n          atomics: this.state.ux.futureSubPlyStack.atomics.slice(0, -1),\n        },\n      });\n\n      const location = stateAnalyzer.getCardLocation(selected);\n      if (gameUtil.isReserve(location)) {\n        this.tryDrop(selected as AnimalType, row);\n      } else {\n        if (\n          selected === CardType.AlphaSnipe ||\n          selected === CardType.BetaSnipe\n        ) {\n          this.trySnipeStep(row);\n        } else {\n          this.tryAnimalStep(selected, row);\n        }\n      }\n    });\n  }\n\n  tryDrop(selected: AnimalType, destination: Row): void {\n    const stateAnalyzer = getStateAnalyzer(this.state.gameState);\n    const drop: Drop = {\n      plyType: PlyType.Drop,\n      dropped: selected,\n      destination,\n    };\n\n    const dropResult = stateAnalyzer.tryPerform(drop);\n    this.updateGameStateOrAlertError(dropResult);\n  }\n\n  updateGameStateOrAlertError(\n    res: Result<GameState, IllegalGameStateUpdate>\n  ): void {\n    res.match({\n      ok: (newGameState) => {\n        this.saveAndUpdateGameState(newGameState);\n        this.updateUxState({ selectedCardType: option.none() });\n      },\n      err: (errorCode) => {\n        alert(IllegalGameStateUpdate[errorCode]);\n        this.updateUxState({ selectedCardType: option.none() });\n      },\n    });\n  }\n\n  trySnipeStep(destination: Row): void {\n    const stateAnalyzer = getStateAnalyzer(this.state.gameState);\n    const step: SnipeStep = {\n      plyType: PlyType.SnipeStep,\n      destination,\n    };\n\n    const stepResult = stateAnalyzer.tryPerform(step);\n    this.updateGameStateOrAlertError(stepResult);\n  }\n\n  tryAnimalStep(selected: AnimalType, destination: Row): void {\n    const stateAnalyzer = getStateAnalyzer(this.state.gameState);\n    const step: AnimalStep = {\n      moved: selected,\n      destination,\n    };\n\n    const stepResult = stateAnalyzer.tryPerform(step);\n    this.updateGameStateOrAlertError(stepResult);\n  }\n\n  onUndoSubPlyClicked(): void {\n    const stateAnalyzer = getStateAnalyzer(this.state.gameState);\n\n    const undoResult = stateAnalyzer.tryUndoSubPly();\n    undoResult.match({\n      ok: ({ newState: newGameState, undone }) => {\n        this.updateUxState({\n          futureSubPlyStack: this.getFutureSubPlyStackAfterUndoing(undone),\n        });\n\n        this.saveAndUpdateGameState(newGameState);\n      },\n\n      err: (errorCode) => {\n        alert(IllegalGameStateUpdate[errorCode]);\n      },\n    });\n  }\n\n  getFutureSubPlyStackAfterUndoing(\n    undone: Atomic\n  ): AppState[\"ux\"][\"futureSubPlyStack\"] {\n    const stack = this.state.ux.futureSubPlyStack;\n\n    return {\n      stateVersion: stack.stateVersion,\n      atomics: stack.atomics.concat([undone]),\n    };\n  }\n\n  onRedoSubPlyClicked(): void {\n    const { futureSubPlyStack } = this.state.ux;\n    const { atomics } = futureSubPlyStack;\n\n    if (atomics.length === 0) {\n      alert(\"Nothing to redo.\");\n      return;\n    }\n\n    const nextAtomic = atomics[atomics.length - 1];\n    const stateAnalyzer = getStateAnalyzer(this.state.gameState);\n    const redoResult = stateAnalyzer.tryPerform(nextAtomic);\n\n    this.updateGameStateOrAlertError(redoResult);\n\n    redoResult.ifOk(() => {\n      this.updateUxState({\n        futureSubPlyStack: {\n          stateVersion: futureSubPlyStack.stateVersion,\n          atomics: atomics.slice(0, -1),\n        },\n      });\n    });\n  }\n\n  onResetGameClicked(): void {\n    if (window.confirm(\"Are you sure you want to reset?\")) {\n      const gameState = gameUtil.getRandomGameState();\n      const state: AppState = {\n        gameState,\n        ux: {\n          selectedCardType: option.none(),\n          futureSubPlyStack: {\n            stateVersion: STATE_VERSION,\n            atomics: [],\n          },\n          analysisSuggestionDetailLevels: {},\n        },\n        mctsState: { isRunning: true, mostRecentSnapshot: option.none() },\n        thinkingTimeInMS: option.none(),\n        thinkingTimeInputValue: \"\",\n        stopTime: option.none(),\n      };\n\n      gameStateSaver.setState(gameState);\n      futureSubPlyStackSaver.setState(state.ux.futureSubPlyStack);\n      thinkingTimeSaver.setState(state.thinkingTimeInMS);\n\n      this.setState(state);\n      this.mctsService.updateGameState(gameState, state.thinkingTimeInMS);\n    }\n  }\n\n  isBestAtomicLegal({ bestAtomic }: MctsAnalysisSnapshot): boolean {\n    const legal = getStateAnalyzer(this.state.gameState)\n      .tryPerform(bestAtomic)\n      .isOk();\n    if (!legal) {\n      console.log(\"outdated best atomic\", bestAtomic);\n    }\n    return legal;\n  }\n\n  onMctsServiceSnapshot(analysis: Option<MctsAnalysisSnapshot>): void {\n    if (this.state.mctsState.isRunning) {\n      this.setState({\n        mctsState: {\n          isRunning: true,\n          mostRecentSnapshot: analysis.filter(this.isBestAtomicLegal),\n        },\n      });\n    }\n  }\n\n  onMctsServicePause(analyzer: MctsAnalyzer): void {\n    this.setState({\n      mctsState: { isRunning: false, analyzer, expandedNodeIndexes: [] },\n    });\n\n    this.resetAnalysisSuggestionDetailLevels(analyzer);\n  }\n\n  resetAnalysisSuggestionDetailLevels(analyzer: MctsAnalyzer) {\n    const rootPointer = analyzer.getRootPointer();\n    const bestChildPointer = analyzer.getChildPointersFromBestToWorst(\n      rootPointer\n    )[0];\n    const bestChildAtomic = analyzer\n      .getNodeSummary(bestChildPointer)\n      .atomic.expect(\"Impossible: Child node has no atomic.\");\n\n    if (\n      gameUtil.isAnimalStep(bestChildAtomic) &&\n      !this.state.gameState.pendingAnimalStep\n    ) {\n      this.updateUxState({\n        analysisSuggestionDetailLevels: {\n          [pointerToIndex(rootPointer)]: SuggestionDetailLevel.BestAction,\n          [pointerToIndex(bestChildPointer)]: SuggestionDetailLevel.BestAction,\n        },\n      });\n    } else {\n      this.updateUxState({\n        analysisSuggestionDetailLevels: {\n          [pointerToIndex(rootPointer)]: SuggestionDetailLevel.BestAction,\n        },\n      });\n    }\n  }\n\n  onPauseAnalyzerClicked(): void {\n    this.mctsService.pause();\n  }\n\n  onResumeAnalyzerClicked(): void {\n    const { mctsState } = this.state;\n    if (!mctsState.isRunning) {\n      this.setState({\n        mctsState: {\n          isRunning: true,\n          mostRecentSnapshot: option.some(mctsState.analyzer.getSnapshot()),\n        },\n      });\n\n      this.mctsService.resume(mctsState.analyzer);\n    }\n  }\n\n  onDetailLevelChange(\n    pointer: NodePointer,\n    detailLevel: SuggestionDetailLevel\n  ): void {\n    this.updateUxState({\n      analysisSuggestionDetailLevels: {\n        ...this.state.ux.analysisSuggestionDetailLevels,\n        [pointerToIndex(pointer)]: detailLevel,\n      },\n    });\n  }\n\n  onTimeLimitEnabledChange(event: React.ChangeEvent<HTMLInputElement>): void {\n    if (event.target.checked && this.state.thinkingTimeInMS.isNone()) {\n      this.saveAndUpdateThinkingTime(option.some(DEFAULT_THINKING_TIME_IN_MS));\n    }\n\n    if (!event.target.checked && this.state.thinkingTimeInMS.isSome()) {\n      this.saveAndUpdateThinkingTime(option.none());\n    }\n  }\n\n  saveAndUpdateThinkingTime(thinkingTimeInMS: Option<number>): void {\n    this.setState({\n      thinkingTimeInMS,\n      thinkingTimeInputValue: thinkingTimeInMS.match({\n        none: () => \"\",\n        some: (timeInMS) => \"\" + timeInMS * 1e-3,\n      }),\n    });\n    thinkingTimeSaver.setState(thinkingTimeInMS);\n  }\n\n  onThinkingTimeInputChange(event: React.ChangeEvent<HTMLInputElement>): void {\n    const { value } = event.target;\n    const parsed = parseInt(value, 10);\n    const parsedInMilliseconds = parsed * 1e3;\n    if (parsedInMilliseconds > 0 && isWellFormedDecimalInteger(value)) {\n      this.saveAndUpdateThinkingTime(option.some(parsedInMilliseconds));\n    } else {\n      this.setState({ thinkingTimeInputValue: event.target.value });\n    }\n  }\n\n  onMctsServiceOnStopTimeChange(stopTime: Option<number>) {\n    this.setState({ stopTime });\n  }\n}\n\nfunction loadState(): AppState {\n  const gameState = gameStateSaver.getState().unwrapOrElse(() => {\n    const newGameState = gameUtil.getRandomGameState();\n    gameStateSaver.setState(newGameState);\n    return newGameState;\n  });\n  const futureSubPlyStack = futureSubPlyStackSaver\n    .getState()\n    .unwrapOrElse(() => {\n      const newStack: FutureSubPlyStack = {\n        stateVersion: STATE_VERSION,\n        atomics: [],\n      };\n      futureSubPlyStackSaver.setState(newStack);\n      return newStack;\n    });\n  const thinkingTimeInMS: Option<number> = thinkingTimeSaver\n    .getState()\n    .unwrapOrElse(() => option.none());\n\n  return {\n    gameState,\n    ux: {\n      selectedCardType: option.none(),\n      futureSubPlyStack,\n      analysisSuggestionDetailLevels: {},\n    },\n    mctsState: { isRunning: true, mostRecentSnapshot: option.none() },\n    thinkingTimeInMS,\n    thinkingTimeInputValue: thinkingTimeInMS.match({\n      none: () => \"\",\n      some: (timeInMS) => \"\" + timeInMS * 1e-3,\n    }),\n    stopTime: option.none(),\n  };\n}\n\nfunction isAlpha(card: Card): boolean {\n  return card.allegiance === Player.Alpha;\n}\n\nfunction isBeta(card: Card): boolean {\n  return card.allegiance === Player.Beta;\n}\n\n/** Leading zeros are not allowed. */\nfunction isWellFormedDecimalInteger(s: string): boolean {\n  return /^\\d+$/.test(s) && !/^0\\d/.test(s);\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nimport * as analyzer from \"./stateAnalyzer\";\nimport * as mcts from \"./mcts\";\nimport * as gameUtil from \"./gameUtil\";\nimport { CardType, MctsWorkerMessageType } from \"./types\";\n\n(window as any).analyzer = analyzer;\n(window as any).mcts = mcts;\n(window as any).gameUtil = gameUtil;\n(window as any).CardType = CardType;\n(window as any).WorkerMessageType = MctsWorkerMessageType;\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}